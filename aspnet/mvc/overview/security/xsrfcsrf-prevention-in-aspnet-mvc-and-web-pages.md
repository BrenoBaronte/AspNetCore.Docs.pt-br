---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: Prevenção de XSRF/CSRF no ASP.NET MVC e páginas da Web | Microsoft Docs
author: Rick-Anderson
description: Falsificação de solicitação entre sites (também conhecido como XSRF ou CSRF) é um ataque contra aplicativos web hospedados no qual um site mal-intencionado pode influenciar o interacti...
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/14/2013
ms.topic: article
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 6cf30daa7ed966b11405cec715c5bc803b567249
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/10/2018
---
<a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="c7d12-103">Prevenção de XSRF/CSRF no ASP.NET MVC e páginas da Web</span><span class="sxs-lookup"><span data-stu-id="c7d12-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>
====================
<span data-ttu-id="c7d12-104">por [Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="c7d12-104">by [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

> <span data-ttu-id="c7d12-105">Solicitação intersite forjada (também conhecido como XSRF ou CSRF) é um ataque contra aplicativos web hospedados no qual um site mal-intencionado pode influenciar a interação entre o navegador do cliente e um site confiada pelo navegador.</span><span class="sxs-lookup"><span data-stu-id="c7d12-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="c7d12-106">Esses ataques são possibilitados como navegadores da web enviará tokens de autenticação automaticamente com todas as solicitações para um site da web.</span><span class="sxs-lookup"><span data-stu-id="c7d12-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="c7d12-107">O exemplo canônico é um cookie de autenticação, como ASP. Tíquete de autenticação de formulários do NET.</span><span class="sxs-lookup"><span data-stu-id="c7d12-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="c7d12-108">No entanto, os sites da web que use qualquer mecanismo de autenticação persistente (como a autenticação do Windows, Basic e assim por diante) podem ser afetados por esses ataques.</span><span class="sxs-lookup"><span data-stu-id="c7d12-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="c7d12-109">Um ataque XSRF é diferente de um ataque de phishing.</span><span class="sxs-lookup"><span data-stu-id="c7d12-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="c7d12-110">Ataques de phishing requerem interação da vítima.</span><span class="sxs-lookup"><span data-stu-id="c7d12-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="c7d12-111">Em um ataque de phishing, um site mal-intencionado imitarão o site de destino e a vítima é levada a fornecer informações confidenciais ao invasor.</span><span class="sxs-lookup"><span data-stu-id="c7d12-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="c7d12-112">Em um ataque de XSRF, geralmente há nenhuma interação necessárias da vítima.</span><span class="sxs-lookup"><span data-stu-id="c7d12-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="c7d12-113">Em vez disso, o invasor depende do navegador automaticamente enviar todos os cookies relevantes para o site de destino.</span><span class="sxs-lookup"><span data-stu-id="c7d12-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="c7d12-114">Para obter mais informações, consulte o [Abrir projeto de segurança do aplicativo Web](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span><span class="sxs-lookup"><span data-stu-id="c7d12-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>


## <a name="anatomy-of-an-attack"></a><span data-ttu-id="c7d12-115">Anatomia de um ataque</span><span class="sxs-lookup"><span data-stu-id="c7d12-115">Anatomy of an attack</span></span>

<span data-ttu-id="c7d12-116">Para percorrer um ataque XSRF, considere um usuário que deseja executar algumas transações bancárias online.</span><span class="sxs-lookup"><span data-stu-id="c7d12-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="c7d12-117">Este usuário acessa primeiro WoodgroveBank.com e os logs em, no ponto em que o cabeçalho de resposta conterá o cookie de autenticação:</span><span class="sxs-lookup"><span data-stu-id="c7d12-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="c7d12-118">Como o cookie de autenticação é um cookie de sessão, ele será automaticamente excluído pelo navegador quando o processo do navegador.</span><span class="sxs-lookup"><span data-stu-id="c7d12-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="c7d12-119">No entanto, até esse momento, o navegador automaticamente incluirá o cookie com cada solicitação para WoodgroveBank.com. Agora, o usuário deseja transferir $1000 para outra conta, para que ela preenche um formulário no site de serviços bancários, e o navegador faz a solicitação para o servidor:</span><span class="sxs-lookup"><span data-stu-id="c7d12-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com. The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="c7d12-120">Como essa operação não tem um efeito colateral (ele inicia uma transação monetária), o site de serviços bancários escolheu solicitar um HTTP POST para iniciar essa operação.</span><span class="sxs-lookup"><span data-stu-id="c7d12-120">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="c7d12-121">O servidor lê o token de autenticação da solicitação, pesquise o número da conta do usuário atual, verifica se os fundos existe e, em seguida, inicia a transação para a conta de destino.</span><span class="sxs-lookup"><span data-stu-id="c7d12-121">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="c7d12-122">Ela bancárias online concluída, o usuário navega para fora do site de serviços bancários e outros locais de visitas na web.</span><span class="sxs-lookup"><span data-stu-id="c7d12-122">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="c7d12-123">Um desses sites – fabrikam.com – inclui a seguinte marcação em uma página inserida em uma &lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="c7d12-123">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="c7d12-124">Que faz com que o navegador fazer essa solicitação:</span><span class="sxs-lookup"><span data-stu-id="c7d12-124">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="c7d12-125">O invasor está explorando o fato de que o usuário ainda poderá ter um token de autenticação válido para o site de destino, e ela está usando um pequeno trecho de Javascript para fazer com que o navegador tornar um HTTP POST para o site de destino automaticamente.</span><span class="sxs-lookup"><span data-stu-id="c7d12-125">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="c7d12-126">Se o token de autenticação ainda é válido, o site de serviços bancários iniciará uma transferência de US $250 para a conta de invasores.</span><span class="sxs-lookup"><span data-stu-id="c7d12-126">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="c7d12-127">Atenuantes ineficazes</span><span class="sxs-lookup"><span data-stu-id="c7d12-127">Ineffective mitigations</span></span>

<span data-ttu-id="c7d12-128">É interessante observar que, no cenário anterior, o fato que WoodgroveBank.com estava sendo acessado via SSL e teve um cookie de autenticação somente SSL foi suficiente para impedir o ataque.</span><span class="sxs-lookup"><span data-stu-id="c7d12-128">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="c7d12-129">O invasor for capaz de especificar o [esquema URI](http://en.wikipedia.org/wiki/URI_scheme) (https) em sua &lt;formulário&gt; elemento e o navegador continuará a enviar cookies não expirados ao site de destino, desde que esses cookies são consistentes com o URI esquema de destino pretendido.</span><span class="sxs-lookup"><span data-stu-id="c7d12-129">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="c7d12-130">Alguém poderia argumentar que o usuário simplesmente não visite sites não confiáveis, como visitar somente sites confiáveis é ajuda a permaneçam seguros online.</span><span class="sxs-lookup"><span data-stu-id="c7d12-130">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="c7d12-131">Há um fundo de verdade isso, mas infelizmente esse aviso nem sempre é prático.</span><span class="sxs-lookup"><span data-stu-id="c7d12-131">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="c7d12-132">Talvez o usuário "confia" do site de notícias locais ConsolidatedMessenger.</span><span class="sxs-lookup"><span data-stu-id="c7d12-132">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="c7d12-133">ConsolidatedMessenger.com e vai para a visita do site em vez disso, mas esse site tem uma vulnerabilidade XSS que permite que um invasor inserir o mesmo trecho de código que estava em execução no fabrikam.com.</span><span class="sxs-lookup"><span data-stu-id="c7d12-133">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="c7d12-134">Você pode verificar se as solicitações de entrada tem um [cabeçalho de referenciador](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) fazendo referência a seu domínio.</span><span class="sxs-lookup"><span data-stu-id="c7d12-134">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="c7d12-135">Isso interromperá a solicitações inadvertidamente enviadas de um domínio de terceiro.</span><span class="sxs-lookup"><span data-stu-id="c7d12-135">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="c7d12-136">No entanto, algumas pessoas desabilitar o cabeçalho de referenciador do seu navegador por motivos de privacidade e os invasores às vezes podem falsificar esse cabeçalho se vítima tem determinados inseguro software instalado.</span><span class="sxs-lookup"><span data-stu-id="c7d12-136">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="c7d12-137">Verificando o [cabeçalho de referenciador](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) não é considerado uma abordagem segura para evitar ataques XSRF.</span><span class="sxs-lookup"><span data-stu-id="c7d12-137">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="c7d12-138">Reduções de pilha em tempo de execução XSRF da Web</span><span class="sxs-lookup"><span data-stu-id="c7d12-138">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="c7d12-139">O tempo de execução de pilha do ASP.NET Web usa uma variante do [padrão de token sincronizador](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) para proteção contra ataques XSRF.</span><span class="sxs-lookup"><span data-stu-id="c7d12-139">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="c7d12-140">A forma geral do padrão de token sincronizador é que os dois tokens de anti-XSRF sejam enviados para o servidor com cada HTTP POST (além do token de autenticação): um token como um cookie e o outro como um valor de formulário.</span><span class="sxs-lookup"><span data-stu-id="c7d12-140">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="c7d12-141">Os valores do token gerados pelo tempo de execução do ASP.NET não são determinísticas ou previsível por um invasor.</span><span class="sxs-lookup"><span data-stu-id="c7d12-141">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="c7d12-142">Quando os tokens são enviados, o servidor permitirá que a solicitação avance somente se ambos os tokens passam em uma verificação de comparação.</span><span class="sxs-lookup"><span data-stu-id="c7d12-142">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="c7d12-143">A verificação de solicitação XSRF *o token de sessão* é armazenado como um cookie HTTP e contém as seguintes informações na sua carga:</span><span class="sxs-lookup"><span data-stu-id="c7d12-143">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="c7d12-144">Um token de segurança, consiste em um identificador de 128 bits aleatório.</span><span class="sxs-lookup"><span data-stu-id="c7d12-144">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="c7d12-145">A imagem a seguir mostra o token de sessão de verificação do XSRF solicitação exibido com as ferramentas de desenvolvedor F12 do Internet Explorer: (Observe que esta é a implementação atual e é um assunto, provavelmente, será alterado.)</span><span class="sxs-lookup"><span data-stu-id="c7d12-145">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="c7d12-146">O *token de campo* é armazenado como um `<input type="hidden" />` e contém as seguintes informações na sua carga:</span><span class="sxs-lookup"><span data-stu-id="c7d12-146">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="c7d12-147">Nome do usuário conectado (se autenticado).</span><span class="sxs-lookup"><span data-stu-id="c7d12-147">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="c7d12-148">Dados adicionais fornecidos por um [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span><span class="sxs-lookup"><span data-stu-id="c7d12-148">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="c7d12-149">As cargas dos tokens de anti-XSRF estão criptografadas e assinadas, para que você não pode exibir o nome de usuário ao usar as ferramentas para examinar os tokens.</span><span class="sxs-lookup"><span data-stu-id="c7d12-149">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="c7d12-150">Quando o aplicativo web está direcionando o ASP.NET 4.0, os serviços de criptografia são fornecidos pelo [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) rotina.</span><span class="sxs-lookup"><span data-stu-id="c7d12-150">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="c7d12-151">Quando o aplicativo web está voltado para ASP.NET 4.5 ou superior de serviços criptográficos fornecidos pelo [Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) rotina, que oferece melhor desempenho, segurança e extensibilidade.</span><span class="sxs-lookup"><span data-stu-id="c7d12-151">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="c7d12-152">Consulte que postagens de blog a seguir para obter mais detalhes:</span><span class="sxs-lookup"><span data-stu-id="c7d12-152">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="c7d12-153">Aprimoramentos de criptografia no ASP.NET 4.5, pt. 1</span><span class="sxs-lookup"><span data-stu-id="c7d12-153">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="c7d12-154">Aprimoramentos de criptografia no ASP.NET 4.5, pt. 2</span><span class="sxs-lookup"><span data-stu-id="c7d12-154">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="c7d12-155">Aprimoramentos de criptografia no ASP.NET 4.5, pt. 3</span><span class="sxs-lookup"><span data-stu-id="c7d12-155">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="c7d12-156">Geração de tokens</span><span class="sxs-lookup"><span data-stu-id="c7d12-156">Generating the tokens</span></span>

<span data-ttu-id="c7d12-157">Para gerar tokens de anti-XSRF, chame o [ @Html.AntiForgeryToken ](https://msdn.microsoft.com/library/dd470175.aspx) método de um modo de exibição do MVC ou @AntiForgery.GetHtml() de uma página do Razor.</span><span class="sxs-lookup"><span data-stu-id="c7d12-157">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="c7d12-158">O tempo de execução, em seguida, executará as seguintes etapas:</span><span class="sxs-lookup"><span data-stu-id="c7d12-158">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="c7d12-159">Se a solicitação HTTP atual já contém um token de sessão de anti-XSRF (o cookie de anti-XSRF \_ \_RequestVerificationToken), o token de segurança é extraído dele.</span><span class="sxs-lookup"><span data-stu-id="c7d12-159">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="c7d12-160">Se a solicitação HTTP não contém um token de sessão de anti-XSRF ou se uma falha na extração do token de segurança, um novo token anti-XSRF aleatória será gerado.</span><span class="sxs-lookup"><span data-stu-id="c7d12-160">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="c7d12-161">Um token de campo de anti-XSRF é gerado usando o token de segurança da etapa (1) acima e a identidade do usuário atual fez logon.</span><span class="sxs-lookup"><span data-stu-id="c7d12-161">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="c7d12-162">(Para obter mais informações sobre como determinar a identidade do usuário, consulte o **[cenários com suporte especial](#_Scenarios_with_special)** seção abaixo.) Além disso, se um [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) é configurado, o tempo de execução chamará o [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) método e incluir a cadeia de caracteres retornada no token de campo.</span><span class="sxs-lookup"><span data-stu-id="c7d12-162">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="c7d12-163">(Consulte o **[configuração e extensibilidade](#_Configuration_and_extensibility)** para obter mais informações.)</span><span class="sxs-lookup"><span data-stu-id="c7d12-163">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="c7d12-164">Se um novo token anti-XSRF foi gerado na etapa (1), um token de nova sessão será criado para contê-lo e será adicionado à coleção de cookies HTTP de saída.</span><span class="sxs-lookup"><span data-stu-id="c7d12-164">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="c7d12-165">O token de campo da etapa (2) será encapsulado em um `<input type="hidden" />` elemento e essa marcação HTML será o valor de retorno `Html.AntiForgeryToken()` ou `AntiForgery.GetHtml()`.</span><span class="sxs-lookup"><span data-stu-id="c7d12-165">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="c7d12-166">Valida os tokens</span><span class="sxs-lookup"><span data-stu-id="c7d12-166">Validating the tokens</span></span>

<span data-ttu-id="c7d12-167">Para validar os tokens de anti-XSRF a entrada, o desenvolvedor inclui um [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) atributo em sua ação do MVC ou controlador ou chamadas she `@AntiForgery.Validate()` da sua página de Razor.</span><span class="sxs-lookup"><span data-stu-id="c7d12-167">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="c7d12-168">O tempo de execução executará as seguintes etapas:</span><span class="sxs-lookup"><span data-stu-id="c7d12-168">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="c7d12-169">O token de sessão de entrada e o token de campo são lidos e o token anti-XSRF extraídos de cada um.</span><span class="sxs-lookup"><span data-stu-id="c7d12-169">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="c7d12-170">Os tokens de anti-XSRF devem ser idênticos por etapa (2) na rotina de geração.</span><span class="sxs-lookup"><span data-stu-id="c7d12-170">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="c7d12-171">Se o usuário atual é autenticado, seu nome de usuário é comparado com o nome de usuário armazenado no token de campo.</span><span class="sxs-lookup"><span data-stu-id="c7d12-171">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="c7d12-172">Os nomes de usuário devem corresponder.</span><span class="sxs-lookup"><span data-stu-id="c7d12-172">The usernames must match.</span></span>
3. <span data-ttu-id="c7d12-173">Se um [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) estiver configurado, o tempo de execução chama seu *ValidateAdditionalData* método.</span><span class="sxs-lookup"><span data-stu-id="c7d12-173">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="c7d12-174">O método deve retornar o valor booliano *true*.</span><span class="sxs-lookup"><span data-stu-id="c7d12-174">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="c7d12-175">Se a validação for bem-sucedida, a solicitação pode continuar.</span><span class="sxs-lookup"><span data-stu-id="c7d12-175">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="c7d12-176">Se a validação falhar, o framework lançará um *HttpAntiForgeryException*.</span><span class="sxs-lookup"><span data-stu-id="c7d12-176">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="c7d12-177">Condições de falha</span><span class="sxs-lookup"><span data-stu-id="c7d12-177">Failure conditions</span></span>

<span data-ttu-id="c7d12-178">Começando com o ASP.NET Web pilha Runtime v2, qualquer *HttpAntiForgeryException* que é lançada durante a validação conterá informações detalhadas sobre o que deu errado.</span><span class="sxs-lookup"><span data-stu-id="c7d12-178">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="c7d12-179">As condições de falha definidos atualmente são:</span><span class="sxs-lookup"><span data-stu-id="c7d12-179">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="c7d12-180">O token de sessão ou um token de formulário não está presente na solicitação.</span><span class="sxs-lookup"><span data-stu-id="c7d12-180">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="c7d12-181">O token de sessão ou um token de formulário é ilegível.</span><span class="sxs-lookup"><span data-stu-id="c7d12-181">The session token or form token is unreadable.</span></span> <span data-ttu-id="c7d12-182">A causa mais provável disso é um farm executando versões incompatíveis do Runtime de pilha da Web ASP.NET ou um farm onde o &lt;machineKey&gt; elemento no Web. config é diferente entre as máquinas.</span><span class="sxs-lookup"><span data-stu-id="c7d12-182">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="c7d12-183">Você pode usar uma ferramenta como o Fiddler para forçar essa exceção viole o token anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="c7d12-183">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="c7d12-184">O token de sessão e o token de campo foram trocadas.</span><span class="sxs-lookup"><span data-stu-id="c7d12-184">The session token and field token were swapped.</span></span>
- <span data-ttu-id="c7d12-185">O token de sessão e o token de campo contém tokens de segurança incompatível.</span><span class="sxs-lookup"><span data-stu-id="c7d12-185">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="c7d12-186">O nome de usuário inserido dentro do token de campo não coincide com nome de usuário fez logon do usuário atual.</span><span class="sxs-lookup"><span data-stu-id="c7d12-186">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="c7d12-187">O *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* retornados pelo método *false*.</span><span class="sxs-lookup"><span data-stu-id="c7d12-187">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="c7d12-188">As instalações de anti-XSRF também podem executar a verificação adicional durante a geração de token ou validação e falhas durante essas verificações podem resultar em exceções que está sendo geradas.</span><span class="sxs-lookup"><span data-stu-id="c7d12-188">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="c7d12-189">Consulte o [WIF / ACS / baseada em declarações autenticação](#_WIF_ACS) e **[configuração e extensibilidade](#_Configuration_and_extensibility)** seções para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="c7d12-189">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="c7d12-190">Cenários com suporte especial</span><span class="sxs-lookup"><span data-stu-id="c7d12-190">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="c7d12-191">Autenticação anônima</span><span class="sxs-lookup"><span data-stu-id="c7d12-191">Anonymous authentication</span></span>

<span data-ttu-id="c7d12-192">O sistema de anti-XSRF contém suporte especial para usuários anônimos, onde o "anônimo" é definido como um usuário onde o *IIdentity.IsAuthenticated* propriedade retorna *false*.</span><span class="sxs-lookup"><span data-stu-id="c7d12-192">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="c7d12-193">Os cenários incluem fornecendo proteção XSRF à página de logon (antes que o usuário é autenticado) e esquemas de autenticação personalizada em que o aplicativo usa um mecanismo diferente de *IIdentity* para identificar os usuários.</span><span class="sxs-lookup"><span data-stu-id="c7d12-193">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="c7d12-194">Para dar suporte a esses cenários, lembre-se de que os tokens de sessão e de campo são unidos por um token de segurança, que é um identificador opaco 128 bits gerada aleatoriamente.</span><span class="sxs-lookup"><span data-stu-id="c7d12-194">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="c7d12-195">Esse token de segurança é usado para controlar a sessão de um usuário individual conforme ela navega site, portanto ele efetivamente tem a finalidade de um identificador anônimo.</span><span class="sxs-lookup"><span data-stu-id="c7d12-195">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="c7d12-196">Uma cadeia de caracteres vazia é usada no lugar do nome de usuário para as rotinas de geração e validação descritas acima.</span><span class="sxs-lookup"><span data-stu-id="c7d12-196">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="c7d12-197">O WIF / ACS / baseado em declarações de autenticação</span><span class="sxs-lookup"><span data-stu-id="c7d12-197">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="c7d12-198">Normalmente, o *IIdentity* classes internas para o .NET Framework tem a propriedade que *IIdentity.Name* são suficientes para identificar exclusivamente um usuário específico dentro de um aplicativo específico.</span><span class="sxs-lookup"><span data-stu-id="c7d12-198">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="c7d12-199">Por exemplo, *FormsIdentity.Name* retorna o nome de usuário armazenado no banco de dados em associação (que é exclusivo para todos os aplicativos, dependendo do banco de dados), *WindowsIdentity.Name* retorna o domínio qualificado a identidade do usuário e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="c7d12-199">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="c7d12-200">Esses sistemas fornecem não somente a autenticação; Eles também *identificar* os usuários para um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c7d12-200">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="c7d12-201">Autenticação baseada em declarações, por outro lado, não necessariamente exigem a identificação de um usuário específico.</span><span class="sxs-lookup"><span data-stu-id="c7d12-201">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="c7d12-202">Em vez disso, o *ClaimsPrincipal* e *ClaimsIdentity* tipos são associados um conjunto de *declaração* instâncias, onde as declarações individuais podem ser "é de 18 anos de idade" ou " é um administrador"para qualquer outra coisa.</span><span class="sxs-lookup"><span data-stu-id="c7d12-202">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="c7d12-203">Como o usuário não necessariamente foi identificado, o tempo de execução não pode usar o *ClaimsIdentity.Name* a propriedade como um identificador exclusivo para esse usuário específico.</span><span class="sxs-lookup"><span data-stu-id="c7d12-203">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="c7d12-204">A equipe viu exemplos do mundo real onde *ClaimsIdentity.Name* retorna *nulo*, retorna um nome amigável (exibição) ou, caso contrário, retorna uma cadeia de caracteres que não é apropriada para uso como um identificador exclusivo para o usuário.</span><span class="sxs-lookup"><span data-stu-id="c7d12-204">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="c7d12-205">Muitas implantações que usam a autenticação baseada em declarações estão usando [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) em particular.</span><span class="sxs-lookup"><span data-stu-id="c7d12-205">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="c7d12-206">ACS permite que o desenvolvedor configure individuais *provedores de identidade* (como o AD FS, o provedor do Microsoft Account, provedores de OpenID como Yahoo!, etc.), e os provedores de identidade retornam *nome identificadores*.</span><span class="sxs-lookup"><span data-stu-id="c7d12-206">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="c7d12-207">Esses identificadores de nome podem conter informações pessoalmente identificáveis (PII) como um endereço de email, ou eles podem ser anônimas como um privada PPID (identificador pessoal).</span><span class="sxs-lookup"><span data-stu-id="c7d12-207">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="c7d12-208">Independentemente, a tupla (provedor de identidade, identificador de nome) suficientemente serve como um token de controle apropriado para um determinado usuário enquanto ela estiver navegando no site, então o tempo de execução de pilha do ASP.NET Web pode usar a tupla no lugar do nome de usuário durante a geração e Validando tokens de campo de anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="c7d12-208">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="c7d12-209">Os URIs específico para o provedor de identidade e o identificador do nome são:</span><span class="sxs-lookup"><span data-stu-id="c7d12-209">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="c7d12-210">(consulte este [página do documento de ACS](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) para obter mais informações.)</span><span class="sxs-lookup"><span data-stu-id="c7d12-210">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="c7d12-211">Ao gerar ou validação de um token, o tempo de execução do ASP.NET Web pilha em tempo de execução tentará associação para os tipos:</span><span class="sxs-lookup"><span data-stu-id="c7d12-211">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="c7d12-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (Para o SDK do WIF.)</span><span class="sxs-lookup"><span data-stu-id="c7d12-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="c7d12-213">`System.Security.Claims.ClaimsIdentity` (Para .NET 4.5).</span><span class="sxs-lookup"><span data-stu-id="c7d12-213">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="c7d12-214">Se esses tipos existem e se o usuário atual *IIIIdentity* subclasses ou implementa um desses tipos, o recurso de anti-XSRF usará (provedor de identidade, identificador de nome) tupla no lugar ao gerar o nome de usuário e valida os tokens.</span><span class="sxs-lookup"><span data-stu-id="c7d12-214">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="c7d12-215">Se nenhuma tupla tal estiver presente, a solicitação falhará com um erro que descreve ao desenvolvedor de como configurar o sistema de anti-XSRF para entender o mecanismo de autenticação específica baseada em declarações em uso.</span><span class="sxs-lookup"><span data-stu-id="c7d12-215">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="c7d12-216">Consulte o **[configuração e extensibilidade](#_Configuration_and_extensibility)** para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="c7d12-216">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="c7d12-217">OAuth / OpenID autenticação</span><span class="sxs-lookup"><span data-stu-id="c7d12-217">OAuth / OpenID authentication</span></span>

<span data-ttu-id="c7d12-218">Por fim, o recurso de anti-XSRF possui suporte especial para aplicativos que usam autenticação OAuth ou OpenID.</span><span class="sxs-lookup"><span data-stu-id="c7d12-218">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="c7d12-219">Esse suporte é baseado em heurística: se o atual *IIdentity.Name* começa com http:// ou https://, em seguida, as comparações de nome de usuário serão feitas usando uma comparação Ordinal em vez do comparador de OrdinalIgnoreCase padrão.</span><span class="sxs-lookup"><span data-stu-id="c7d12-219">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="c7d12-220">Configuração e extensibilidade</span><span class="sxs-lookup"><span data-stu-id="c7d12-220">Configuration and extensibility</span></span>

<span data-ttu-id="c7d12-221">Ocasionalmente, os desenvolvedores podem desejar maior controle sobre a geração de anti-XSRF e comportamentos de validação.</span><span class="sxs-lookup"><span data-stu-id="c7d12-221">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="c7d12-222">Por exemplo, talvez o comportamento padrão dos auxiliares MVC e páginas da Web adicionando automaticamente os cookies HTTP para a resposta é indesejável, e o desenvolvedor pode desejar manter os tokens em outro lugar.</span><span class="sxs-lookup"><span data-stu-id="c7d12-222">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="c7d12-223">Existem duas APIs para ajudá-lo com isso:</span><span class="sxs-lookup"><span data-stu-id="c7d12-223">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="c7d12-224">O *GetTokens* método utiliza como entrada um existente XSRF verificação sessão token de solicitação (que pode ser nulo) e gera como saída um novo token de sessão de verificação para solicitação XSRF e um token de campo.</span><span class="sxs-lookup"><span data-stu-id="c7d12-224">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="c7d12-225">Os tokens são cadeias de caracteres opacas simplesmente sem decoração; o *formToken* valor para a instância não será ajustado em um &lt;entrada&gt; marca.</span><span class="sxs-lookup"><span data-stu-id="c7d12-225">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="c7d12-226">O *newCookieToken* valor pode ser null; nesse caso, o *oldCookieToken* valor ainda é válido e não precisa ser definido nenhum novo cookie de resposta.</span><span class="sxs-lookup"><span data-stu-id="c7d12-226">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="c7d12-227">O chamador de *GetTokens* é responsável por manter os cookies de resposta necessários ou gerar qualquer marcação necessário; o *GetTokens* próprio método não alterará a resposta como um efeito colateral.</span><span class="sxs-lookup"><span data-stu-id="c7d12-227">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="c7d12-228">O *validar* método usa a sessão de entrada e o campo de tokens e executa a lógica de validação mencionados acima sobre eles.</span><span class="sxs-lookup"><span data-stu-id="c7d12-228">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="c7d12-229">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="c7d12-229">AntiForgeryConfig</span></span>

<span data-ttu-id="c7d12-230">O desenvolvedor pode configurar o sistema de anti-XSRF do aplicativo\_iniciar.</span><span class="sxs-lookup"><span data-stu-id="c7d12-230">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="c7d12-231">A configuração é através de programação.</span><span class="sxs-lookup"><span data-stu-id="c7d12-231">Configuration is programmatic.</span></span> <span data-ttu-id="c7d12-232">As propriedades de estático *AntiForgeryConfig* tipo são descritos abaixo.</span><span class="sxs-lookup"><span data-stu-id="c7d12-232">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="c7d12-233">A maioria dos usuários usando declarações deve definir a propriedade UniqueClaimTypeIdentifier.</span><span class="sxs-lookup"><span data-stu-id="c7d12-233">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="c7d12-234">**Property**</span><span class="sxs-lookup"><span data-stu-id="c7d12-234">**Property**</span></span> | <span data-ttu-id="c7d12-235">**Descrição**</span><span class="sxs-lookup"><span data-stu-id="c7d12-235">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="c7d12-236">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="c7d12-236">**AdditionalDataProvider**</span></span> | <span data-ttu-id="c7d12-237">Um [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) que fornece dados adicionais durante a geração de token e consome dados adicionais durante a validação de token.</span><span class="sxs-lookup"><span data-stu-id="c7d12-237">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="c7d12-238">O valor padrão é *nulo*.</span><span class="sxs-lookup"><span data-stu-id="c7d12-238">The default value is *null*.</span></span> <span data-ttu-id="c7d12-239">Para obter mais informações, consulte o [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) seção.</span><span class="sxs-lookup"><span data-stu-id="c7d12-239">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="c7d12-240">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="c7d12-240">**CookieName**</span></span> | <span data-ttu-id="c7d12-241">Uma cadeia de caracteres que fornece o nome do cookie HTTP que é usado para armazenar o token de sessão de anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="c7d12-241">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="c7d12-242">Se esse valor não for definido, um nome será gerado automaticamente com base no caminho virtual implantado do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c7d12-242">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="c7d12-243">O valor padrão é *nulo*.</span><span class="sxs-lookup"><span data-stu-id="c7d12-243">The default value is *null*.</span></span> |
| <span data-ttu-id="c7d12-244">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="c7d12-244">**RequireSsl**</span></span> | <span data-ttu-id="c7d12-245">Um valor booleano que determina se os tokens de anti-XSRF são necessários para serem enviados por um canal protegido por SSL.</span><span class="sxs-lookup"><span data-stu-id="c7d12-245">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="c7d12-246">Se esse valor for *true*, os cookies automaticamente gerado terá o sinalizador "secure" definida e as APIs de anti-XSRF lançará se chamado de dentro de uma solicitação que não é enviada por meio de SSL.</span><span class="sxs-lookup"><span data-stu-id="c7d12-246">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="c7d12-247">O valor padrão é *false*.</span><span class="sxs-lookup"><span data-stu-id="c7d12-247">The default value is *false*.</span></span> |
| <span data-ttu-id="c7d12-248">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="c7d12-248">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="c7d12-249">Um valor booleano que determina se o sistema de anti-XSRF deve desativar o suporte a identidades baseadas em declarações.</span><span class="sxs-lookup"><span data-stu-id="c7d12-249">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="c7d12-250">Se esse valor for *true*, o sistema assumirá que *IIdentity.Name* é adequado para uso como um identificador exclusivo por usuário e não tentará casos especiais *IClaimsIdentity*ou *ClClaimsIdentity* conforme descrito no [WIF / ACS / baseada em declarações autenticação](#_WIF_ACS) seção.</span><span class="sxs-lookup"><span data-stu-id="c7d12-250">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="c7d12-251">O valor padrão é `false`.</span><span class="sxs-lookup"><span data-stu-id="c7d12-251">The default value is `false`.</span></span> |
| <span data-ttu-id="c7d12-252">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="c7d12-252">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="c7d12-253">Uma cadeia de caracteres que indica qual declaração de tipo é adequada para uso como um identificador exclusivo por usuário.</span><span class="sxs-lookup"><span data-stu-id="c7d12-253">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="c7d12-254">Se esse valor é o conjunto e atual *IIdentity* é baseada em declarações, o sistema tentará extrair uma declaração do tipo especificada pelo *UniqueClaimTypeIdentifier*, e o valor correspondente será usado no lugar do nome de usuário ao gerar o token de campo.</span><span class="sxs-lookup"><span data-stu-id="c7d12-254">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="c7d12-255">Se o tipo de declaração não for encontrado, o sistema falhará na solicitação.</span><span class="sxs-lookup"><span data-stu-id="c7d12-255">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="c7d12-256">O valor padrão é *nulo*, que indica que o sistema deve usar (provedor de identidade, identificador de nome) tupla conforme descrita anteriormente no lugar do nome do usuário.</span><span class="sxs-lookup"><span data-stu-id="c7d12-256">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="c7d12-257">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="c7d12-257">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="c7d12-258">O *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* tipo permite aos desenvolvedores estender o comportamento do sistema anti-XSRF por dados adicionais do ciclo em cada token.</span><span class="sxs-lookup"><span data-stu-id="c7d12-258">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="c7d12-259">O *GetAdditionalData* método é chamado sempre que um token de campo é gerado e o valor de retorno é inserido no token gerado.</span><span class="sxs-lookup"><span data-stu-id="c7d12-259">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="c7d12-260">Um implementador pode retornar um carimbo de hora, um valor de uso único ou qualquer outro valor que ela deseja deste método.</span><span class="sxs-lookup"><span data-stu-id="c7d12-260">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="c7d12-261">Da mesma forma, o *ValidateAdditionalData* método é chamado sempre que um token de campo for validado, e a cadeia de caracteres "dados adicionais" foi incorporada o token é passada para o método.</span><span class="sxs-lookup"><span data-stu-id="c7d12-261">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="c7d12-262">A rotina de validação pode implementar um tempo limite (Verificando a hora atual em relação a hora em que foi armazenada quando o token foi criado), um verificação de rotina ou qualquer outro de nonce desejado lógica.</span><span class="sxs-lookup"><span data-stu-id="c7d12-262">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="c7d12-263">Decisões de design e considerações de segurança</span><span class="sxs-lookup"><span data-stu-id="c7d12-263">Design decisions and security considerations</span></span>

<span data-ttu-id="c7d12-264">O token de segurança que vincula os tokens de sessão e o campo tecnicamente só é necessário ao tentar proteger os usuários não autenticados / anônimos contra ataques XSRF.</span><span class="sxs-lookup"><span data-stu-id="c7d12-264">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="c7d12-265">Quando o usuário é autenticado, o token de autenticação em si (supostamente enviada na forma de um cookie) pode ser usado como um par de metade de um sincronizador token.</span><span class="sxs-lookup"><span data-stu-id="c7d12-265">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="c7d12-266">No entanto, há cenários válidos para proteger as páginas de logon de ocorrências por usuários não autenticados e a lógica de anti-XSRF foi simplificada por sempre gerar e validar o token de segurança, mesmo para os usuários autenticados.</span><span class="sxs-lookup"><span data-stu-id="c7d12-266">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="c7d12-267">Ela também fornece proteção adicional que um token de campo for comprometido por um invasor, como configuração ou adivinhar que o token de sessão seria outro obstáculo para superar o invasor.</span><span class="sxs-lookup"><span data-stu-id="c7d12-267">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="c7d12-268">Os desenvolvedores devem usar cuidado quando vários aplicativos são hospedados em um único domínio.</span><span class="sxs-lookup"><span data-stu-id="c7d12-268">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="c7d12-269">Por exemplo, embora *example1.cloudapp.net* e *example2.cloudapp.net* são hosts diferentes, há uma relação de confiança implícita entre todos os hosts sob o  *\*. cloudapp.net* domínio.</span><span class="sxs-lookup"><span data-stu-id="c7d12-269">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="c7d12-270">Essa relação de confiança implícita [permite que os hosts potencialmente não confiáveis afetam uns dos outros cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (as políticas de mesma origem que governam as solicitações do AJAX não necessariamente se aplicam a cookies HTTP).</span><span class="sxs-lookup"><span data-stu-id="c7d12-270">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="c7d12-271">O tempo de execução de pilha do ASP.NET Web fornece algumas redução em que o nome de usuário é incorporada ao token de campo, assim mesmo se um subdomínio mal-intencionado é capaz de substituir um token de sessão, será possível gerar um token de campo válido para o usuário.</span><span class="sxs-lookup"><span data-stu-id="c7d12-271">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="c7d12-272">No entanto, quando hospedados em um ambiente desse tipo as rotinas de anti-XSRF internas ainda não é possível proteger contra sequestro de sessão ou logon XSRF.</span><span class="sxs-lookup"><span data-stu-id="c7d12-272">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="c7d12-273">As rotinas de anti-XSRF atualmente não proteger contra [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="c7d12-273">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="c7d12-274">Aplicativos que deseja proteger-se contra clickjacking podem facilmente fazer isso enviando um X-Frame-Options: cabeçalho SAMEORIGIN com cada resposta.</span><span class="sxs-lookup"><span data-stu-id="c7d12-274">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="c7d12-275">Esse cabeçalho é compatível com todos os navegadores recentes.</span><span class="sxs-lookup"><span data-stu-id="c7d12-275">This header is supported by all recent browsers.</span></span> <span data-ttu-id="c7d12-276">Para obter mais informações, consulte o [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), o [blog do SDL](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), e [OWASP](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="c7d12-276">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="c7d12-277">O tempo de execução do ASP.NET Web pilha pode em alguns Verifique versão futura do MVC e auxiliares de anti-XSRF páginas da Web automaticamente defina esse cabeçalho para que os aplicativos são protegidos automaticamente contra esse ataque.</span><span class="sxs-lookup"><span data-stu-id="c7d12-277">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="c7d12-278">Os desenvolvedores da Web devem continuar a garantir que seu site não é vulnerável a ataques XSS.</span><span class="sxs-lookup"><span data-stu-id="c7d12-278">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="c7d12-279">Ataques XSS são muito eficientes e uma exploração bem-sucedida também interrompe as defesas de tempo de execução do ASP.NET Web pilha contra ataques XSRF.</span><span class="sxs-lookup"><span data-stu-id="c7d12-279">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="c7d12-280">Confirmação</span><span class="sxs-lookup"><span data-stu-id="c7d12-280">Acknowledgment</span></span>

<span data-ttu-id="c7d12-281">[@LeviBroderick](https://twitter.com/LeviBroderick), quem criou a boa parte do código de segurança do ASP.NET a maior parte dessas informações.</span><span class="sxs-lookup"><span data-stu-id="c7d12-281">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
