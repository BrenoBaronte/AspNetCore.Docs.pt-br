---
title: Migrar do ASP.NET Core 2,2 para 3,0
author: rick-anderson
description: Saiba como migrar um projeto ASP.NET Core 2,2 para ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 11/26/2019
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 364556aed741569adafedd9760ef74af005f0537
ms.sourcegitcommit: c0b72b344dadea835b0e7943c52463f13ab98dd1
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 12/06/2019
ms.locfileid: "74881191"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrar do ASP.NET Core 2,2 para 3,0

Por [Scott Addie](https://github.com/scottaddie) e [Rick Anderson](https://twitter.com/RickAndMSFT)

Este artigo explica como atualizar um projeto existente do ASP.NET Core 2,2 para ASP.NET Core 3,0.

## <a name="prerequisites"></a>Pré-requisitos

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio para Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Atualizar a versão do SDK do .NET Core em global.json

Se sua solução depende de um arquivo [global. JSON](/dotnet/core/tools/global-json) para direcionar uma versão específica do SDK do .NET Core, atualize sua propriedade `version` para a versão 3,0 instalada em seu computador:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Atualizar o arquivo de projeto

### <a name="update-the-target-framework"></a>Atualizar a estrutura de destino

ASP.NET Core 3,0 e posterior somente são executados no .NET Core. Defina o [moniker da estrutura de destino (TFM)](/dotnet/standard/frameworks) como `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Remover referências de pacote obsoletas

Um grande número de pacotes NuGet não é produzido para o ASP.NET Core 3,0. Essas referências de pacote devem ser removidas do arquivo de projeto. Considere o seguinte arquivo de projeto para um aplicativo Web ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

O arquivo de projeto atualizado para o ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

O arquivo de projeto ASP.NET Core 3,0 atualizado:

* No `<PropertyGroup>`:
  * Atualiza o TFM para `netcoreapp3.0`
  * Remove o elemento `<AspNetCoreHostingModel>`. Para obter mais informações, consulte [modelo de hospedagem em processo](#in-process-hosting-model) neste documento.

* No `<ItemGroup>`:
  * `Microsoft.AspNetCore.App` é removido. Para obter mais informações, consulte [referência de estrutura](#framework-reference) neste documento.
  * `Microsoft.AspNetCore.Razor.Design` é removido e na lista de pacotes a seguir não está mais sendo produzido.

Para ver a lista completa de pacotes que não são mais produzidos, selecione a seguinte lista de expansão:

<details>
    <summary>Clique para expandir a lista de pacotes que não estão mais sendo produzidos</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore.SignalR. Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Revisar alterações recentes

[Revisar alterações recentes](#break)

### <a name="framework-reference"></a>Referência de estrutura

Os recursos de ASP.NET Core que estavam disponíveis por meio de um dos pacotes listados acima estão disponíveis como parte da estrutura compartilhada `Microsoft.AspNetCore.App`. A *estrutura compartilhada* é o conjunto de assemblies (arquivos *. dll* ) que estão instalados no computador e inclui um componente de tempo de execução e um pacote de direcionamento. Saiba mais em [A estrutura compartilhada](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Projetos que visam o SDK do `Microsoft.NET.Sdk.Web` referenciam implicitamente a estrutura de `Microsoft.AspNetCore.App`.

  Nenhuma referência adicional é necessária para esses projetos:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Os projetos direcionados `Microsoft.NET.Sdk` ou `Microsoft.NET.Sdk.Razor` SDK, devem adicionar um `FrameworkReference` explícito ao `Microsoft.AspNetCore.App`:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Compilações dependentes da estrutura usando o Docker

Compilações dependentes de estrutura de aplicativos de console que usam um pacote que depende da [estrutura compartilhada](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) ASP.NET Core pode fornecer o seguinte erro de tempo de execução:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` é a estrutura compartilhada que contém o tempo de execução ASP.NET Core e só está presente na imagem [dotnet/núcleo/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker. O SDK 3,0 reduz o tamanho de compilações dependentes da estrutura usando ASP.NET Core não incluindo cópias duplicadas de bibliotecas que estão disponíveis na estrutura compartilhada. Essa é uma economia potencial de até 18 MB, mas requer que o tempo de execução do ASP.NET Core esteja presente/instalado para executar o aplicativo.

Para determinar se o aplicativo tem uma dependência (direta ou indireta) na estrutura compartilhada ASP.NET Core, examine o arquivo *runtimeconfig. JSON* gerado durante uma compilação/publicação de seu aplicativo. O arquivo JSON a seguir mostra uma dependência na estrutura compartilhada ASP.NET Core:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Se seu aplicativo estiver usando o Docker, use uma imagem base que inclua ASP.NET Core 3,0. Por exemplo: `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Adicionar referências de pacote para assemblies removidos

ASP.NET Core 3,0 remove alguns assemblies que anteriormente faziam parte da referência do pacote `Microsoft.AspNetCore.App`. Para visualizar quais assemblies foram removidos, compare as duas pastas de estrutura compartilhadas. Por exemplo, uma comparação das versões 2.2.7 e 3.0.0:

![comparação de assemblies de estrutura compartilhada](22-to-30/_static/assembly-diff.png)

Para continuar usando os recursos fornecidos pelos assemblies removidos, faça referência às versões 3,0 dos pacotes correspondentes:

* Um aplicativo Web gerado por modelo com **contas de usuário individuais** requer a adição dos seguintes pacotes:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Para obter mais informações sobre como referenciar o pacote específico do provedor de banco de dados, consulte [provedores de banco de dados](/ef/core/providers/index).

* Interface do usuário de identidade

  O suporte para [interface do usuário de identidade](xref:security/authentication/identity) pode ser adicionado referenciando o pacote [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Serviços de SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* O suporte de &ndash; de autenticação para fluxos de autenticação de terceiros está disponível como pacotes NuGet:

  * OAuth do Facebook ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Autenticação de conta da Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Autenticação do OpenID Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Token de portador OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Autenticação WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Suporte à formatação e à negociação de conteúdo para `System.Net.HttpClient` &ndash; o pacote NuGet [Microsoft. AspNet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) fornece extensibilidade útil para `System.Net.HttpClient` com APIs como `ReadAsAsync` e `PostJsonAsync`.

* A compilação de tempo de execução do Razor &ndash; suporte para a compilação em tempo de execução de exibições e páginas do Razor agora faz parte de [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* O MVC `Newtonsoft.Json` suporte a &ndash; suporte para usar o MVC com `Newtonsoft.Json` agora faz parte de [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Alterações de inicialização

A imagem a seguir mostra as linhas excluídas e alteradas em um aplicativo Web ASP.NET Core 2,2 Razor Pages:

![as linhas excluídas e alteradas em um ASP.NET Core aplicativo Web do Razor 2,2](22-to-30/_static/startup2.2.png)

Na imagem anterior, o código excluído é mostrado em vermelho. O código excluído não mostra o código de opções de cookie, que foi excluído antes de comparar os arquivos.

A imagem a seguir mostra as linhas adicionadas e alteradas em um aplicativo Web ASP.NET Core 3,0 Razor Pages:

![as linhas adicionadas e alteradas em um ASP.NET Core aplicativo Web do Razor 3,0](22-to-30/_static/startup3.0.png)

Na imagem anterior, o código adicionado é mostrado em verde. Para obter informações sobre as seguintes alterações:

* `services.AddMvc` `services.AddRazorPages`, consulte [registro do serviço MVC](#mvc-service-registration) neste documento.
* `CompatibilityVersion`, consulte <xref:mvc/compatibility-version>.
* `IHostingEnvironment` `IWebHostEnvironment`, consulte [este comunicado do GitHub](https://github.com/aspnet/AspNetCore/issues/7749).
* `app.UseAuthorization` foi adicionado aos modelos para mostrar que o middleware de autorização de ordem deve ser adicionado. Se o aplicativo não usar autorização, você poderá remover com segurança a chamada para `app.UseAuthorization`.
* `app.UseEndpoints`, consulte [Razor Pages](#razor-pages) ou [migrar inicialização. configurar](#migrate-startupconfigure) neste documento.

### <a name="analyzer-support"></a>Suporte do Analyzer

Projetos que visam `Microsoft.NET.Sdk.Web` analisadores implicitamente de referência foram fornecidos como parte do pacote [Microsoft. AspNetCore. Mvc. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Nenhuma referência adicional é necessária para habilitá-las.

Se seu aplicativo usar [analisadores de API](xref:web-api/advanced/analyzers) fornecidos anteriormente usando o pacote [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , edite o arquivo de projeto para fazer referência aos analisadores fornecidos como parte do SDK Web do .NET Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Biblioteca de Classes do Razor

Os projetos de biblioteca de classes Razor que fornecem componentes de interface do usuário para o MVC devem definir a propriedade `AddRazorSupportForMvc` no arquivo de projeto:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modelo de hospedagem em processo

Os projetos assumem como padrão o [modelo de hospedagem em processo](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) no ASP.NET Core 3,0 ou posterior. Opcionalmente, você pode remover a propriedade `<AspNetCoreHostingModel>` no arquivo de projeto se seu valor for `InProcess`.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuração

Migre a configuração do Kestrel para o construtor de hosts da Web fornecido pelo `ConfigureWebHostDefaults` (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Se o aplicativo criar o host manualmente com `HostBuilder`, chame `UseKestrel` no construtor de hosts da Web no `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Middleware de conexão substitui adaptadores de conexão

Os adaptadores de conexão (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) foram removidos do Kestrel. Substitua adaptadores de conexão por middleware de conexão. O middleware de conexão é semelhante ao middleware HTTP no pipeline de ASP.NET Core, mas para conexões de nível inferior. Log de conexão e HTTPS:

* Foram movidos dos adaptadores de conexão para o middleware de conexão.
* Esses métodos de extensão funcionam como nas versões anteriores do ASP.NET Core. 

Para obter mais informações, consulte [o exemplo TlsFilterConnectionHandler na seção listenoptions. Protocols do artigo Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstrações de transporte movidas e tornadas públicas

A camada de transporte Kestrel foi exposta como uma interface pública no `Connections.Abstractions`. Como parte dessas atualizações:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` e tipos associados foram removidos.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> foi movido de <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> para as opções de transporte.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` foi removido do <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Para obter mais informações, consulte os seguintes recursos do GitHub:

* [Abstrações de rede cliente/servidor (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementar nova abstração de ouvinte Fundação e plat novamente Kestrel no início (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Cabeçalhos do trailer de solicitação do Kestrel

Para aplicativos destinados a versões anteriores do ASP.NET Core:

* Kestrel adiciona cabeçalhos de trailers em partes do HTTP/1.1 à coleção de cabeçalhos de solicitação.
* Os trailers ficam disponíveis depois que o corpo da solicitação é lido até o final.

Isso causa algumas preocupações sobre ambigüidade entre cabeçalhos e trailers, portanto, os trailers foram movidos para uma nova coleção (`RequestTrailerExtensions`) em 3,0.

Os trailers de solicitação HTTP/2 são:

* Não disponível no ASP.NET Core 2,2.
* Disponível em 3,0 como `RequestTrailerExtensions`.

Novos métodos de extensão de solicitação estão presentes para acessar esses trailers. Assim como ocorre com HTTP/1.1, os trailers ficam disponíveis depois que o corpo da solicitação é lido até o final.

Para a versão 3,0, os seguintes métodos de `RequestTrailerExtensions` estão disponíveis:

* `GetDeclaredTrailers` &ndash; Obtém a solicitação `Trailer` cabeçalho que lista os marcadores a serem esperados após o corpo.
* `SupportsTrailers` &ndash; indica se a solicitação dá suporte ao recebimento de cabeçalhos de trailer.
* `CheckTrailersAvailable` &ndash; verifica se a solicitação dá suporte a trailers e se está disponível para ser lida. Essa verificação não pressupõe que haja trailers para leitura. Pode não haver nenhum trailer para ler mesmo se `true` for retornado por esse método.
* `GetTrailer` &ndash; Obtém o cabeçalho à direita solicitado da resposta. Verifique `SupportsTrailers` antes de chamar `GetTrailer`ou uma <xref:System.NotSupportedException> pode ocorrer se a solicitação não oferecer suporte a cabeçalhos à direita.

Para obter mais informações, consulte [colocar os trailers de solicitação em uma coleção separada (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO desabilitado

`AllowSynchronousIO` habilita ou desabilita as APIs de e/s síncronas, como `HttpRequest.Body.Read`, `HttpResponse.Body.Write`e `Stream.Flush`. Essas APIs são uma fonte de privação de thread que leva a falhas de aplicativo. Em 3,0, `AllowSynchronousIO` é desabilitada por padrão. Para obter mais informações, consulte [a seção e/s síncrona no artigo Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Se a e/s síncrona for necessária, ela poderá ser habilitada com a configuração da opção `AllowSynchronousIO` no servidor que está sendo usado (ao chamar `ConfigureKestrel`, por exemplo, se estiver usando Kestrel). Observe que os servidores (Kestrel, HttpSa, TestServer, etc.) têm sua própria opção de `AllowSynchronousIO` que não afetará outros servidores. A e/s síncrona pode ser habilitada para todos os servidores de acordo com a solicitação usando a opção `IHttpBodyControlFeature.AllowSynchronousIO`:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Se você tiver problemas com implementações de <xref:System.IO.TextWriter> ou outros fluxos que chamam APIs síncronas em [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), chame a nova API de <xref:System.IO.Stream.DisposeAsync*> em vez disso.

Para obter mais informações, consulte [[comunicado] AllowSynchronousIO desabilitado em todos os servidores (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. Kestrel. https removido

No ASP.NET Core 2,1, o conteúdo de *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* foi movido para *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Essa foi uma atualização sem interrupção usando atributos de `TypeForwardedTo`. Para 3,0, o assembly *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* vazio e o pacote NuGet foram removidos.

Bibliotecas que fazem referência a [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) devem atualizar ASP.NET Core dependências para 2,1 ou posterior.

Os aplicativos e bibliotecas direcionados ASP.NET Core 2,1 ou posterior devem remover todas as referências diretas para o pacote [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Suporte do Json.NET

Como parte do trabalho para [melhorar a estrutura compartilhada ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), o [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) foi removido da estrutura compartilhada ASP.NET Core.

O padrão para ASP.NET Core é agora [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), que é novo no .net Core 3,0. Considere o uso de `System.Text.Json` quando possível. Ele é de alto desempenho e não requer uma dependência de biblioteca adicional. No entanto, como `System.Text.Json` é novo, no momento, pode haver recursos ausentes que seu aplicativo precisa.

Seu aplicativo poderá exigir `Newtonsoft.Json` integração se usar um recurso específico de `Newtonsoft.Json`, como JsonPatch ou conversores, ou se ele [formatar](xref:web-api/advanced/formatting) `Newtonsoft.Json`tipos específicos.

Para usar o Json.NET em um projeto ASP.NET Core 3,0 SignalR, consulte [alternar para Newtonsoft. JSON](#switch-to-newtonsoftjson) neste documento.

Para usar o Json.NET em um projeto ASP.NET Core 3,0:

* Adicione uma referência de pacote a [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Atualize `Startup.ConfigureServices` para chamar `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` é compatível com os novos métodos de registro do serviço MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  As configurações de Json.NET podem ser definidas na chamada para `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registro do serviço MVC

ASP.NET Core 3,0 adiciona novas opções para registrar cenários MVC dentro de `Startup.ConfigureServices`.

Três novos métodos de extensão de nível superior relacionados a cenários MVC no `IServiceCollection` estão disponíveis. Os modelos usam esses novos métodos em vez de `AddMvc`. No entanto, `AddMvc` continua se comportando como tem em versões anteriores.

O exemplo a seguir adiciona suporte para controladores e recursos relacionados à API, mas não a exibições ou páginas. O modelo de API usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

O exemplo a seguir adiciona suporte para controladores, recursos relacionados à API e exibições, mas não páginas. O modelo de aplicativo Web (MVC) usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

O exemplo a seguir adiciona suporte para Razor Pages e suporte mínimo a controlador. O modelo de aplicativo Web usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Os novos métodos também podem ser combinados. O exemplo a seguir é equivalente a chamar `AddMvc` em ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Código de inicialização de roteamento

Se um aplicativo chamar `UseMvc` ou `UseSignalR`, migre o aplicativo para o [Roteamento de ponto de extremidade](xref:fundamentals/routing) , se possível. Para melhorar a compatibilidade de roteamento de ponto de extremidade com versões anteriores do MVC, revertemos algumas das alterações na geração de URL introduzidas no ASP.NET Core 2,2. Se você enfrentou problemas ao usar o roteamento de ponto de extremidade em 2,2, espere melhorias no ASP.NET Core 3,0 com as seguintes exceções:

* Se o aplicativo implementa `IRouter` ou herda de `Route`, use [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) como a substituição.

* Se o aplicativo acessa diretamente `RouteData.Routers` dentro do MVC para analisar URLs, você pode substituir isso pelo uso de `LinkParser.ParsePathByEndpointName`. 
 * Defina a rota com um nome de rota.
 * Use `LinkParser.ParsePathByEndpointName` e passe o nome da rota desejada.

O roteamento de ponto de extremidade dá suporte à mesma sintaxe de padrão de rota e aos recursos de criação de padrão de rota como `IRouter`. O roteamento de ponto de extremidade dá suporte a `IRouteConstraint`. O roteamento de ponto de extremidade dá suporte a `[Route]`, `[HttpGet]`e outros atributos de roteamento do MVC.

Para a maioria dos aplicativos, apenas `Startup` requer alterações.

### <a name="migrate-startupconfigure"></a>Migrar inicialização. configurar

Conselhos gerais:

* Adicionar `UseRouting`.
* Se o aplicativo chamar `UseStaticFiles`, coloque `UseStaticFiles` **antes** de `UseRouting`.
* Se o aplicativo usar recursos de autenticação/autorização, como `AuthorizePage` ou `[Authorize]`, coloque a chamada para `UseAuthentication` e `UseAuthorization`: **After**, `UseRouting` e `UseCors`, mas antes de `UseEndpoints`:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Substitua `UseMvc` ou `UseSignalR` com `UseEndpoints`.
* Se o aplicativo usar cenários [CORS](xref:security/cors) , como `[EnableCors]`, coloque a chamada para `UseCors` antes de qualquer outro middleware que use CORS (por exemplo, coloque `UseCors` antes de `UseAuthentication`, `UseAuthorization`e `UseEndpoints`).
* Substitua `IHostingEnvironment` por `IWebHostEnvironment` e adicione uma instrução `using` para o namespace <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>.
* Substituir `IApplicationLifetime` por <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> namespace).
* Substituir `EnvironmentName` por <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> namespace).

O código a seguir é um exemplo de `Startup.Configure` em um aplicativo típico do ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Depois de atualizar o código de `Startup.Configure` anterior:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Para a maioria dos aplicativos, chamadas para `UseAuthentication`, `UseAuthorization`e `UseCors` devem aparecer entre as chamadas para `UseRouting` e `UseEndpoints` entrarem em vigor.

### <a name="health-checks"></a>Verificações de integridade

As verificações de integridade usam o roteamento de ponto de extremidade com o host genérico. Em `Startup.Configure`, chame `MapHealthChecks` no construtor de ponto de extremidade com a URL do ponto de extremidade ou o caminho relativo:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Os pontos de extremidade de verificações de integridade podem:

* Especifique um ou mais hosts/portas permitidos.
* Exigir autorização.
* Exigir CORS.

Para obter mais informações, consulte <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Diretrizes de middleware de segurança

O suporte para autorização e CORS é unificado em relação à abordagem de [middleware](xref:fundamentals/middleware/index) . Isso permite o uso do mesmo middleware e funcionalidade entre esses cenários. Um middleware de autorização atualizado é fornecido nesta versão, e o middleware CORS é aprimorado para que ele possa entender os atributos usados pelos controladores MVC.

#### <a name="cors"></a>CORS

Anteriormente, o CORS poderia ser difícil de configurar. O middleware foi fornecido para uso em alguns casos de uso, mas os filtros MVC foram destinados para serem usados **sem** o middleware em outros casos de uso. Com o ASP.NET Core 3,0, recomendamos que todos os aplicativos que exigem CORS usem o middleware CORS em tandem com o roteamento de ponto de extremidade. `UseCors` pode ser fornecida com uma política padrão e os atributos `[EnableCors]` e `[DisableCors]` podem ser usados para substituir a política padrão quando necessário.

No exemplo a seguir:

* O CORS está habilitado para todos os pontos de extremidade com a política nomeada `default`.
* A classe `MyController` desabilita o CORS com o atributo `[DisableCors]`.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorização

Em versões anteriores do ASP.NET Core, o suporte à autorização foi fornecido por meio do atributo `[Authorize]`. O middleware de autorização não estava disponível. No ASP.NET Core 3,0, o middleware de autorização é necessário. É recomendável colocar o ASP.NET Core de middleware de autorização (`UseAuthorization`) imediatamente após `UseAuthentication`. O middleware de autorização também pode ser configurado com uma política padrão, que pode ser substituída.

No ASP.NET Core 3,0 ou posterior, `UseAuthorization` é chamado em `Startup.Configure`e o `HomeController` a seguir requer um usuário conectado:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Se o aplicativo usar um `AuthorizeFilter` como um filtro global no MVC, é recomendável refatorar o código para fornecer uma política na chamada para `AddAuthorization`.

A `DefaultPolicy` é inicialmente configurada para exigir autenticação, portanto, nenhuma configuração adicional é necessária. No exemplo a seguir, os pontos de extremidade MVC são marcados como `RequireAuthorization` para que todas as solicitações devam ser autorizadas com base na `DefaultPolicy`. No entanto, o `HomeController` permite o acesso sem o usuário entrar no aplicativo devido a `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

As políticas também podem ser personalizadas. Com base no exemplo anterior, a `DefaultPolicy` está configurada para exigir autenticação e um escopo específico:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Como alternativa, todos os pontos de extremidade podem ser configurados para exigir autorização sem `[Authorize]` ou `RequireAuthorization` Configurando um `FallbackPolicy`. A `FallbackPolicy` é diferente da `DefaultPolicy`. O `DefaultPolicy` é disparado por `[Authorize]` ou `RequireAuthorization`, enquanto o `FallbackPolicy` é disparado quando nenhuma outra política é definida. o `FallbackPolicy` é inicialmente configurado para permitir solicitações sem autorização.

O exemplo a seguir é o mesmo que o exemplo anterior de `DefaultPolicy`, mas usa a `FallbackPolicy` para sempre exigir autenticação em todos os pontos de extremidade, exceto quando `[AllowAnonymous]` é especificado:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

A autorização por middleware funciona sem a estrutura com qualquer conhecimento específico de autorização. Por exemplo, as [verificações de integridade](xref:host-and-deploy/health-checks) não têm conhecimento específico de autorização, mas as verificações de integridade podem ter uma política de autorização configurável aplicada pelo middleware.

Além disso, cada ponto de extremidade pode personalizar seus requisitos de autorização. No exemplo a seguir, `UseAuthorization` processa a autorização com o `DefaultPolicy`, mas o ponto de extremidade de verificação de integridade `/healthz` requer um usuário `admin`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

A proteção é implementada para alguns cenários. O middleware de pontos de extremidade gera uma exceção se uma política de autorização ou CORS é ignorada devido ao middleware ausente. O suporte do Analyzer para fornecer comentários adicionais sobre a configuração incorreta está em andamento.

#### <a name="custom-authorization-handlers"></a>Manipuladores de autorização personalizados

Se o aplicativo usar [manipuladores de autorização](xref:security/authorization/policies#authorization-handlers)personalizados, o roteamento de ponto de extremidade passará um tipo de recurso diferente para manipuladores do que o MVC. Os manipuladores que esperam que o recurso de contexto do manipulador de autorização sejam do tipo <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (o tipo de recurso [fornecido pelos filtros MVC](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)) precisarão ser atualizados para manipular recursos do tipo <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (o tipo de recurso fornecido aos manipuladores de autorização por roteamento de ponto de extremidade).

O MVC ainda usa `AuthorizationFilterContext` recursos, portanto, se o aplicativo usar filtros de autorização do MVC junto com a autorização de roteamento de ponto de extremidade, poderá ser necessário lidar com os dois tipos de recursos.

### SignalR

Agora, o mapeamento dos hubs de SignalR ocorre dentro de `UseEndpoints`.

Mapeie cada Hub com `MapHub`. Como nas versões anteriores, cada Hub é explicitamente listado.

No exemplo a seguir, o suporte para o Hub de SignalR de `ChatHub` é adicionado:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Há uma nova opção para controlar os limites de tamanho de mensagens de clientes. Por exemplo, em `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

No ASP.NET Core 2,2, você pode definir o `TransportMaxBufferSize` e isso efetivamente controlaria o tamanho máximo da mensagem. No ASP.NET Core 3,0, essa opção agora controla apenas o tamanho máximo antes de a pressão de back.

### <a name="mvc-controllers"></a>Controladores MVC

O mapeamento de controladores agora ocorre dentro de `UseEndpoints`.

Adicione `MapControllers` se o aplicativo usar o roteamento de atributos. Como o roteamento inclui suporte para muitas estruturas no ASP.NET Core 3,0 ou posterior, adicionar controladores roteados por atributo é aceitar.

Substitua o seguinte:

* `MapRoute` com `MapControllerRoute`
* `MapAreaRoute` com `MapAreaControllerRoute`

Como o roteamento agora inclui suporte para mais do que apenas MVC, a terminologia foi alterada para tornar esses métodos claramente desconsiderando o que eles fazem. Rotas convencionais, como `MapControllerRoute`/`MapAreaControllerRoute`/`MapDefaultControllerRoute` são aplicadas na ordem em que são adicionadas. Coloque rotas mais específicas (como rotas para uma área) primeiro.

No exemplo a seguir:

* `MapControllers` adiciona suporte para controladores roteados por atributo.
* `MapAreaControllerRoute` adiciona uma rota convencional para controladores em uma área.
* `MapControllerRoute` adiciona uma rota convencional para controladores.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Remoção de sufixo assíncrono de nomes de ação do controlador

No ASP.NET Core 3,0, ASP.NET Core MVC remove o sufixo `Async` dos nomes de ação do controlador. O roteamento e a geração de link são afetados por esse novo padrão. Por exemplo:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Antes do ASP.NET Core 3,0:

* A ação anterior pode ser acessada na rota *Products/ListAsync* .
* Geração de link necessária ao especificar o sufixo de `Async`. Por exemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

No ASP.NET Core 3,0:

* A ação anterior pode ser acessada na rota *produtos/lista* .
* A geração de link não requer a especificação do sufixo de `Async`. Por exemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Essa alteração não afeta os nomes especificados usando o atributo [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . O comportamento padrão pode ser desabilitado com o seguinte código no `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Alterações na geração de link

Conforme explicado na documentação sobre [as diferenças de versões anteriores do roteamento](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), há algumas diferenças na geração de link (usando `Url.Link` e APIs semelhantes, por exemplo). Elas incluem:

* Por padrão, ao usar o roteamento de ponto de extremidade, a capitalização de parâmetros de rota em URIs gerados não é necessariamente preservada. Esse comportamento pode ser controlado com a interface `IOutboundParameterTransformer`.
* A geração de um URI para uma rota inválida (um controlador/uma ação ou uma página que não exista) produzirá uma cadeia de caracteres vazia em roteamento de ponto de extremidade em vez de produzir um URI inválido.
* Valores de ambiente (parâmetros de rota do contexto atual) não são usados automaticamente na geração de link com roteamento de ponto de extremidade. Anteriormente, ao gerar um link para outra ação (ou página), os valores de rota não especificados seriam inferidos dos valores de ambiente de rotas *atuais* . Ao usar o roteamento de ponto de extremidade, todos os parâmetros de rota devem ser especificados explicitamente durante a geração de link.

### <a name="razor-pages"></a>Páginas do Razor

O mapeamento Razor Pages agora ocorre dentro `UseEndpoints`.

Adicione `MapRazorPages` se o aplicativo usar Razor Pages. Como o roteamento de ponto de extremidade inclui suporte para muitas estruturas, adicionar Razor Pages agora é opcional.

No método `Startup.Configure` a seguir, `MapRazorPages` adiciona suporte para Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Usar MVC sem roteamento de ponto de extremidade

Usar o MVC via `UseMvc` ou `UseMvcWithDefaultRoute` no ASP.NET Core 3,0 requer uma aceitação explícita dentro de `Startup.ConfigureServices`. Isso é necessário porque o MVC deve saber se ele pode contar com a autorização e middleware CORS durante a inicialização. É fornecido um analisador que avisa se o aplicativo tenta usar uma configuração sem suporte.

Se o aplicativo exigir suporte `IRouter` herdado, desabilite `EnableEndpointRouting` usando qualquer uma das seguintes abordagens no `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Verificações de integridade

As verificações de integridade podem ser usadas como um *roteador-Ware* com roteamento de ponto de extremidade.

Adicione `MapHealthChecks` para usar verificações de integridade com roteamento de ponto de extremidade. O método `MapHealthChecks` aceita argumentos semelhantes a `UseHealthChecks`. A vantagem de usar `MapHealthChecks` sobre `UseHealthChecks` é a capacidade de aplicar autorização e ter um controle mais refinado sobre a política de correspondência.

No exemplo a seguir, `MapHealthChecks` é chamado para um ponto de extremidade de verificação de integridade na `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder substitui WebHostBuilder

Os modelos ASP.NET Core 3,0 usam [host genérico](xref:fundamentals/host/generic-host). Versões anteriores usavam [host da Web](xref:fundamentals/host/web-host). O código a seguir mostra o modelo ASP.NET Core 3,0 gerado `Program` classe:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

O código a seguir mostra a classe `Program` gerada pelo modelo ASP.NET Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> permanece em 3,0 e é o tipo de `webBuilder` visto no exemplo de código anterior. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> será preterida em uma versão futura e substituída por `HostBuilder`.

A alteração mais significativa de `WebHostBuilder` para `HostBuilder` está na [injeção de dependência (di)](xref:fundamentals/dependency-injection). Ao usar `HostBuilder`, você só pode injetar o seguinte no construtor de `Startup`:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* `Microsoft.Extensions.Hosting.IHostEnvironment`
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

As restrições de `HostBuilder` DI:

* Habilite o contêiner de DI para ser criado apenas uma vez.
* Evita os problemas de tempo de vida do objeto resultante, como a resolução de várias instâncias de singletons.

Para obter mais informações, consulte [evitando a injeção do serviço de inicialização no ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addautoria movida para um assembly diferente

Os métodos ASP.NET Core 2,2 e inferior `AddAuthorization` em *Microsoft. AspNetCore. Authorization. dll*:

* Foram renomeados `AddAuthorizationCore`.
* Foram movidos para *Microsoft. AspNetCore. Authorization. Policy. dll*.

Aplicativos que estão usando *Microsoft. AspNetCore. Authorization. dll* e *Microsoft. AspNetCore. Authorization. Policy. dll* não são afetados.

Aplicativos que não estão usando *Microsoft. AspNetCore. Authorization. Policy. dll* devem executar um dos seguintes procedimentos:

* Adicione uma referência a *Microsoft. AspNetCore. Authorization. Policy. dll*. Essa abordagem funciona para a maioria dos aplicativos e é tudo o que é necessário.
* Alternar para o uso de `AddAuthorizationCore`

Para obter mais informações, consulte [sobrecargas de alteração na `AddAuthorization(o =>`) em um assembly diferente #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Interface do usuário de identidade

Atualizações da interface do usuário de identidade para o ASP.NET Core 3,0:

* Adicione uma referência de pacote a [Microsoft. AspNetCore. Identity. UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Os aplicativos que não usam Razor Pages devem chamar `MapRazorPages`. Consulte [Razor Pages](#razor-pages) neste documento.
* A inicialização 4 é a estrutura de interface do usuário padrão. Defina uma propriedade de projeto `IdentityUIFrameworkVersion` para alterar o padrão. Para obter mais informações, consulte [este comunicado do GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

O cliente SignalR JavaScript foi alterado de `@aspnet/signalr` para `@microsoft/signalr`. Para reagir a essa alteração, altere as referências em arquivos *Package. JSON* , instruções `require` e instruções ECMAScript `import`.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON é o protocolo padrão

`System.Text.Json` agora é o protocolo de Hub padrão usado pelo cliente e pelo servidor.

Em `Startup.ConfigureServices`, chame `AddJsonProtocol` para definir opções de serializador.

**Servidor**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Cliente:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Alternar para Newtonsoft. JSON

Se você estiver usando recursos de `Newtonsoft.Json` que não têm suporte no `System.Text.Json`, você pode voltar para `Newtonsoft.Json`:

1. Instale o [Microsoft. AspNetCore.SignalR. Pacote NuGet Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. No cliente, encadear uma chamada de método `AddNewtonsoftJsonProtocol` para a instância `HubConnectionBuilder`:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. No servidor, ligue uma chamada de método `AddNewtonsoftJsonProtocol` para a chamada do método `AddSignalR` no `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Aceitar a compilação em tempo de execução

Antes do ASP.NET Core 3,0, a compilação do tempo de execução dos modos de exibição era um recurso implícito da estrutura. A compilação em tempo de execução complementa a compilação de exibições do tempo de compilação. Ele permite que a estrutura compile exibições e páginas do Razor (arquivos *. cshtml* ) quando os arquivos são modificados, sem a necessidade de recriar o aplicativo inteiro. Esse recurso dá suporte ao cenário de fazer uma edição rápida no IDE e atualizar o navegador para exibir as alterações.

No ASP.NET Core 3,0, a compilação em tempo de execução é um cenário de aceitação. Compilação em tempo de compilação é o único mecanismo para a compilação de exibição que é habilitada por padrão. O tempo de execução depende do Visual Studio ou [dotnet-Watch](xref:tutorials/dotnet-watch) no Visual Studio Code para recompilar o projeto quando ele detecta alterações em arquivos *. cshtml* . No Visual Studio, as alterações em arquivos *. cs*, *. cshtml*ou *. Razor* no projeto que estão sendo executados (<kbd>Ctrl + F5</kbd>), mas não depuradas (<kbd>F5</kbd>), disparam a recompilação do projeto.

Para habilitar a compilação em tempo de execução em seu projeto ASP.NET Core 3,0:

1. Instalar o pacote do NuGet [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).
1. Atualizar `Startup.ConfigureServices` para chamar `AddRazorRuntimeCompilation`:

    Para ASP.NET Core MVC, use o seguinte código:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Para ASP.NET Core Razor Pages, use o seguinte código:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
O exemplo em https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation mostra um exemplo de como habilitar a compilação de tempo de execução condicionalmente em ambientes de desenvolvimento.

Para obter mais informações sobre a compilação de arquivos Razor, consulte <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Migrar bibliotecas por meio de vários destinos

As bibliotecas geralmente precisam dar suporte a várias versões do ASP.NET Core. A maioria das bibliotecas que foram compiladas em relação às versões anteriores do ASP.NET Core deve continuar trabalhando sem problemas. As seguintes condições exigem que o aplicativo seja compilado em Cruz:

* A biblioteca depende de um recurso que tem uma [alteração significativa](#breaking-api-changes)binária.
* A biblioteca deseja aproveitar os novos recursos do ASP.NET Core 3,0. 

Por exemplo:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Use `#ifdefs` para habilitar as APIs específicas do ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

### <a name="publish"></a>Publicar

Exclua as pastas *bin* e *obj* no diretório do projeto.

## <a name="testserver"></a>TestServer

Para aplicativos que usam <xref:Microsoft.AspNetCore.TestHost.TestServer> diretamente com o [host genérico](xref:fundamentals/host/web-host), crie o `TestServer` em um <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> no <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Interrompendo alterações de API

Revise as alterações significativas:

* [Lista completa de alterações significativas na versão ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Quebrando alterações de API em antifalsificação, CORS, diagnóstico, MVC e roteamento](https://github.com/aspnet/Announcements/issues/387). Essa lista inclui alterações significativas para as opções de compatibilidade.
* Para obter um resumo das alterações mais recentes de 2,2 a 3,0 no .NET Core, ASP.NET Core e Entity Framework Core, consulte [alterações significativas para a migração da versão 2,2 para a 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 no serviço Azure App

Para o progresso da distribuição do .NET Core para Azure App serviço, consulte o site oficial do [.NET Core no serviço de aplicativo](https://aspnetcoreon.azurewebsites.net/) . Até que o .NET Core 3,0 esteja disponível no serviço Azure App, siga as instruções em [implantar ASP.NET Core versão de visualização para Azure app serviço](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
