---
title: Migrar do ASP.NET Core 2,2 para a versão prévia 3,0
author: rick-anderson
description: Saiba como migrar um projeto ASP.NET Core 2,2 para ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/16/2019
uid: migration/22-to-30
ms.openlocfilehash: 1318d97fedb3f77ba0a1a153383207914448bb96
ms.sourcegitcommit: fa61d882be9d0c48bd681f2efcb97e05522051d0
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/23/2019
ms.locfileid: "71205730"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrar do ASP.NET Core 2,2 para 3,0

Por [Scott Addie](https://github.com/scottaddie) e [Rick Anderson](https://twitter.com/RickAndMSFT)

Este artigo explica como atualizar um projeto existente do ASP.NET Core 2,2 para ASP.NET Core 3,0.

## <a name="prerequisites"></a>Pré-requisitos

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio para Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Atualizar o arquivo de projeto

### <a name="update-the-target-framework"></a>Atualizar a estrutura de destino

O ASP.NET Core 3.0 e posterior somente executará no .NET Core. Defina o [moniker do Framework de destino (TFM)](/dotnet/standard/frameworks) como `netcoreapp3.0`:

```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>Remover referências de pacote obsoletas

ASP.NET Core não produz mais um grande número de recursos de pacotes NuGet. Essas referências de pacote devem ser removidas do arquivo de projeto. Para ver a lista completa de pacotes que não são mais produzidos, veja abaixo:

<details>
    <summary>Clique aqui para expandir a lista de pacotes que não estão mais sendo produzidos</summary>

    * Microsoft.AspNetCore
    * Microsoft.AspNetCore.All
    * Microsoft.AspNetCore.App
    * Microsoft. AspNetCore. antifalsificação
    * Microsoft. AspNetCore. Authentication
    * Microsoft. AspNetCore. Authentication. abstrações
    * Microsoft. AspNetCore. Authentication. cookies
    * Microsoft. AspNetCore. Authentication. Core
    * Microsoft. AspNetCore. Authentication. JwtBearer
    * Microsoft. AspNetCore. Authentication. OAuth
    * Microsoft. AspNetCore. Authentication. OpenIdConnect
    * Microsoft. AspNetCore. Authorization
    * Microsoft. AspNetCore. Authorization. Policy
    * Microsoft. AspNetCore. CookiePolicy
    * Microsoft. AspNetCore. CORS
    * Microsoft. AspNetCore. Cryptography. Internal
    * Microsoft. AspNetCore. Cryptography. keyderivation
    * Microsoft.AspNetCore.DataProtection
    * Microsoft. AspNetCore. dataprotection. abstrações
    * Microsoft. AspNetCore. dataprotection. Extensions
    * Microsoft. AspNetCore. Diagnostics
    * Microsoft. AspNetCore. Diagnostics. HealthChecks
    * Microsoft.AspNetCore.HostFiltering
    * Microsoft.AspNetCore.Hosting
    * Microsoft. AspNetCore. Hosting. abstrações
    * Microsoft. AspNetCore. Hosting. Server. abstrações
    * Microsoft. AspNetCore. http
    * Microsoft. AspNetCore. http. abstrações
    * Microsoft. AspNetCore. http. Connections
    * Microsoft. AspNetCore. http. Extensions
    * Microsoft. AspNetCore. http. Features
    * Microsoft. AspNetCore. HttpOverrides
    * Microsoft. AspNetCore. HttpsPolicy
    * Microsoft. AspNetCore. Identity
    * Microsoft. AspNetCore. Localization
    * Microsoft. AspNetCore. Localization. Routing
    * Microsoft. AspNetCore. MiddlewareAnalysis
    * Microsoft.AspNetCore.Mvc
    * Microsoft. AspNetCore. Mvc. abstrações
    * Microsoft. AspNetCore. Mvc. Analyzers
    * Microsoft. AspNetCore. Mvc. ApiExplorer
    * Microsoft. AspNetCore. Mvc. API. Analyzers
    * Microsoft. AspNetCore. Mvc. Core
    * Microsoft. AspNetCore. Mvc. CORS
    * Microsoft. AspNetCore. Mvc. Annotations
    * Microsoft. AspNetCore. Mvc. Formatters. JSON
    * Microsoft. AspNetCore. Mvc. Formatters. xml
    * Microsoft. AspNetCore. Mvc. Localization
    * Microsoft.AspNetCore.Mvc.Razor
    * Microsoft. AspNetCore. Mvc. Razor. Extensions
    * Microsoft. AspNetCore. Mvc. Razor. ViewCompilation
    * Microsoft. AspNetCore. Mvc. RazorPages
    * Microsoft. AspNetCore. Mvc. TagHelpers
    * Microsoft. AspNetCore. Mvc. ViewFeatures
    * Microsoft. AspNetCore. Razor
    * Microsoft. AspNetCore. Razor. Runtime
    * Microsoft. AspNetCore. Razor. Design
    * Microsoft. AspNetCore. ResponseCaching
    * Microsoft. AspNetCore. ResponseCaching. abstrações
    * Microsoft. AspNetCore. ResponseCompression
    * Microsoft. AspNetCore. Rewrite
    * Microsoft.AspNetCore.Routing
    * Microsoft. AspNetCore. Routing. abstrações
    * Microsoft. AspNetCore. Server. HttpSu
    * Microsoft. AspNetCore. Server. IIS
    * Microsoft. AspNetCore. Server. IISIntegration
    * Microsoft. AspNetCore. Server. Kestrel
    * Microsoft. AspNetCore. Server. Kestrel. Core
    * Microsoft. AspNetCore. Server. Kestrel. https
    * Microsoft. AspNetCore. Server. Kestrel. Transport. abstrações
    * Microsoft. AspNetCore. Server. Kestrel. Transport. Sockets
    * Microsoft. AspNetCore. Session
    * Microsoft. AspNetCore. Signalr
    * Microsoft. AspNetCore. Signalr. Core
    * Microsoft.AspNetCore.StaticFiles
    * Microsoft. AspNetCore. WebSockets
    * Microsoft. AspNetCore. webutilities
    * Microsoft.Net. http. Headers</details>

### <a name="framework-reference"></a>Referência de estrutura

Recursos de ASP.NET Core que estavam disponíveis por meio de um dos pacotes listados acima estão disponíveis como parte da `Microsoft.AspNetCore.App` estrutura compartilhada.  A *estrutura compartilhada* é o conjunto de assemblies (arquivos *. dll* ) que estão instalados no computador e inclui um componente de tempo de execução e um pacote de direcionamento. Saiba mais em [A estrutura compartilhada](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).


* Projetos direcionados ao `Microsoft.NET.Sdk.Web` SDK referenciam implicitamente `Microsoft.AspNetCore.App` a estrutura.

Nenhuma referência adicional é necessária para esses projetos:

```xml
<Project SDK="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Os projetos `Microsoft.NET.Sdk` direcionados `Microsoft.NET.Sdk.Razor` ou SDK devem adicionar um explícito `FrameworkReference` a `Microsoft.AspNetCore.App`:

```xml
<Project SDK="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

### <a name="add-package-references-for-removed-assemblies"></a>Adicionar referências de pacote para assemblies removidos

ASP.NET Core 3,0 remove alguns assemblies que anteriormente faziam parte da `Microsoft.AspNetCore.App` referência do pacote. Para continuar usando os recursos fornecidos por esses assemblies, referencie as versões 3,0 dos pacotes correspondentes:

* Entity Framework Core-consulte https://docs.microsoft.com/ef/core/providers/index para obter mais informações sobre como referenciar o pacote específico do provedor de banco de dados.

* O suporte da interface do usuário de identidade para a [interface do usuário de identidade](xref:security/authentication/identity) pode ser adicionado referenciando o pacote [Microsoft. AspNetCore. Identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Serviços de SPA
    * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
    * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Autenticação-o suporte para fluxos de autenticação de terceiros está disponível como pacotes NuGet:

    * [OAuth do Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook)
    * [OAuth do Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google)
    * [Token de portador do OpenID Connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer)
    * [Autenticação da conta da Microsoft](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount)
    * [Autenticação do OpenID Connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect)
    * [OAuth do Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter)
    * [Autenticação WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation)

* Suporte para formatação e negociação de `System.Net.HttpClient` conteúdo para o, o pacote NuGet [Microsoft. AspNet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) fornece `System.Net.HttpClient` uma extensibilidade útil para `ReadAsAsync`o `PostJsonAsync` com APIs como, etc.

* Compilação de tempo de execução Razor-suporte para a compilação em tempo de execução de exibições e páginas do Razor agora faz parte de [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Suporte `Newtonsoft.Json` MVC-o suporte para usar o `Newtonsoft.Json` MVC com o agora faz parte de [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

### <a name="analyzer-support"></a>Suporte do Analyzer

* Projetos que têm `Microsoft.NET.Sdk.Web` como alvo implicitamente referenciam analisadores fornecidos anteriormente como parte do pacote [Microsoft. AspNetCore. Mvc. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Nenhuma referência adicional é necessária para habilitá-las.

* Se seu aplicativo usar [analisadores de API](xref:web-api/advanced/analyzers) fornecidos anteriormente usando o pacote [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , edite o arquivo de projeto para fazer referência aos analisadores fornecidos como parte do SDK Web do .NET Core:

```xml
<Project SDK="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
    <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
  </PropertyGroup>

  ...
</Project>
```

### <a name="razor-class-library"></a>Biblioteca de Classes do Razor

Os projetos de biblioteca de classes Razor que fornecem componentes de interface do `AddRazorSupportForMvc` usuário para o MVC devem definir a propriedade no arquivo de projeto:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modelo de hospedagem em processo

* Os projetos assumem como padrão o [modelo de hospedagem em processo](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) no ASP.NET Core 3,0 ou posterior. Opcionalmente, você pode remover `<AspNetCoreHostingModel>` a propriedade no arquivo de projeto se seu valor `InProcess`for.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuração

Migre a configuração do Kestrel para o construtor de hosts da Web fornecido pelo `ConfigureWebHostDefaults` (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Se o aplicativo criar o host manualmente com `HostBuilder`o, `UseKestrel` chame no construtor de hosts `ConfigureWebHostDefaults`da Web em:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Middleware de conexão substitui adaptadores de conexão

Os adaptadores<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>de conexão () foram removidos do Kestrel. Substitua adaptadores de conexão por middleware de conexão. O middleware de conexão é semelhante ao middleware HTTP no pipeline de ASP.NET Core, mas para conexões de nível inferior. Log de conexão e HTTPS:

* Foram movidos dos adaptadores de conexão para o middleware de conexão.
* Esses métodos de extensão funcionam como nas versões anteriores do ASP.NET Core. 

Para obter mais informações, consulte [o exemplo TlsFilterConnectionHandler na seção listenoptions. Protocols do artigo Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstrações de transporte movidas e tornadas públicas

A camada de transporte Kestrel foi exposta como uma interface pública no `Connections.Abstractions`. Como parte dessas atualizações:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`e os tipos associados foram removidos.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>foi movido de <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> para as opções de transporte.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>foi removido de <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Para obter mais informações, consulte os seguintes recursos do GitHub:

* [Abstrações de rede cliente/servidor (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementar nova abstração de ouvinte Fundação e plat novamente Kestrel no início (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Cabeçalhos do trailer de solicitação do Kestrel

Para aplicativos destinados a versões anteriores do ASP.NET Core:

* Kestrel adiciona cabeçalhos de trailers em partes do HTTP/1.1 à coleção de cabeçalhos de solicitação.
* Os trailers ficam disponíveis depois que o corpo da solicitação é lido até o final.

Isso causa algumas preocupações sobre ambigüidade entre cabeçalhos e trailers, portanto, os trailers foram movidos para uma nova coleção (`RequestTrailerExtensions`) em 3,0.

Os trailers de solicitação HTTP/2 são:

* Não disponível no ASP.NET Core 2,2.
* Disponível em 3,0 como `RequestTrailerExtensions`.

Novos métodos de extensão de solicitação estão presentes para acessar esses trailers. Assim como ocorre com HTTP/1.1, os trailers ficam disponíveis depois que o corpo da solicitação é lido até o final.

Para a versão 3,0, os seguintes `RequestTrailerExtensions` métodos estão disponíveis:

* `GetDeclaredTrailers`Obtém o cabeçalho `Trailer` da solicitação que lista os marcadores a serem esperados após o corpo. &ndash;
* `SupportsTrailers`&ndash; Indica se a solicitação dá suporte ao recebimento de cabeçalhos de trailer.
* `CheckTrailersAvailable`&ndash; Verifica se a solicitação dá suporte a trailers e se está disponível para leitura. Essa verificação não pressupõe que haja trailers para leitura. Pode não haver nenhum trailer para ler mesmo se `true` for retornado por esse método.
* `GetTrailer`&ndash; Obtém o cabeçalho à direita solicitado da resposta. Verifique `SupportsTrailers` antes de `GetTrailer`chamar, ou <xref:System.NotSupportedException> um pode ocorrer se a solicitação não oferecer suporte a cabeçalhos à direita.

Para obter mais informações, consulte [colocar os trailers de solicitação em uma coleção separada (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO desabilitado

`AllowSynchronousIO`Habilita ou desabilita APIs de e/s síncronas, `HttpRequest.Body.Read`como `HttpResponse.Body.Write`, e `Stream.Flush`. Essas APIs são uma fonte de privação de thread que leva a falhas de aplicativo. No 3,0, `AllowSynchronousIO` é desabilitado por padrão. Para obter mais informações, consulte [a seção e/s síncrona no artigo Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Além de habilitar `AllowSynchronousIO` `ConfigureKestrel`as opções do, a e/s síncrona também pode ser substituída por solicitação como uma mitigação temporária:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Se você tiver problemas com <xref:System.IO.TextWriter> implementações ou outros fluxos que chamam APIs síncronas em [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), chame <xref:System.IO.Stream.DisposeAsync*> a nova API em vez disso.

Para obter mais informações, consulte [[comunicado] AllowSynchronousIO desabilitado em todos os servidores (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. Kestrel. https removido

No ASP.NET Core 2,1, o conteúdo de *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* foi movido para *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Essa era uma atualização sem interrupção usando `TypeForwardedTo` atributos. Para 3,0, o assembly vazio *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* (e o pacote NuGet) foram removidos.

Bibliotecas que fazem referência a [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) devem atualizar ASP.NET Core dependências para 2,1 ou posterior.

Os aplicativos e bibliotecas direcionados ASP.NET Core 2,1 ou posterior devem remover todas as referências diretas para o pacote [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Suporte do Json.NET

Como parte do trabalho para [melhorar a estrutura compartilhada ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), o [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) foi removido da estrutura compartilhada ASP.NET Core.

O padrão para ASP.NET Core é agora [System. Text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), que é novo no .net Core 3,0. Considere o `System.Text.Json` uso quando possível. Ele é de alto desempenho e não requer uma dependência de biblioteca adicional. No entanto `System.Text.Json` , como é novo, no momento, ele pode estar faltando recursos que seu aplicativo precisa.

Seu aplicativo poderá exigir `Netwtonsoft.Json` integração se usar `Newtonsoft.Json`um recurso específico, como JsonPatch ou conversores, ou se ele [Formatar](xref:web-api/advanced/formatting) `Newtonsoft.Json`tipos específicos.

Para usar o Json.NET em um projeto de sinalização 3,0 do ASP.NET Core, consulte [alternar para Newtonsoft. JSON](#switch-to-newtonsoftjson) neste documento.

Para usar o Json.NET em um projeto ASP.NET Core 3,0:

* Adicione uma referência de pacote a [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Atualize `Startup.ConfigureServices` para chamar `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`é compatível com os novos métodos de registro do serviço MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  As configurações de Json.NET podem ser definidas na chamada `AddNewtonsoftJson`para:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registro do serviço MVC

ASP.NET Core 3,0 adiciona novas opções para o registro de cenários MVC `Startup.ConfigureServices`dentro do.

Três novos métodos de extensão de nível superior relacionados aos cenários MVC `IServiceCollection` no estão disponíveis. Os modelos usam esses novos métodos em `UseMvc`vez de. No entanto, `AddMvc` continua se comportando como tem em versões anteriores.

O exemplo a seguir adiciona suporte para controladores e recursos relacionados à API, mas não a exibições ou páginas. O modelo de API usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

O exemplo a seguir adiciona suporte para controladores, recursos relacionados à API e exibições, mas não páginas. O modelo de aplicativo Web (MVC) usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

O exemplo a seguir adiciona suporte para Razor Pages e suporte mínimo a controlador. O modelo de aplicativo Web usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Os novos métodos também podem ser combinados. O exemplo a seguir é equivalente a `AddMvc` chamar no ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Código de inicialização de roteamento

Se um aplicativo chamar `UseMvc` ou `UseSignalR`, migre o aplicativo para o [Roteamento de ponto de extremidade](xref:fundamentals/routing) , se possível. Para melhorar a compatibilidade de roteamento de ponto de extremidade com versões anteriores do MVC, revertemos algumas das alterações na geração de URL introduzidas no ASP.NET Core 2,2. Se você enfrentou problemas ao usar o roteamento de ponto de extremidade em 2,2, espere melhorias no ASP.NET Core 3,0 com as seguintes exceções:

* Se o aplicativo implementar `IRouter` ou herdar `Route`de, use [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) como a substituição.

* Se o aplicativo acessar `RouteData.Routers` diretamente dentro do MVC para analisar URLs, você poderá substituir isso pelo uso de. `LinkParser.ParsePathByEndpointName` 
 * Defina a rota com um nome de rota.
 * Use `LinkParser.ParsePathByEndpointName` e passe o nome da rota desejada.

O roteamento de ponto de extremidade dá suporte à mesma sintaxe de padrão de rota `IRouter`e aos recursos de criação de padrão de rota como. O roteamento de `IRouteConstraint`ponto de extremidade dá suporte. O roteamento de `[Route]`ponto `[HttpGet]`de extremidade dá suporte a, e aos outros atributos de roteamento do MVC.

Para a maioria dos aplicativos `Startup` , o requer apenas alterações.

### <a name="migrate-startupconfigure"></a>Migrar inicialização. configurar

Conselhos gerais:

* Adicionar `UseRouting`.
* Se o aplicativo chamar `UseStaticFiles`, coloque `UseStaticFiles` **antes** `UseRouting`de.
* Se o aplicativo usar recursos de autenticação/autorização, `AuthorizePage` como `[Authorize]`ou, coloque a chamada `UseAuthentication` para `UseAuthorization` e **depois** `UseRouting` (e **depois** `UseCors` se o middleware CORS for usado).
* Substituir `UseMvc` ou `UseSignalR` por .`UseEndpoints`
* Se o aplicativo usar cenários [CORS](xref:security/cors) , como `[EnableCors]`, coloque a chamada para `UseCors` antes de qualquer outro middleware que use CORS (por exemplo, Place `UseCors` antes `UseAuthentication`, `UseAuthorization`e `UseEndpoints`).
* Substituir `IHostingEnvironment` `using` <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> por `IWebHostEnvironment` e adicionar uma instrução para o namespace.
* Substituir `IApplicationLifetime` por <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> namespace).
* Substituir `EnvironmentName` por <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> namespace).

O código a seguir é um exemplo `Startup.Configure` de em um aplicativo típico ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Depois de atualizar o `Startup.Configure` código anterior:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Para a maioria dos aplicativos, `UseAuthentication`chamadas `UseAuthorization`para, `UseCors` e devem aparecer entre as chamadas `UseRouting` para `UseEndpoints` e para entrar em vigor.
### <a name="health-checks"></a>Verificações de integridade

As verificações de integridade usam o roteamento de ponto de extremidade com o host genérico. No `Startup.Configure`, chame `MapHealthChecks` no construtor de ponto de extremidade com a URL do ponto de extremidade ou o caminho relativo:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Os pontos de extremidade de verificações de integridade podem:

* Especifique um ou mais hosts/portas permitidos.
* Exigir autorização.
* Exigir CORS.

Para obter mais informações, consulte <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Diretrizes de middleware de segurança

O suporte para autorização e CORS é unificado em relação à abordagem de [middleware](xref:fundamentals/middleware/index) . Isso permite o uso do mesmo middleware e funcionalidade entre esses cenários. Um middleware de autorização atualizado é fornecido nesta versão, e o middleware CORS é aprimorado para que ele possa entender os atributos usados pelos controladores MVC.

#### <a name="cors"></a>CORS

Anteriormente, o CORS poderia ser difícil de configurar. O middleware foi fornecido para uso em alguns casos de uso, mas os filtros MVC foram destinados para serem usados **sem** o middleware em outros casos de uso. Com o ASP.NET Core 3,0, recomendamos que todos os aplicativos que exigem CORS usem o middleware CORS em tandem com o roteamento de ponto de extremidade. `UseCors`pode ser fornecido com uma política padrão, e `[EnableCors]` `[DisableCors]` os atributos podem ser usados para substituir a política padrão quando necessário.

No exemplo a seguir:

* O CORS está habilitado para todos os pontos de extremidade `default` com a política nomeada.
* A `MyController` classe desabilita CORS com o `[DisableCors]` atributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorização

Em versões anteriores do ASP.NET Core, o suporte à autorização foi fornecido `[Authorize]` por meio do atributo. O middleware de autorização não estava disponível. No ASP.NET Core 3,0, o middleware de autorização é necessário. É recomendável colocar o middleware de autorização ASP.NET Core`UseAuthorization`() imediatamente `UseAuthentication`após. O middleware de autorização também pode ser configurado com uma política padrão, que pode ser substituída.

No ASP.NET Core 3,0 ou posterior, `UseAuthorization` é chamado em `Startup.Configure`, e o seguinte `HomeController` requer um usuário conectado:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Se o aplicativo usar um `AuthorizeFilter` como filtro global no MVC, é recomendável refatorar o código para fornecer uma política na chamada para. `AddAuthorization`

Inicialmente `DefaultPolicy` , o é configurado para exigir autenticação, portanto, nenhuma configuração adicional é necessária. No exemplo a seguir, os pontos de extremidade MVC são marcados `RequireAuthorization` como para que todas as solicitações devam ser autorizadas com base `DefaultPolicy`no. No entanto `HomeController` , o permite o acesso sem o usuário entrar no aplicativo `[AllowAnonymous]`devido a:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

As políticas também podem ser personalizadas. Com base no exemplo anterior, o `DefaultPolicy` é configurado para exigir autenticação e um escopo específico:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Como alternativa, todos os pontos de extremidade podem ser configurados para `[Authorize]` exigir `RequireAuthorization` autorização sem ou `FallbackPolicy`Configurando um. O `FallbackPolicy` é diferente `DefaultPolicy`do. O `DefaultPolicy` é disparado `RequireAuthorization`pelo `[Authorize]` ou, `FallbackPolicy` enquanto o é disparado quando nenhuma outra política é definida. `FallbackPolicy`é inicialmente configurado para permitir solicitações sem autorização.

O exemplo a seguir é o mesmo que o `DefaultPolicy` exemplo anterior, mas `FallbackPolicy` usa o para sempre exigir autenticação em todos os pontos de `[AllowAnonymous]` extremidade, exceto quando é especificado:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

A autorização por middleware funciona sem a estrutura com qualquer conhecimento específico de autorização. Por exemplo, as [verificações de integridade](xref:host-and-deploy/health-checks) não têm conhecimento específico de autorização, mas as verificações de integridade podem ter uma política de autorização configurável aplicada pelo middleware.

Além disso, cada ponto de extremidade pode personalizar seus requisitos de autorização. No exemplo a seguir, `UseAuthorization` processa a autorização com `DefaultPolicy`o, mas `/healthz` o ponto de extremidade de `admin` verificação de integridade requer um usuário:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

A proteção é implementada para alguns cenários. `UseEndpoint`o middleware lançará uma exceção se uma política de autorização ou CORS for ignorada devido ao middleware ausente. O suporte do Analyzer para fornecer comentários adicionais sobre a configuração incorreta está em andamento.

### <a name="signalr"></a>SignalR

O mapeamento de hubs do Signalr agora ocorre `UseEndpoints`dentro do.

Mapeie cada Hub com `MapHub`. Como nas versões anteriores, cada Hub é explicitamente listado.

No exemplo a seguir, o suporte para `ChatHub` o Hub signalr é adicionado:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Há uma nova opção para controlar os limites de tamanho de mensagens de clientes. Por exemplo, em `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

No ASP.NET Core 2,2, você pode definir `TransportMaxBufferSize` e que efetivamente controlaria o tamanho máximo da mensagem. No ASP.NET Core 3,0, essa opção agora controla apenas o tamanho máximo antes de a pressão de back.

### <a name="mvc-controllers"></a>Controladores MVC

O mapeamento de controladores agora ocorre dentro `UseEndpoints`do.

Adicione `MapControllers` se o aplicativo usar o roteamento de atributos. Como o roteamento inclui suporte para muitas estruturas no ASP.NET Core 3,0 ou posterior, adicionar controladores roteados por atributo é aceitar.

Substitua o seguinte:

* `MapRoute`por`MapControllerRoute`
* `MapAreaRoute`por`MapAreaControllerRoute`

Como o roteamento agora inclui suporte para mais do que apenas MVC, a terminologia foi alterada para tornar esses métodos claramente desconsiderando o que eles fazem. Rotas convencionais, como `MapControllerRoute` , / `MapAreaControllerRoute` sãoaplicadasnaordememquesãoadicionadas./ `MapDefaultControllerRoute` Coloque rotas mais específicas (como rotas para uma área) primeiro.

No exemplo a seguir:

* `MapControllers`Adiciona suporte para controladores roteados por atributo.
* `MapAreaControllerRoute`Adiciona uma rota convencional para controladores em uma área.
* `MapControllerRoute`Adiciona uma rota convencional para controladores.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Páginas do Razor

O mapeamento Razor Pages agora ocorre dentro `UseEndpoints`de.

Adicione `MapRazorPages` se o aplicativo usar Razor Pages. Como o roteamento de ponto de extremidade inclui suporte para muitas estruturas, adicionar Razor Pages agora é opcional.

No exemplo a seguir, `MapRazorPages` o adiciona suporte para Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Usar MVC sem roteamento de ponto de extremidade

Usar o MVC `UseMvc` via `UseMvcWithDefaultRoute` ou no ASP.NET Core 3,0 requer uma aceitação explícita dentro `Startup.ConfigureServices`do. Isso é necessário porque o MVC deve saber se ele pode contar com a autorização e middleware CORS durante a inicialização. É fornecido um analisador que avisa se o aplicativo tenta usar uma configuração sem suporte.

Se o aplicativo exigir suporte `IRouter` herdado, `EnableEndpointRouting` desabilite usando qualquer uma das seguintes `Startup.ConfigureServices`abordagens no:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Verificações de integridade

As verificações de integridade podem ser usadas como um *roteador-Ware* com roteamento de ponto de extremidade.

Adicione `MapHealthChecks` para usar verificações de integridade com roteamento de ponto de extremidade. O `MapHealthChecks` método aceita argumentos semelhantes a `UseHealthChecks`. A vantagem de usar `MapHealthChecks` o `UseHealthChecks` over é a capacidade de aplicar a autorização e ter um controle mais refinado sobre a política de correspondência.

No exemplo a seguir, `MapHealthChecks` é chamado para um ponto de extremidade de `/healthz`verificação de integridade em:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder substitui WebHostBuilder

Os modelos ASP.NET Core 3,0 usam [host genérico](xref:fundamentals/host/generic-host). Versões anteriores usavam [host da Web](xref:fundamentals/host/web-host). O código a seguir mostra a classe gerada pelo `Program` modelo ASP.NET Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

O código a seguir mostra a classe gerada `Program` pelo modelo ASP.NET Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>permanece em 3,0 e é o tipo de `webBuilder` visto no exemplo de código anterior. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>será preterido em uma versão futura e substituído por `HostBuilder`.

A alteração mais significativa de `WebHostBuilder` para `HostBuilder` está na [injeção de dependência (di)](xref:fundamentals/dependency-injection). Ao usar `HostBuilder`o, você só pode <xref:Microsoft.Extensions.Configuration.IConfiguration> injetar `Startup`e <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> entrar no construtor. As `HostBuilder` restrições de di:

* Habilite o contêiner de DI para ser criado apenas uma vez.
* Evita os problemas de tempo de vida do objeto resultante, como a resolução de várias instâncias de singletons.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addautoria movida para um assembly diferente

O ASP.NET Core 2,2 e os `AddAuthorization` métodos inferiores em *Microsoft. AspNetCore. Authorization. dll*:

* Foram renomeados `AddAuthorizationCore`.
* Foram movidos para *Microsoft. AspNetCore. Authorization. Policy. dll*.

Aplicativos que estão usando *Microsoft. AspNetCore. Authorization. dll* e *Microsoft. AspNetCore. Authorization. Policy. dll* não são afetados.

Aplicativos que não estão usando *Microsoft. AspNetCore. Authorization. Policy. dll* devem executar um dos seguintes procedimentos:

* Alternar para usando`AddAuthorizationCore`
* Adicione uma referência a *Microsoft. AspNetCore. Authorization. Policy. dll*.

Para obter mais informações, consulte [sobrecargas de alterações na `AddAuthorization(o =>`sobrecarga em um assembly diferente #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr-code"></a>Código do signalr

O cliente do sinalizador JavaScript foi alterado `@aspnet/signalr` de `@microsoft/signalr`para. Para reagir a essa alteração, altere as referências em arquivos *Package. JSON* , exigem instruções e instruções de importação ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON é o protocolo padrão

`System.Text.Json`Agora é o protocolo de Hub padrão usado pelo cliente e pelo servidor.

No `Startup.ConfigureServices`, chame `AddJsonProtocol` para definir opções de serializador.

**Servidor**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Cliente:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Alternar para Newtonsoft. JSON

Se você estiver usando recursos do `Newtonsoft.Json` que não têm suporte `System.Text.Json`no, poderá voltar para `Newtonsoft.Json`:

1. Instale o pacote NuGet [Microsoft. AspNetCore. signalr. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. No cliente, encadeamento uma `AddNewtonsoftJsonProtocol` chamada de método para a `HubConnectionBuilder` instância:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. No servidor, encadeamento uma `AddNewtonsoftJsonProtocol` chamada de método para a chamada de `AddSignalR` método `Startup.ConfigureServices`em:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Aceitar a compilação em tempo de execução

Em 3,0, a compilação em tempo de execução é um cenário de aceitação. Para habilitar a compilação em tempo <xref:mvc/views/view-compilation#runtime-compilation>de execução, consulte.

## <a name="migrating-libraries-via-multi-targeting"></a>Migrando bibliotecas por meio de vários destinos

As bibliotecas geralmente precisam dar suporte a várias versões do ASP.NET Core. A maioria das bibliotecas que foram compiladas em relação às versões anteriores do ASP.NET Core deve continuar trabalhando sem problemas. As seguintes condições exigem que o aplicativo seja compilado em Cruz:

* A biblioteca depende de um recurso que tem uma [alteração significativa](#breaking-api-changes)binária.
* A biblioteca deseja aproveitar os novos recursos do ASP.NET Core 3,0. 

Por exemplo:

```xml
<Project SDK="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Use `#ifdefs` para acender ASP.NET Core APIs específicas do 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#else if NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

## <a name="breaking-api-changes"></a>Interrompendo alterações de API

Para mais alterações significativas na versão ASP.NET Core 3,0, consulte o [repositório ASPNET/Announcements](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0). Para obter um resumo das alterações mais recentes de 2,2 a 3,0 no .NET Core, ASP.NET Core e Entity Framework Core, consulte [alterações significativas para a migração da versão 2,2 para a 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 não disponível no momento para o serviço Azure App. 

Esperamos torná-lo disponível em breve. Até que ASP.NET Core 3,0 esteja disponível no serviço Azure App, siga as instruções em [implantar ASP.NET Core versão de visualização para Azure app serviço](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
