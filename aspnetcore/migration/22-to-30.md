---
title: Migrar do ASP.NET Core 2,2 para a versão prévia 3,0
author: rick-anderson
description: Saiba como migrar um projeto ASP.NET Core 2,2 para ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/16/2019
uid: migration/22-to-30
ms.openlocfilehash: ce16961c8a30ed4b905d5a20b2230fbde269a3ed
ms.sourcegitcommit: b1e480e1736b0fe0e4d8dce4a4cf5c8e47fc2101
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/19/2019
ms.locfileid: "71108043"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrar do ASP.NET Core 2,2 para 3,0

Por [Scott Addie](https://github.com/scottaddie) e [Rick Anderson](https://twitter.com/RickAndMSFT)

Este artigo explica como atualizar um projeto existente do ASP.NET Core 2,2 para ASP.NET Core 3,0.

## <a name="prerequisites"></a>Pré-requisitos

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio para Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Atualizar o arquivo de projeto

* Defina o [moniker do Framework de destino (TFM)](/dotnet/standard/frameworks) como `netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* Remova qualquer `<PackageReference>` para o metapacote [Microsoft. AspNetCore. All](xref:fundamentals/metapackage) ou [Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app) .

* Remova qualquer `<PackageReference>` para o pacote [Microsoft. AspNetCore. Razor. Design](https://www.nuget.org/packages/Microsoft.AspNetCore.Razor.Design/) .

* Se seu aplicativo usar [analisadores de API](xref:web-api/advanced/analyzers), remova `<PackageReference>` qualquer elemento para o pacote [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) . Edite o arquivo de projeto para usar o analisador fornecido como parte do SDK do .NET Core:

```xml
<PropertyGroup>
 <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
</PropertyGroup>
```

* Atualize o `Version` atributo nos elementos `<PackageReference>` restantes para `Microsoft.AspNetCore.*` pacotes para a visualização atual (por exemplo, `3.0.0-preview5-19227-01`).

  Se não houver uma versão 3,0 de um pacote, o pacote poderá ter sido preterido em 3,0. Muitos desses pacotes fazem parte do `Microsoft.AspNetCore.App` e não devem ser referenciados individualmente. Para obter uma lista preliminar de pacotes que não são mais produzidos em 3,0, consulte [parar de produzir pacotes para assemblies de estrutura compartilhada em 3,0 (ASPNET/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756). A *estrutura compartilhada* é o conjunto de assemblies (arquivos *. dll* ) que estão instalados no computador e referenciados pelo `Microsoft.AspNetCore.App`. Saiba mais em [A estrutura compartilhada](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Os assemblies de vários componentes notáveis foram removidos `Microsoft.AspNetCore.App` do em 3,0. Adicione `<PackageReference>` elementos se você estiver usando APIs de pacotes listados em [assemblies sendo removidos de Microsoft. AspNetCore. app 3,0 (ASPNET/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755).

  Exemplos de componentes removidos incluem:

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  A lista de assemblies que estão `Microsoft.AspNetCore.App` sendo distribuídos não foi finalizada e será alterada antes de 3,0 RTM.

  Considere o código a seguir:

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  O `ReadAsAsync` método chamado no código anterior está incluído no `Microsoft.AspNet.WebApi.Client`. Instale o pacote NuGet [Microsoft. AspNet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) para resolver o problema de compilação no 3,0.

* Adicionar [suporte a JSON.net](#jsonnet-support).

* Os projetos assumem como padrão o [modelo de hospedagem em processo](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) no ASP.NET Core 3,0 ou posterior. Opcionalmente, você pode remover `<AspNetCoreHostingModel>` a propriedade no arquivo de projeto se seu valor `InProcess`for.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuração

Migre a configuração do Kestrel para o construtor de hosts da Web fornecido pelo `ConfigureWebHostDefaults` (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Se o aplicativo criar o host manualmente com `HostBuilder`o, `UseKestrel` chame no construtor de hosts `ConfigureWebHostDefaults`da Web em:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Middleware de conexão substitui adaptadores de conexão

Os adaptadores<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>de conexão () foram removidos do Kestrel. Substitua adaptadores de conexão por middleware de conexão. O middleware de conexão é semelhante ao middleware HTTP no pipeline de ASP.NET Core, mas para conexões de nível inferior. Log de conexão e HTTPS:

* Foram movidos dos adaptadores de conexão para o middleware de conexão.
* Esses métodos de extensão funcionam como nas versões anteriores do ASP.NET Core. 

Para obter mais informações, consulte [o exemplo TlsFilterConnectionHandler na seção listenoptions. Protocols do artigo Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstrações de transporte movidas e tornadas públicas

A camada de transporte Kestrel foi exposta como uma interface pública no `Connections.Abstractions`. Como parte dessas atualizações:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`e os tipos associados foram removidos.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>foi movido de <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> para as opções de transporte.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>foi removido de <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Para obter mais informações, consulte os seguintes recursos do GitHub:

* [Abstrações de rede cliente/servidor (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementar nova abstração de ouvinte Fundação e plat novamente Kestrel no início (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Cabeçalhos do trailer de solicitação do Kestrel

Para aplicativos destinados a versões anteriores do ASP.NET Core:

* Kestrel adiciona cabeçalhos de trailers em partes do HTTP/1.1 à coleção de cabeçalhos de solicitação.
* Os trailers ficam disponíveis depois que o corpo da solicitação é lido até o final.

Isso causa algumas preocupações sobre ambigüidade entre cabeçalhos e trailers, portanto, os trailers foram movidos para uma nova coleção (`RequestTrailerExtensions`) em 3,0.

Os trailers de solicitação HTTP/2 são:

* Não disponível no ASP.NET Core 2,2.
* Disponível em 3,0 como `RequestTrailerExtensions`.

Novos métodos de extensão de solicitação estão presentes para acessar esses trailers. Assim como ocorre com HTTP/1.1, os trailers ficam disponíveis depois que o corpo da solicitação é lido até o final.

Para a versão 3,0, os seguintes `RequestTrailerExtensions` métodos estão disponíveis:

* `GetDeclaredTrailers`Obtém o cabeçalho `Trailer` da solicitação que lista os marcadores a serem esperados após o corpo. &ndash;
* `SupportsTrailers`&ndash; Indica se a solicitação dá suporte ao recebimento de cabeçalhos de trailer.
* `CheckTrailersAvailable`&ndash; Verifica se a solicitação dá suporte a trailers e se está disponível para leitura. Essa verificação não pressupõe que haja trailers para leitura. Pode não haver nenhum trailer para ler mesmo se `true` for retornado por esse método.
* `GetTrailer`&ndash; Obtém o cabeçalho à direita solicitado da resposta. Verifique `SupportsTrailers` antes de `GetTrailer`chamar, ou <xref:System.NotSupportedException> um pode ocorrer se a solicitação não oferecer suporte a cabeçalhos à direita.

Para obter mais informações, consulte [colocar os trailers de solicitação em uma coleção separada (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO desabilitado

`AllowSynchronousIO`Habilita ou desabilita APIs de e/s síncronas, `HttpReqeuest.Body.Read`como `HttpResponse.Body.Write`, e `Stream.Flush`. Essas APIs são uma fonte de privação de thread que leva a falhas de aplicativo. No 3,0, `AllowSynchronousIO` é desabilitado por padrão. Para obter mais informações, consulte [a seção e/s síncrona no artigo Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Além de habilitar `AllowSynchronousIO` `ConfigureKestrel`as opções do, a e/s síncrona também pode ser substituída por solicitação como uma mitigação temporária:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Se você tiver problemas com <xref:System.IO.TextWriter> implementações ou outros fluxos que chamam APIs síncronas em [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), chame <xref:System.IO.Stream.DisposeAsync*> a nova API em vez disso.

Para obter mais informações, consulte [[comunicado] AllowSynchronousIO desabilitado em todos os servidores (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. Kestrel. https removido

No ASP.NET Core 2,1, o conteúdo de *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* foi movido para *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Essa era uma atualização sem interrupção usando `TypeForwardedTo` atributos. Para 3,0, o assembly vazio *Microsoft. AspNetCore. Server. Kestrel. HTTPS. dll* (e o pacote NuGet) foram removidos.

Bibliotecas que fazem referência a [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) devem atualizar ASP.NET Core dependências para 2,1 ou posterior.

Os aplicativos e bibliotecas direcionados ASP.NET Core 2,1 ou posterior devem remover todas as referências diretas para o pacote [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Suporte do Json.NET

Como parte do trabalho para [melhorar a estrutura compartilhada ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), o [JSON.net](https://www.newtonsoft.com/json/help/html/Introduction.htm) foi removido da estrutura compartilhada ASP.NET Core. Seu aplicativo pode exigir essa referência se usar `Newtonsoft.Json`um recurso específico, como JsonPatch ou conversores, ou se ele [Formatar](xref:web-api/advanced/formatting) `Newtonsoft.Json`tipos específicos.

Para usar o Json.NET em um projeto ASP.NET Core 3,0:

* Adicione uma referência de pacote a [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Atualize `Startup.ConfigureServices` para chamar `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`é compatível com os novos métodos de registro do serviço MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  As configurações de Json.NET podem ser definidas na chamada `AddNewtonsoftJson`para:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registro do serviço MVC

ASP.NET Core 3,0 adiciona novas opções para o registro de cenários MVC `Startup.ConfigureServices`dentro do.

Três novos métodos de extensão de nível superior relacionados aos cenários MVC `IServiceCollection` no estão disponíveis. Os modelos usam esses novos métodos em `UseMvc`vez de. No entanto, `AddMvc` continua se comportando como tem em versões anteriores.

O exemplo a seguir adiciona suporte para controladores e recursos relacionados à API, mas não a exibições ou páginas. O modelo de API usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

O exemplo a seguir adiciona suporte para controladores, recursos relacionados à API e exibições, mas não páginas. O modelo de aplicativo Web (MVC) usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

O exemplo a seguir adiciona suporte para Razor Pages e suporte mínimo a controlador. O modelo de aplicativo Web usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Os novos métodos também podem ser combinados. O exemplo a seguir é equivalente a `AddMvc` chamar no ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Código de inicialização de roteamento

Se um aplicativo chamar `UseMvc` ou `UseSignalR`, migre o aplicativo para o [Roteamento de ponto de extremidade](xref:fundamentals/routing) , se possível. Para melhorar a compatibilidade de roteamento de ponto de extremidade com versões anteriores do MVC, revertemos algumas das alterações na geração de URL introduzidas no ASP.NET Core 2,2. Se você enfrentou problemas ao usar o roteamento de ponto de extremidade em 2,2, espere melhorias no ASP.NET Core 3,0 com as seguintes exceções:

* Se o aplicativo implementar `IRouter` ou herdar `Route`do, talvez você queira evitar a migração no momento. Forneça comentários no [plano para migrar implementações baseadas em IRouter para roteamento de ponto de extremidade](https://github.com/aspnet/AspNetCore/issues/4221).

* Se o aplicativo acessar `RouteData.Routers` diretamente dentro do MVC, talvez você queira evitar a migração no momento. Forneça comentários em [diretrizes de migração para usar RouteData. roteadores](https://github.com/aspnet/AspNetCore/issues/9148).

O roteamento de ponto de extremidade dá suporte à mesma sintaxe de padrão de rota `IRouter`e aos recursos de criação de padrão de rota como. O roteamento de `IRouteConstraint`ponto de extremidade dá suporte. O roteamento de `[Route]`ponto `[HttpGet]`de extremidade dá suporte a, e aos outros atributos de roteamento do MVC.

Para a maioria dos aplicativos `Startup` , o requer apenas alterações.

### <a name="migrate-startupconfigure"></a>Migrar inicialização. configurar

Conselhos gerais:

* Adicionar `UseRouting`.
* Se o aplicativo chamar `UseStaticFiles`, coloque `UseStaticFiles` **antes** `UseRouting`de.
* Se o aplicativo usar recursos de autenticação/autorização, `AuthorizePage` como `[Authorize]`ou, coloque a chamada `UseAuthentication` para `UseAuthorization` e **depois** `UseRouting` (e **depois** `UseCors` se o middleware CORS for usado).
* Substituir `UseMvc` ou `UseSignalR` por .`UseEndpoints`
* Se o aplicativo usar cenários [CORS](xref:security/cors) , como `[EnableCors]`, coloque a chamada para `UseCors` antes de qualquer outro middleware que use CORS (por exemplo, Place `UseCors` antes `UseAuthentication`, `UseAuthorization`e `UseEndpoints`).
* Substituir `IHostingEnvironment` `using` <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> por `IWebHostEnvironment` e adicionar uma instrução para o namespace.
* Substituir `IApplicationLifetime` por <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> namespace).
* Substituir `EnvironmentName` por <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> namespace).

Veja a seguir um exemplo de `Startup.Configure` em um aplicativo típico ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Depois de atualizar o `Startup.Configure` código anterior:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="health-checks"></a>Verificações de integridade

As verificações de integridade usam o roteamento de ponto de extremidade com o host genérico. No `Startup.Configure`, chame `MapHealthChecks` no construtor de ponto de extremidade com a URL do ponto de extremidade ou o caminho relativo:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Os pontos de extremidade de verificações de integridade podem:

* Especifique um ou mais hosts/portas permitidos.
* Exigir autorização.
* Exigir CORS.

Para obter mais informações, consulte <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Diretrizes de middleware de segurança

O suporte para autorização e CORS é unificado em relação à abordagem de [middleware](xref:fundamentals/middleware/index) . Isso permite o uso do mesmo middleware e funcionalidade entre esses cenários. Um middleware de autorização atualizado é fornecido nesta versão, e o middleware CORS é aprimorado para que ele possa entender os atributos usados pelos controladores MVC.

#### <a name="cors"></a>CORS

Anteriormente, o CORS poderia ser difícil de configurar. O middleware foi fornecido para uso em alguns casos de uso, mas os filtros MVC foram destinados para serem usados **sem** o middleware em outros casos de uso. Com o ASP.NET Core 3,0, recomendamos que todos os aplicativos que exigem CORS usem o middleware CORS em tandem com o roteamento de ponto de extremidade. `UseCors`pode ser fornecido com uma política padrão, e `[EnableCors]` `[DisableCors]` os atributos podem ser usados para substituir a política padrão quando necessário.

No exemplo a seguir:

* O CORS está habilitado para todos os pontos de extremidade `default` com a política nomeada.
* A `MyController` classe desabilita CORS com o `[DisableCors]` atributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorização

Em versões anteriores do ASP.NET Core, o suporte à autorização foi fornecido `[Authorize]` por meio do atributo. O middleware de autorização não estava disponível. No ASP.NET Core 3,0, o middleware de autorização é necessário. É recomendável colocar o middleware de autorização ASP.NET Core`UseAuthorization`() imediatamente `UseAuthentication`após. O middleware de autorização também pode ser configurado com uma política padrão, que pode ser substituída.

No ASP.NET Core 3,0 ou posterior, `UseAuthorization` é chamado em `Startup.Configure`, e o seguinte `HomeController` requer um usuário conectado:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Se o aplicativo usar um `AuthorizeFilter` como filtro global no MVC, é recomendável refatorar o código para fornecer uma política na chamada para. `AddAuthorization`

Inicialmente `DefaultPolicy` , o é configurado para exigir autenticação, portanto, nenhuma configuração adicional é necessária. No exemplo a seguir, os pontos de extremidade MVC são marcados `RequireAuthorization` como para que todas as solicitações devam ser autorizadas com base `DefaultPolicy`no. No entanto `HomeController` , o permite o acesso sem o usuário entrar no aplicativo `[AllowAnonymous]`devido a:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

As políticas também podem ser personalizadas. Com base no exemplo anterior, o `DefaultPolicy` é configurado para exigir autenticação e um escopo específico:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Como alternativa, todos os pontos de extremidade podem ser configurados para `[Authorize]` exigir `RequireAuthorization` autorização sem ou `FallbackPolicy`Configurando um. O `FallbackPolicy` é diferente `DefaultPolicy`do. O `DefaultPolicy` é disparado `RequireAuthorization`pelo `[Authorize]` ou, `FallbackPolicy` enquanto o é disparado quando nenhuma outra política é definida. `FallbackPolicy`é inicialmente configurado para permitir solicitações sem autorização.

O exemplo a seguir é o mesmo que o `DefaultPolicy` exemplo anterior, mas `FallbackPolicy` usa o para sempre exigir autenticação em todos os pontos de `[AllowAnonymous]` extremidade, exceto quando é especificado:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

A autorização por middleware funciona sem a estrutura com qualquer conhecimento específico de autorização. Por exemplo, as [verificações de integridade](xref:host-and-deploy/health-checks) não têm conhecimento específico de autorização, mas as verificações de integridade podem ter uma política de autorização configurável aplicada pelo middleware.

Além disso, cada ponto de extremidade pode personalizar seus requisitos de autorização. No exemplo a seguir, `UseAuthorization` processa a autorização com `DefaultPolicy`o, mas `/healthz` o ponto de extremidade de `admin` verificação de integridade requer um usuário:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

A proteção é implementada para alguns cenários. `UseEndpoint`o middleware lançará uma exceção se uma política de autorização ou CORS for ignorada devido ao middleware ausente. O suporte do Analyzer para fornecer comentários adicionais sobre a configuração incorreta está em andamento.

### <a name="signalr"></a>SignalR

O mapeamento de hubs do Signalr agora ocorre `UseEndpoints`dentro do.

Mapeie cada Hub com `MapHub`. Como nas versões anteriores, cada Hub é explicitamente listado.

No exemplo a seguir, o suporte para `ChatHub` o Hub signalr é adicionado:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Há uma nova opção para controlar os limites de tamanho de mensagens de clientes. Por exemplo, em `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

No ASP.NET Core 2,2, você pode definir `TransportMaxBufferSize` e que efetivamente controlaria o tamanho máximo da mensagem. No ASP.NET Core 3,0, essa opção agora controla apenas o tamanho máximo antes de a pressão de back.

### <a name="mvc-controllers"></a>Controladores MVC

O mapeamento de controladores agora ocorre dentro `UseEndpoints`do.

Adicione `MapControllers` se o aplicativo usar o roteamento de atributos. Como o roteamento inclui suporte para muitas estruturas no ASP.NET Core 3,0 ou posterior, adicionar controladores roteados por atributo é aceitar.

Substitua o seguinte:

* `MapRoute`por`MapControllerRoute`
* `MapAreaRoute`por`MapAreaControllerRoute`

Como o roteamento agora inclui suporte para mais do que apenas MVC, a terminologia foi alterada para tornar esses métodos claramente desconsiderando o que eles fazem. Rotas convencionais, como `MapControllerRoute` , / `MapAreaControllerRoute` sãoaplicadasnaordememquesãoadicionadas./ `MapDefaultControllerRoute` Coloque rotas mais específicas (como rotas para uma área) primeiro.

No exemplo a seguir:

* `MapControllers`Adiciona suporte para controladores roteados por atributo.
* `MapAreaControllerRoute`Adiciona uma rota convencional para controladores em uma área.
* `MapControllerRoute`Adiciona uma rota convencional para controladores.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Páginas do Razor

O mapeamento Razor Pages agora ocorre dentro `UseEndpoints`de.

Adicione `MapRazorPages` se o aplicativo usar Razor Pages. Como o roteamento de ponto de extremidade inclui suporte para muitas estruturas, adicionar Razor Pages agora é opcional.

No exemplo a seguir, `MapRazorPages` o adiciona suporte para Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Usar MVC sem roteamento de ponto de extremidade

Usar o MVC `UseMvc` via `UseMvcWithDefaultRoute` ou no ASP.NET Core 3,0 requer uma aceitação explícita dentro `Startup.ConfigureServices`do. Isso é necessário porque o MVC deve saber se ele pode contar com a autorização e middleware CORS durante a inicialização. É fornecido um analisador que avisa se o aplicativo tenta usar uma configuração sem suporte.

Se o aplicativo exigir suporte `IRouter` herdado, `EnableEndpointRouting` desabilite usando qualquer uma das seguintes `Startup.ConfigureServices`abordagens no:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Verificações de integridade

As verificações de integridade podem ser usadas como um *roteador-Ware* com roteamento de ponto de extremidade.

Adicione `MapHealthChecks` para usar verificações de integridade com roteamento de ponto de extremidade. O `MapHealthChecks` método aceita argumentos semelhantes a `UseHealthChecks`. A vantagem de usar `MapHealthChecks` o `UseHealthChecks` over é a capacidade de aplicar a autorização e ter um controle mais refinado sobre a política de correspondência.

No exemplo a seguir, `MapHealthChecks` é chamado para um ponto de extremidade de `/healthz`verificação de integridade em:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder substitui WebHostBuilder

Os modelos ASP.NET Core 3,0 usam [host genérico](xref:fundamentals/host/generic-host). Versões anteriores usavam [host da Web](xref:fundamentals/host/web-host). O código a seguir mostra a classe gerada pelo `Program` modelo ASP.NET Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

O código a seguir mostra a classe gerada `Program` pelo modelo ASP.NET Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>permanece em 3,0 e é o tipo de `webBuilder` visto no exemplo de código anterior. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>será preterido em uma versão futura e substituído por `HostBuilder`.

A alteração mais significativa de `WebHostBuilder` para `HostBuilder` está na [injeção de dependência (di)](xref:fundamentals/dependency-injection). Ao usar `HostBuilder`o, você só pode <xref:Microsoft.Extensions.Configuration.IConfiguration> injetar `Startup`e <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> entrar no construtor. As `HostBuilder` restrições de di:

* Habilite o contêiner de DI para ser criado apenas uma vez.
* Evita os problemas de tempo de vida do objeto resultante, como a resolução de várias instâncias de singletons.

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addautoria movida para um assembly diferente

O ASP.NET Core 2,2 e os `AddAuthorization` métodos inferiores em *Microsoft. AspNetCore. Authorization. dll*:

* Foram renomeados `AddAuthorizationCore`.
* Foram movidos para *Microsoft. AspNetCore. Authorization. Policy. dll*.

Aplicativos que estão usando *Microsoft. AspNetCore. Authorization. dll* e *Microsoft. AspNetCore. Authorization. Policy. dll* não são afetados.

Aplicativos que não estão usando *Microsoft. AspNetCore. Authorization. Policy. dll* devem executar um dos seguintes procedimentos:

* Alternar para usando`AddAuthorizationCore`
* Adicione uma referência a *Microsoft. AspNetCore. Authorization. Policy. dll*.

Para obter mais informações, consulte [sobrecargas de alterações na `AddAuthorization(o =>`sobrecarga em um assembly diferente #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr-code"></a>Código do signalr

O cliente do sinalizador JavaScript foi alterado `@aspnet/signalr` de `@microsoft/signalr`para. Para reagir a essa alteração, altere as referências em arquivos *Package. JSON* , exigem instruções e instruções de importação ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. Text. JSON é o protocolo padrão

`System.Text.Json`Agora é o protocolo de Hub padrão usado pelo cliente e pelo servidor.

No `Startup.ConfigureServices`, chame `AddJsonProtocol` para definir opções de serializador.

**Servidor**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Cliente:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Alternar para Newtonsoft. JSON

Se você estiver usando recursos do `Newtonsoft.Json` que não têm suporte `System.Text.Json`no, poderá voltar para `Newtonsoft.Json`:

1. Instale o pacote NuGet [Microsoft. AspNetCore. signalr. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. No cliente, encadeamento uma `AddNewtonsoftJsonProtocol` chamada de método para a `HubConnectionBuilder` instância:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. No servidor, encadeamento uma `AddNewtonsoftJsonProtocol` chamada de método para a chamada de `AddSignalR` método `Startup.ConfigureServices`em:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Aceitar a compilação em tempo de execução

Em 3,0, a compilação em tempo de execução é um cenário de aceitação. Para habilitar a compilação em tempo <xref:mvc/views/view-compilation#runtime-compilation>de execução, consulte.
