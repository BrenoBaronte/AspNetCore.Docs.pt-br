---
title: Migrar de ASP.NET Core 2.2 para 3.0
author: rick-anderson
description: Saiba como migrar um projeto ASP.NET Core 2.2 para ASP.NET Core 3.0.
ms.author: riande
ms.custom: mvc
ms.date: 01/21/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 84ef0cfd7e2d785ed4c107dcfc30434f2aa9bfa0
ms.sourcegitcommit: 77c046331f3d633d7cc247ba77e58b89e254f487
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/16/2020
ms.locfileid: "81488781"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrar de ASP.NET Core 2.2 para 3.0

Por [Scott Addie](https://github.com/scottaddie) e [Rick Anderson](https://twitter.com/RickAndMSFT)

Este artigo explica como atualizar um projeto de ASP.NET Core 2.2 existente para ASP.NET O Core 3.0. Pode ser útil criar um novo projeto ASP.NET Core 3.0 para:

* Compare com o código ASP.NET Core 2.2.
* Copie as alterações relevantes no seu projeto ASP.NET Core 3.0.

## <a name="prerequisites"></a>Pré-requisitos

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio para Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Atualizar a versão do SDK do .NET Core em global.json

Se sua solução depender de um arquivo [global.json](/dotnet/core/tools/global-json) para segmentar uma `version` versão específica do .NET Core SDK, atualize sua propriedade para a versão 3.0 instalada na sua máquina:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Atualize o arquivo do projeto

### <a name="update-the-target-framework"></a>Atualize o Quadro de Destino

ASP.NET Core 3.0 e depois só são executados no .NET Core. Defina o [Nome do Quadro de Destino (TFM)](/dotnet/standard/frameworks) como `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Remover referências obsoletas de pacote

Um grande número de pacotes NuGet não são produzidos para ASP.NET Core 3.0. Essas referências de pacote devem ser removidas do arquivo do projeto. Considere o seguinte arquivo de projeto para um aplicativo web ASP.NET Core 2.2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

O arquivo de projeto atualizado para ASP.NET Núcleo 3.0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

O arquivo de projeto ASP.NET Core 3.0 atualizado:

* No `<PropertyGroup>`:
  * Atualiza o TFM para`netcoreapp3.0`
  * Remove o `<AspNetCoreHostingModel>` elemento. Para obter mais informações, consulte [o modelo de hospedagem](#in-process-hosting-model) em processo neste documento.

* No `<ItemGroup>`:
  * `Microsoft.AspNetCore.App`é removido. Para obter mais informações, consulte [referência framework](#framework-reference) neste documento.
  * `Microsoft.AspNetCore.Razor.Design`é removido e na lista a seguir de pacotes que não estão mais sendo produzidos.

Para ver a lista completa de pacotes que não são mais produzidos, selecione a seguinte lista de expansão:

<details>
    <summary>Clique para expandir a lista de pacotes que não estão mais sendo produzidos</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore. SignalR. Núcleo</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Revisar mudanças de quebra

[Revisar mudanças de quebra](#break)

### <a name="framework-reference"></a>Referência de quadro

Os recursos do ASP.NET Core que estavam disponíveis através de `Microsoft.AspNetCore.App` um dos pacotes listados acima estão disponíveis como parte da estrutura compartilhada. A *estrutura compartilhada* é o conjunto de conjuntos *(arquivos .dll)* que são instalados na máquina e inclui um componente de tempo de execução e um pacote de segmentação. Saiba mais em [A estrutura compartilhada](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Projetos que `Microsoft.NET.Sdk.Web` visam o SDK `Microsoft.AspNetCore.App` fazem referência implícita à estrutura.

  Não são necessárias referências adicionais para esses projetos:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Projetos que `Microsoft.NET.Sdk` `Microsoft.NET.Sdk.Razor` visam ou SDK, `FrameworkReference` `Microsoft.AspNetCore.App`devem adicionar um explícito a:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Compilações dependentes de framework usando docker

Compilações dependentes de framework de aplicativos de console que usam um pacote que depende da [estrutura compartilhada](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) ASP.NET Core podem dar o seguinte erro de tempo de execução:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`é a estrutura compartilhada que contém o tempo de execução do ASP.NET Core e só está presente na imagem [dotnet/core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker. O SDK 3.0 reduz o tamanho das compilações dependentes de estruturas usando ASP.NET Core, não incluindo cópias duplicadas de bibliotecas disponíveis na estrutura compartilhada. Esta é uma economia potencial de até 18 MB, mas requer que o tempo de execução do ASP.NET Core esteja presente/instalado para executar o aplicativo.

Para determinar se o aplicativo tem uma dependência (direta ou indireta) na estrutura compartilhada do ASP.NET Core, examine o arquivo *runtimeconfig.json* gerado durante uma compilação/publicação do seu aplicativo. O arquivo JSON a seguir mostra uma dependência da estrutura compartilhada do ASP.NET Core:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Se o seu aplicativo estiver usando o Docker, use uma imagem base que inclua ASP.NET Core 3.0. Por exemplo, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Adicionar referências de pacote para conjuntos removidos

ASP.NET Core 3.0 remove alguns conjuntos que `Microsoft.AspNetCore.App` antes faziam parte da referência do pacote. Para visualizar quais conjuntos foram removidos, compare as duas pastas de quadros compartilhados. Por exemplo, uma comparação das versões 2.2.7 e 3.0.0:

![comparação de assembléias de estruturas compartilhadas](22-to-30/_static/assembly-diff.png)

Para continuar usando recursos fornecidos pelos conjuntos removidos, consulte as versões 3.0 dos pacotes correspondentes:

* Um aplicativo web gerado por modelo com **contas de usuário individuais** requer a adição dos seguintes pacotes:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Para obter mais informações sobre como fazer referência ao pacote específico do provedor de banco de dados, consulte [Provedores](/ef/core/providers/index)de banco de dados .

* II de identidade

  O suporte para [iU de identidade](xref:security/authentication/identity) pode ser adicionado fazendo referência ao pacote [Microsoft.AspNetCore.Identity.UI.](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI)

* Serviços spa

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft.AspNetCore.SpaServices.Extensões](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* O &ndash; suporte à autenticação para fluxos de autenticação de terceiros está disponível como pacotes NuGet:

  * Facebook OAuth ([Microsoft.AspNetCore.Authentication.Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft.AspNetCore.Authentication.Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Autenticação da Conta Microsoft ([Microsoft.AspNetCore.Authentication.MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Autenticação openid connect[(Microsoft.AspNetCore.Authentication.OpenIdConnect)](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect)
  * Token do portador openID connect[(Microsoft.AspNetCore.Authentication.JwtBearer)](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer)
  * Twitter OAuth ([Microsoft.AspNetCore.Authentication.Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Autenticação WsFederation[(Microsoft.AspNetCore.Authentication.WsFederation)](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation)

* O suporte à formatação e negociação de conteúdo `System.Net.HttpClient` &ndash; para o pacote [Microsoft.AspNet.WebApi.Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet oferece extensibilidade útil para `System.Net.HttpClient` com APIs como `ReadAsAsync` e `PostJsonAsync`.

* Compilação de &ndash; tempo de execução O suporte para compilação em tempo de execução de visualizações e páginas do Razor agora faz parte do [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Suporte `Newtonsoft.Json` a &ndash; MVC (Json.NET) Para `Newtonsoft.Json` o uso de MVC agora faz parte do [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Mudanças de inicialização

A imagem a seguir mostra as linhas excluídas e alteradas em um aplicativo web ASP.NET Core 2.2 Razor Pages:

![as linhas excluídas e alteradas em um aplicativo ASP.NET Core 2.2 Razor Web](22-to-30/_static/startup2.2.png)

Na imagem anterior, o código excluído é mostrado em vermelho. O código excluído não mostra o código de opções de cookies, que foi excluído antes de comparar os arquivos.

A imagem a seguir mostra as linhas adicionadas e alteradas em um aplicativo web ASP.NET Core 3.0 Razor Pages:

![as linhas adicionadas e alteradas em um aplicativo ASP.NET Core 3.0 Razor Web](22-to-30/_static/startup3.0.png)

Na imagem anterior, o código adicionado é mostrado em verde. Para obter informações sobre as seguintes alterações:

* `services.AddMvc`para `services.AddRazorPages`, ver [o registro de serviço MVC](#mvc-service-registration) neste documento.
* `CompatibilityVersion`, <xref:mvc/compatibility-version>veja .
* `IHostingEnvironment`para `IWebHostEnvironment`, ver [este anúncio do GitHub](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization`foi adicionado aos modelos para mostrar o middleware de autorização de pedido deve ser adicionado. Se o aplicativo não usar autorização, você pode `app.UseAuthorization`remover a chamada com segurança para .
* `app.UseEndpoints`, consulte [Páginas de Barbear](#razor-pages) ou [Migrate Startup.Configure](#migrate-startupconfigure) neste documento.

### <a name="analyzer-support"></a>Suporte ao analisador

Projetos que `Microsoft.NET.Sdk.Web` visam implicitamente analisadores de referência enviados anteriormente como parte do pacote [Microsoft.AspNetCore.Mvc.Analyzers.](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) Não são necessárias referências adicionais para habilitá-las.

Se o aplicativo usar [analisadores de API enviados](xref:web-api/advanced/analyzers) anteriormente usando o pacote [Microsoft.AspNetCore.Mvc.Api.Analyzers,](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) edite o arquivo do projeto para referenciar os analisadores enviados como parte do .NET Core Web SDK:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Biblioteca de Classes do Razor

Os projetos da Razor Class Library que fornecem `AddRazorSupportForMvc` componentes de IA para MVC devem definir a propriedade no arquivo do projeto:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modelo de hospedagem em processo

Projetos padrão para o [modelo de hospedagem em processo](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) em ASP.NET Core 3.0 ou posterior. Você pode, opcionalmente, remover a `<AspNetCoreHostingModel>` propriedade `InProcess`no arquivo do projeto se o seu valor for .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuração

Migrar a configuração do Kestrel `ConfigureWebHostDefaults` para o construtor de host web fornecido por *(Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Se o aplicativo criar o `HostBuilder`host `UseKestrel` manualmente com `ConfigureWebHostDefaults`, chame o construtor de host web em :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>O Middleware de conexão substitui os adaptadores de conexão

Adaptadores`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`de conexão ( ) foram removidos de Kestrel. Substitua os adaptadores de conexão por middleware de conexão. O Connection Middleware é semelhante ao HTTP Middleware no pipeline ASP.NET Core, mas para conexões de nível inferior. HTTPS e registro de conexão:

* Foram movidos de Adaptadores de conexão para Middleware de conexão.
* Esses métodos de extensão funcionam como nas versões anteriores do ASP.NET Core. 

Para obter mais informações, consulte [o exemplo TlsFilterConnectionHandler na seção ListenOptions.Protocols do artigo Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstrações de transporte movidas e divulgadas

A camada de transporte Kestrel foi exposta `Connections.Abstractions`como uma interface pública em . Como parte dessas atualizações:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`e os tipos associados foram removidos.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>foi movido <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> para as opções de transporte.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`foi removido <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>de .

Para obter mais informações, consulte os seguintes recursos do GitHub:

* [Abstrações de rede de clientes/servidores (#10308 dotnet/AspNetCore)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementar nova abstração de ouvinte de base e re-plat Kestrel em cima (dotnet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Cabeçalhos do reboque Kestrel Request

Para aplicativos que visam versões anteriores do ASP.NET Core:

* Kestrel adiciona cabeçalhos de reboque em pedaços HTTP/1.1 na coleção de cabeçalhos de solicitação.
* Os reboques estão disponíveis depois que o corpo de solicitação é lido até o fim.

Isso causa algumas preocupações sobre a ambiguidade entre cabeçalhos e trailers, de modo que os trailers foram movidos para uma nova coleção (`RequestTrailerExtensions`) em 3.0.

Os reboques de solicitação HTTP/2 são:

* Não está disponível em ASP.NET Núcleo 2.2.
* Disponível em 3.0 como `RequestTrailerExtensions`.

Novos métodos de extensão de solicitação estão presentes para acessar esses reboques. Assim como http/1.1, os reboques estão disponíveis depois que o corpo de solicitação é lido até o final.

Para a versão 3.0, os seguintes `RequestTrailerExtensions` métodos estão disponíveis:

* `GetDeclaredTrailers`&ndash; Recebe o `Trailer` cabeçalho de solicitação que lista quais reboques esperar após o corpo.
* `SupportsTrailers`&ndash; Indica se a solicitação suporta o recebimento de cabeçalhos de reboque.
* `CheckTrailersAvailable`&ndash; Verifica se a solicitação suporta reboques e se eles estão disponíveis para serem lidos. Este cheque não pressupõe que há trailers para ler. Pode não haver reboques para `true` ler, mesmo se for devolvido por este método.
* `GetTrailer`&ndash; Recebe o cabeçalho de arrasto solicitado da resposta. Verifique `SupportsTrailers` antes `GetTrailer`de <xref:System.NotSupportedException> ligar ou pode ocorrer se a solicitação não suportar cabeçalhos de arrasto.

Para obter mais informações, consulte [Colocar reboques de solicitação em uma coleção separada (dotnet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>Permitirssosíncrono desativado

`AllowSynchronousIO`habilita ou desativa APIs síncronas `HttpRequest.Body.Read` `HttpResponse.Body.Write`de `Stream.Flush`I/O, tais como , e . Essas APIs são uma fonte de fome de threads que levam a falhas de aplicativos. No 3.0, `AllowSynchronousIO` é desativado por padrão. Para obter mais informações, consulte [a seção Síncrona de I/O no artigo kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Se for necessário i/O síncrono, ele pode `AllowSynchronousIO` ser habilitado configurando `ConfigureKestrel`a opção no servidor que está sendo usado (ao ligar, por exemplo, se estiver usando o Kestrel). Observe que os servidores (Kestrel, HttpSys, TestServer, `AllowSynchronousIO` etc.) têm sua própria opção que não afetará outros servidores. A I/O síncrona pode ser habilitada para todos `IHttpBodyControlFeature.AllowSynchronousIO` os servidores por solicitação usando a opção:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Se você tiver <xref:System.IO.TextWriter> problemas com implementações ou outros fluxos que <xref:System.IO.Stream.DisposeAsync*> chamem APIs síncronas em [Descarte,](/dotnet/standard/garbage-collection/implementing-dispose)chame a nova API em vez disso.

Para obter mais informações, consulte [[Anúncio] AllowSynchronousIO desativado em todos os servidores (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Microsoft.AspNetCore.Server.Kestrel.Https montagem removida

Em ASP.NET Núcleo 2.1, o conteúdo do *Microsoft.AspNetCore.Server.Kestrel.Https.dll* foi movido para *microsoft.AspNetCore.Server.Kestrel.Core.dll*. Esta foi uma atualização `TypeForwardedTo` não-quebra usando atributos. Para o 3.0, o conjunto *vazio microsoft.AspNetCore.server.Kestrel.Https.dll* e o pacote NuGet foram removidos.

Bibliotecas referentes ao [Microsoft.AspNetCore.Server.Kestrel.Https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) devem atualizar ASP.NET dependências core para 2,1 ou posterior.

Aplicativos e bibliotecas direcionados ao ASP.NET Core 2.1 ou posterior devem remover quaisquer referências diretas ao pacote [Microsoft.AspNetCore.Server.Kestrel.Https.](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https)

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Suporte newtonsoft.json (Json.NET)

Como parte do trabalho para [melhorar a estrutura compartilhada do Núcleo ASP.NET,](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/) [Newtonsoft.Json (Json.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) foi removido da estrutura compartilhada do núcleo ASP.NET.

O serializador JSON padrão <xref:System.Text.Json>para ASP.NET Core é agora , o que é novo no .NET Core 3.0. Considere `System.Text.Json` usar quando possível. É de alto desempenho e não requer uma dependência adicional da biblioteca. No entanto, como `System.Text.Json` é novo, pode estar faltando recursos que seu aplicativo precisa. Para obter mais informações, consulte [Como migrar de Newtonsoft.Json para System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>Use Newtonsoft.Json em um projeto SignalR ASP.NET Core 3.0

* Instale o [SignalRMicrosoft.AspNetCore. . Protocolos.Pacote NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet.

* No cliente, acorrente uma `AddNewtonsoftJsonProtocol` `HubConnectionBuilder` chamada de método para a instância:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* No servidor, acorrente uma `AddNewtonsoftJsonProtocol` `AddSignalR` chamada de `Startup.ConfigureServices`método para a chamada do método:

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Use Newtonsoft.Json em um projeto ASP.NET Core 3.0 MVC

* Instale o pacote [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

* Atualização `Startup.ConfigureServices` para `AddNewtonsoftJson`chamar .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`é compatível com os novos métodos de registro de serviços MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`as configurações podem ser `AddNewtonsoftJson`definidas na chamada para:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Nota:** Se `AddNewtonsoftJson` o método não estiver disponível, certifique-se de que você instalou o pacote [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) Um erro comum é instalar o pacote [Newtonsoft.Json](https://www.nuget.org/packages/Newtonsoft.Json/) em vez do pacote [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

## <a name="mvc-service-registration"></a>Registro de serviços MVC

ASP.NET Core 3.0 adiciona novas opções `Startup.ConfigureServices`para registrar cenários De MVC no interior .

Três novos métodos de extensão de `IServiceCollection` nível superior relacionados aos cenários de MVC estão disponíveis. Os modelos usam esses `AddMvc`novos métodos em vez de . No `AddMvc` entanto, continua a se comportar como em versões anteriores.

O exemplo a seguir adiciona suporte para controladores e recursos relacionados à API, mas não visualizações ou páginas. O modelo de API usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

O exemplo a seguir adiciona suporte para controladores, recursos relacionados à API e visualizações, mas não páginas. O modelo MVC (Web Application) usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

O exemplo a seguir adiciona suporte para Páginas de Barbear e suporte mínimo ao controlador. O modelo do Aplicativo Web usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Os novos métodos também podem ser combinados. O exemplo a seguir `AddMvc` é equivalente à chamada ASP.NET Núcleo 2.2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Código de inicialização de roteamento

Se um `UseMvc` aplicativo `UseSignalR`ligar ou migrar o aplicativo para [o Endpoint Routing,](xref:fundamentals/routing) se possível. Para melhorar a compatibilidade do Endpoint Routing com as versões anteriores do MVC, revertemos algumas das mudanças na geração de URL introduzidas no ASP.NET Core 2.2. Se você teve problemas ao usar o Endpoint Routing em 2.2, espere melhorias no ASP.NET Core 3.0 com as seguintes exceções:

* Se o aplicativo `IRouter` implementar ou `Route`herdar, use [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) como substituto.
* Se o aplicativo `RouteData.Routers` acessar diretamente o MVC para analisar URLs, você poderá substituí-lo pelo uso de [LinkParser.ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Defina a rota com um nome de rota.
  * Use `LinkParser.ParsePathByEndpointName` e passe no nome da rota desejada.

O roteamento de ponto final suporta os mesmos recursos `IRouter`de sintaxe de padrão de rota e de padrão de rota como . Suportes de roteamento de ponto final `IRouteConstraint`. O roteamento `[Route]`de `[HttpGet]`ponto final suporta , e os outros atributos de roteamento MVC.

Para a maioria `Startup` dos aplicativos, só requer alterações.

### <a name="migrate-startupconfigure"></a>Migrar inicialização.Configure

Conselho geral:

* Adicione `UseRouting`.
* Se o `UseStaticFiles`aplicativo `UseStaticFiles` chamar, coloque **antes** `UseRouting`.
* Se o aplicativo usar recursos de `AuthorizePage` `[Authorize]`autenticação/autorização, `UseAuthentication` `UseAuthorization`como ou `UseCors`, coloque `UseEndpoints`a chamada para e : **depois**, `UseRouting` e , mas antes :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Substituir `UseMvc` `UseSignalR` ou `UseEndpoints`com .
* Se o aplicativo usar cenários `[EnableCors]` [cors,](xref:security/cors) `UseCors` como , coloque a chamada antes de `UseCors` qualquer `UseAuthentication` `UseAuthorization`outro `UseEndpoints`middleware que use CORS (por exemplo, coloque antes , e ).
* `IHostingEnvironment` Substitua `IWebHostEnvironment` e `using` adicione uma <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> declaração para o namespace.
* Substitua <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> por `IApplicationLifetime` (namespace).
* Substitua <xref:Microsoft.Extensions.Hosting.Environments> <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> por `EnvironmentName` (namespace).

O código a seguir `Startup.Configure` é um exemplo de um aplicativo típico do ASP.NET Core 2.2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Depois de `Startup.Configure` atualizar o código anterior:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Para a maioria `UseAuthentication`dos `UseAuthorization`aplicativos, chamadas para , e `UseCors` deve aparecer entre as chamadas para `UseRouting` e `UseEndpoints` para ser eficaz.

### <a name="health-checks"></a>Verificações de Integridade

As verificações de saúde usam roteamento de ponto final com o Host Genérico. Em `Startup.Configure`, `MapHealthChecks` chamar o construtor de ponto final com a URL de ponto final ou caminho relativo:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Os pontos finais da Verificação de Saúde podem:

* Especifique um ou mais hosts/portas permitidas.
* Requer autorização.
* Requeira o CORS.

Para obter mais informações, consulte <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Orientação de middleware de segurança

O suporte para autorização e o CORS é unificado em torno da abordagem [do middleware.](xref:fundamentals/middleware/index) Isso permite o uso do mesmo middleware e funcionalidade em todos esses cenários. Um middleware de autorização atualizado é fornecido nesta versão, e o CORS Middleware é aprimorado para que ele possa entender os atributos usados pelos controladores MVC.

#### <a name="cors"></a>CORS

Anteriormente, o CORS poderia ser difícil de configurar. O middleware foi fornecido para uso em alguns casos de uso, mas os filtros MVC foram destinados a ser usados **sem** o middleware em outros casos de uso. Com ASP.NET Core 3.0, recomendamos que todos os aplicativos que requerem CORS utilizem o CORS Middleware em conjunto com o Endpoint Routing. `UseCors`pode ser fornecido com uma `[EnableCors]` política `[DisableCors]` padrão, e os atributos podem ser usados para substituir a política padrão quando necessário.

No exemplo a seguir:

* O CORS está habilitado para `default` todos os pontos finais com a política nomeada.
* A `MyController` classe desativa `[DisableCors]` o CORS com o atributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorização

Em versões anteriores do ASP.NET Core, o suporte à autorização era fornecido através do atributo. `[Authorize]` Middleware de autorização não estava disponível. Em ASP.NET Núcleo 3.0, é necessário middleware de autorização. Recomendamos colocar o ASP.NET Middleware de Autorização De Núcleo (`UseAuthorization`) imediatamente após `UseAuthentication`. O Middleware de autorização também pode ser configurado com uma política padrão, que pode ser substituída.

Em ASP.NET Núcleo 3.0 `UseAuthorization` ou `Startup.Configure`posterior, é `HomeController` chamado , e o seguinte requer um usuário conectado:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Ao usar o roteamento de `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` ponto final, recomendamos contra a configuração e, em vez disso, confiar no middleware Autorização.  Se o aplicativo `AuthorizeFilter` usar um filtro global no MVC, recomendamos refatorar o `AddAuthorization`código para fornecer uma política na chamada para .

O `DefaultPolicy` é inicialmente configurado para exigir autenticação, de modo que nenhuma configuração adicional é necessária. No exemplo a seguir, os pontos `RequireAuthorization` finais do MVC são marcados `DefaultPolicy`de modo que todas as solicitações devem ser autorizadas com base no . No entanto, o permite o `HomeController` acesso `[AllowAnonymous]`sem que o usuário entre no aplicativo devido a :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorização para pontos finais específicos

A autorização também pode ser configurada para classes específicas de pontos finais. O código a seguir é um exemplo de conversão `AuthorizeFilter` de um aplicativo MVC que configurou um global para um aplicativo com uma política específica que exige autorização:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

As políticas também podem ser personalizadas. O `DefaultPolicy` é configurado para exigir autenticação:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternativamente, todos os pontos finais podem `[Authorize]` ser `RequireAuthorization` configurados `FallbackPolicy`para exigir autorização sem ou configurando um . O `FallbackPolicy` é diferente `DefaultPolicy`do . O `DefaultPolicy` é acionado `[Authorize]` `RequireAuthorization`por ou `FallbackPolicy` , enquanto o é acionado quando nenhuma outra política é definida. `FallbackPolicy`é inicialmente configurado para permitir solicitações sem autorização.

O exemplo a seguir é `DefaultPolicy` o mesmo `FallbackPolicy` do exemplo anterior, mas usa `[AllowAnonymous]` o para sempre exigir autenticação em todos os pontos finais, exceto quando é especificado:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

A autorização por middleware funciona sem que o quadro tenha qualquer conhecimento específico de autorização. Por exemplo, [as verificações](xref:host-and-deploy/health-checks) de saúde não têm conhecimento específico de autorização, mas as verificações de saúde podem ter uma política de autorização configurável aplicada pelo middleware.

Além disso, cada ponto final pode personalizar seus requisitos de autorização. No exemplo a `UseAuthorization` seguir, `DefaultPolicy`a autorização `/healthz` de processos com `admin` o , mas o ponto final da verificação de saúde requer um usuário:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

A proteção é implementada para alguns cenários. Endpoints Middleware lança uma exceção se uma autorização ou política CORS for ignorada devido à falta de middleware. O suporte ao analisador para fornecer feedback adicional sobre a configuração errada está em andamento.

#### <a name="custom-authorization-handlers"></a>Manipuladores de autorização personalizados

Se o aplicativo usar manipuladores de [autorização personalizados,](xref:security/authorization/policies#authorization-handlers)o roteamento de ponto final passa um tipo de recurso diferente para os manipuladores do que o MVC. Os manipuladores que esperam que o <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> recurso de contexto do manipulador de autorização seja do tipo (o <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> tipo de recurso fornecido pelos [filtros MVC](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)) precisarão ser atualizados para lidar com recursos do tipo (o tipo de recurso dado aos manipuladores de autorização por roteamento de ponto final).

O MVC `AuthorizationFilterContext` ainda usa recursos, portanto, se o aplicativo usa filtros de autorização MVC, juntamente com a autorização de roteamento de ponto final, pode ser necessário lidar com ambos os tipos de recursos.

### SignalR

O SignalR mapeamento dos hubs `UseEndpoints`agora ocorre no interior.

Mapeie `MapHub`cada hub com . Como nas versões anteriores, cada hub está explicitamente listado.

No exemplo a seguir, `ChatHub` SignalR o suporte para o hub é adicionado:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Há uma nova opção para controlar os limites de tamanho de mensagem dos clientes. Por exemplo, em `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

Em ASP.NET Núcleo 2.2, `TransportMaxBufferSize` você poderia definir o e que efetivamente controlaria o tamanho máximo da mensagem. Em ASP.NET Núcleo 3.0, essa opção agora só controla o tamanho máximo antes que a pressão traseira seja observada.

### <a name="mvc-controllers"></a>Controladores MVC

O mapeamento dos controladores `UseEndpoints`agora ocorre no interior.

Adicione `MapControllers` se o aplicativo usar roteamento de atributos. Uma vez que o roteamento inclui suporte para muitas estruturas no ASP.NET Core 3.0 ou posterior, adicionar controladores roteados por atributos é opt-in.

Substitua o seguinte:

* `MapRoute` com `MapControllerRoute`
* `MapAreaRoute` com `MapAreaControllerRoute`

Uma vez que o roteamento agora inclui suporte para mais do que apenas MVC, a terminologia mudou para tornar esses métodos claramente afirmar o que eles fazem. Rotas convencionais `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` como são aplicadas na ordem em que são adicionadas. Coloque rotas mais específicas (como rotas para uma área) primeiro.

No exemplo a seguir:

* `MapControllers`adiciona suporte para controladores roteados por atributos.
* `MapAreaControllerRoute`adiciona uma rota convencional para controladores em uma área.
* `MapControllerRoute`adiciona uma rota convencional para controladores.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Remoção sufixo assíncrona dos nomes de ação do controlador

Em ASP.NET Núcleo 3.0, ASP.NET MVC do Núcleo remove o `Async` sufixo dos nomes de ação do controlador. Tanto o roteamento quanto a geração de links são impactados por esse novo padrão. Por exemplo:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Antes de ASP.NET Núcleo 3.0:

* A ação anterior poderia ser acessada na rota *Produtos/ListAsync.*
* A geração de `Async` link exigiu especificar o sufixo. Por exemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

Em ASP.NET Núcleo 3.0:

* A ação anterior pode ser acessada na rota *Produtos/Lista.*
* A geração de links não `Async` requer especificação do sufixo. Por exemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Essa alteração não afeta nomes especificados usando o atributo. [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) O comportamento padrão pode ser desativado `Startup.ConfigureServices`com o seguinte código em :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Alterações na geração de links

Como explicado na documentação sobre [diferenças em relação às versões anteriores de roteamento,](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)existem algumas diferenças na geração de links (usando `Url.Link` e APIs similares, por exemplo). Eles incluem:

* Por padrão, ao usar o roteamento de ponto final, a carcaça dos parâmetros de rota em URIs gerados não é necessariamente preservada. Esse comportamento pode ser `IOutboundParameterTransformer` controlado com a interface.
* A geração de um URI para uma rota inválida (um controlador/ação ou uma página que não existe) produzirá uma seqüência vazia sob roteamento de ponto final em vez de produzir um URI inválido.
* Os valores ambientais (parâmetros de rota do contexto atual) não são usados automaticamente na geração de links com roteamento de ponto final. Anteriormente, ao gerar um link para outra ação (ou página), valores de rota não especificados seriam inferidos a partir dos valores ambientais das rotas *atuais.* Ao usar o roteamento de ponto final, todos os parâmetros de rota devem ser especificados explicitamente durante a geração de links.

### <a name="razor-pages"></a>Páginas do Razor

O mapeamento de páginas `UseEndpoints`de barbear agora ocorre dentro .

Adicione `MapRazorPages` se o aplicativo usar Páginas de Barbear. Como o Endpoint Routing inclui suporte para muitas frameworks, a adição de Páginas de Barbear agora é opt-in.

No método `Startup.Configure` a `MapRazorPages` seguir, adiciona suporte para Páginas de Navalha:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Use MVC sem roteamento de ponto final

O uso `UseMvc` de `UseMvcWithDefaultRoute` MVC via ou em ASP.NET O `Startup.ConfigureServices`Núcleo 3.0 requer um opt-in explícito no interior . Isso é necessário porque a MVC deve saber se pode contar com a autorização e o CORS Middleware durante a inicialização. Um analisador é fornecido que avisa se o aplicativo tentar usar uma configuração sem suporte.

Se o aplicativo `IRouter` precisar de `EnableEndpointRouting` suporte legado, desabilite `Startup.ConfigureServices`usando qualquer uma das seguintes abordagens em :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Verificações de integridade

As verificações de saúde podem ser usadas como um *roteador-ware* com o Endpoint Routing.

Adicione `MapHealthChecks` para usar verificações de saúde com o Roteamento endpoint. O `MapHealthChecks` método aceita argumentos `UseHealthChecks`semelhantes a . A vantagem `MapHealthChecks` de `UseHealthChecks` usar mais é a capacidade de aplicar autorização e ter maior controle sobre a política de correspondência.

No exemplo a `MapHealthChecks` seguir, é chamado para `/healthz`um ponto final de verificação de saúde em :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder substitui WebHostBuilder

Os modelos ASP.NET Core 3.0 usam [host genérico](xref:fundamentals/host/generic-host). As versões anteriores usavam [o Web Host](xref:fundamentals/host/web-host). O código a seguir mostra a `Program` classe gerada do modelo ASP.NET Core 3.0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

O código a seguir mostra a classe `Program` ASP.NET core 2.2 gerada pelo modelo:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>permanece em 3.0 e é `webBuilder` o tipo do visto na amostra de código anterior. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>serão preteridos em um futuro lançamento `HostBuilder`e substituídos por .

A mudança mais `WebHostBuilder` `HostBuilder` significativa de para a to é na [injeção de dependência (DI)](xref:fundamentals/dependency-injection). Ao `HostBuilder`usar, você só pode `Startup`injetar o seguinte no construtor' :

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

As `HostBuilder` restrições DI:

* Habilite que o recipiente DI seja construído apenas uma vez.
* Evita os problemas de vida do objeto resultantes, como a resolução de várias instâncias de singletons.

Para obter mais informações, consulte [Evitar a injeção de serviço de inicialização em ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization mudou para um conjunto diferente

O ASP.NET Core 2.2 e métodos inferiores `AddAuthorization` em *Microsoft.AspNetCore.Authorization.dll*:

* Foram renomeados. `AddAuthorizationCore`
* Foram movidos para *Microsoft.AspNetCore.Authorization.Policy.dll*.

Aplicativos que estão usando *o Microsoft.AspNetCore.Authorization.dll* e *Microsoft.AspNetCore.Authorization.Policy.dll* não são afetados.

Os aplicativos que não estão usando *o Microsoft.AspNetCore.Authorization.Policy.dll* devem fazer um dos seguintes:

* Adicione uma referência ao *Microsoft.AspNetCore.Authorization.Policy.dll*. Essa abordagem funciona para a maioria dos aplicativos e é tudo o que é necessário.
* Mude para usar`AddAuthorizationCore`

Para obter mais informações, consulte [Quebrando a mudança ) `AddAuthorization(o =>`a sobrecarga vive em uma montagem diferente #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>II de identidade

Atualizações de IU de identidade para ASP.NET Core 3.0:

* Adicione uma referência de pacote ao [Microsoft.AspNetCore.Identity.UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Aplicativos que não usam Páginas `MapRazorPages`de Barbear devem ligar . Veja [páginas de barbear](#razor-pages) neste documento.
* Bootstrap 4 é a estrutura de interface do ui padrão. Defina `IdentityUIFrameworkVersion` uma propriedade do projeto para alterar o padrão. Para obter mais informações, consulte [este anúncio do GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

O SignalR cliente JavaScript `@aspnet/signalr` mudou `@microsoft/signalr`de . Para reagir a essa alteração, altere as referências `require` em arquivos `import` *package.json,* instruções e instruções ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Json é o protocolo padrão

`System.Text.Json`é agora o protocolo padrão do Hub usado pelo cliente e pelo servidor.

Em `Startup.ConfigureServices`, `AddJsonProtocol` chamada para definir opções de serializador.

**Servidor:**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Cliente:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Mude para Newtonsoft.Json

Se você estiver usando [recursos do Newtonsoft.Json que não são suportados no System.Text.Json,](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)você pode voltar para `Newtonsoft.Json`. Veja [Use Newtonsoft.Json em um SignalR projeto ASP.NET Core 3.0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) no início deste artigo.

## <a name="redis-distributed-caches"></a>Caches distribuídos redis

O pacote [Microsoft.Extensions.Caching.Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) não está disponível para ASP.NET aplicativos Core 3.0 ou posteriores. Substitua a referência do pacote por [Microsoft.Extensions.Caching.StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Para obter mais informações, consulte <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Opte por fazer compilação em tempo de execução

Antes de ASP.NET Core 3.0, a compilação de visualizações em tempo de execução era uma característica implícita da estrutura. A compilação de tempo de execução complementa a compilação de visualizações em tempo de construção. Ele permite que a estrutura compile visualizações e páginas de Razor (arquivos *.cshtml)* quando os arquivos são modificados, sem ter que reconstruir todo o aplicativo. Esse recurso suporta o cenário de fazer uma edição rápida no IDE e atualizar o navegador para visualizar as alterações.

Em ASP.NET Core 3.0, a compilação em tempo de execução é um cenário opt-in. A compilação de tempo de compilação de tempo de compilação é o único mecanismo para compilação de visualização habilitado por padrão. O tempo de execução conta com o Visual Studio ou [dotnet-watch](xref:tutorials/dotnet-watch) no Visual Studio Code para reconstruir o projeto quando ele detecta alterações em arquivos *.cshtml.* No Visual Studio, alterações para *.cs,* *.cshtml,* ou *.razor* files no projeto que está sendo executado<kbd>(Ctrl+F5),</kbd>mas não depurado<kbd>(F5),</kbd>acionam a recompilação do projeto.

Para habilitar a compilação em tempo de execução em seu projeto ASP.NET Core 3.0:

1. Instale o pacote [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) NuGet.
1. Atualização `Startup.ConfigureServices` para `AddRazorRuntimeCompilation`chamada:

    Para ASP.NET MVC do Núcleo, use o seguinte código:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Para ASP.NET Páginas de Navalha principais, use o seguinte código:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
A amostra https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation em mostra um exemplo de habilitação da compilação em tempo de execução condicionalmente em ambientes de desenvolvimento.

Para obter mais informações sobre <xref:mvc/views/view-compilation>a compilação de arquivos Razor, consulte .

## <a name="migrate-libraries-via-multi-targeting"></a>Migrar bibliotecas através de multi-segmentação

Bibliotecas muitas vezes precisam suportar várias versões do ASP.NET Core. A maioria das bibliotecas que foram compiladas em relação às versões anteriores do ASP.NET Core devem continuar trabalhando sem problemas. As seguintes condições exigem que o aplicativo seja compilado cruzadamente:

* A biblioteca conta com um recurso que tem uma mudança binária [de quebra.](#breaking-api-changes)
* A biblioteca quer aproveitar os novos recursos do ASP.NET Core 3.0. 

Por exemplo:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Use `#ifdefs` para habilitar ASP.NET APIs específicas do Core 3.0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Para obter mais informações sobre como usar ASP.NET <xref:fundamentals/target-aspnetcore>APIs do Núcleo em uma biblioteca de classes, consulte .

## <a name="miscellaneous-changes"></a>Alterações diversas

O sistema de validação no Núcleo .NET 3.0 e posteriormente trata `[Required]` parâmetros não anulados ou propriedades vinculadas como se tivessem um atributo. Para obter mais informações, consulte [o atributo [Obrigatório].](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute)

### <a name="publish"></a>Publicar

Exclua as pastas *bin* e *obj* no diretório do projeto.

## <a name="testserver"></a>TestServer

Para aplicativos <xref:Microsoft.AspNetCore.TestHost.TestServer> que usam diretamente com `TestServer` o <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> Host <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> [Genérico,](xref:fundamentals/host/web-host)crie o em uma in :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Quebrando as alterações da API

Revisar mudanças de quebra:

* [Lista completa de mudanças na versão ASP.NET Core 3.0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Quebrando alterações de API em Antiforgery, CORS, Diagnóstico, MVC e Roteamento](https://github.com/aspnet/Announcements/issues/387). Esta lista inclui a quebra de alterações para switches de compatibilidade.
* Para obter um resumo das alterações de quebra de 2,2 para 3.0 em .NET Core, ASP.NET Core e Entity Framework Core, consulte [Quebrando alterações para migração da versão 2.2 para 3.0](/dotnet/core/compatibility/2.2-3.0).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3.0 no Serviço de Aplicativos Azure

Para obter o progresso na implantação do .NET Core para Azure App Service, consulte o site oficial [do .NET Core no App Service.](https://aspnetcoreon.azurewebsites.net/) Até que o .NET Core 3.0 esteja disponível no Azure App Service, siga as instruções em [Deploy ASP.NET versão de pré-visualização do Core para o Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
