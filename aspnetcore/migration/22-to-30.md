---
title: Migrar do ASP.NET Core 2,2 para 3,0
author: rick-anderson
description: Saiba como migrar um projeto ASP.NET Core 2,2 para ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 4be20508392496e2c565314379ed8abfb6cbc59c
ms.sourcegitcommit: 24106b7ffffc9fff410a679863e28aeb2bbe5b7e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/17/2020
ms.locfileid: "90722716"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrar do ASP.NET Core 2,2 para 3,0

Por [Scott Addie](https://github.com/scottaddie) e [Rick Anderson](https://twitter.com/RickAndMSFT)

Este artigo explica como atualizar um projeto existente do ASP.NET Core 2,2 para ASP.NET Core 3,0. Pode ser útil criar um novo projeto ASP.NET Core 3,0 para:

* Compare com o ASP.NET Core código 2,2.
* Copie as alterações relevantes para seu projeto ASP.NET Core 3,0.

## <a name="prerequisites"></a>Pré-requisitos

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio para Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Atualizar a versão do SDK do .NET Core em global.json

Se sua solução depende de um [global.jsno](/dotnet/core/tools/global-json) arquivo para direcionar uma versão específica do SDK do .NET Core, atualize sua `version` propriedade para a versão 3,0 instalada em seu computador:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Atualizar o arquivo de projeto

### <a name="update-the-target-framework"></a>Atualizar a estrutura de destino

ASP.NET Core 3,0 e posterior somente são executados no .NET Core. Defina o [moniker do Framework de destino (TFM)](/dotnet/standard/frameworks) como `netcoreapp3.0` :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Remover referências de pacote obsoletas

Um grande número de pacotes NuGet não é produzido para o ASP.NET Core 3,0. Essas referências de pacote devem ser removidas do arquivo de projeto. Considere o seguinte arquivo de projeto para um aplicativo Web ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

O arquivo de projeto atualizado para o ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

O arquivo de projeto ASP.NET Core 3,0 atualizado:

* No `<PropertyGroup>`:
  * Atualiza o TFM para `netcoreapp3.0`
  * Remove o `<AspNetCoreHostingModel>` elemento. Para obter mais informações, consulte [modelo de hospedagem em processo](#in-process-hosting-model) neste documento.

* No `<ItemGroup>`:
  * `Microsoft.AspNetCore.App` é removido. Para obter mais informações, consulte [referência de estrutura](#framework-reference) neste documento.
  * `Microsoft.AspNetCore.Razor.Design` é removido e na lista de pacotes a seguir não está mais sendo produzido.

Para ver a lista completa de pacotes que não são mais produzidos, selecione a seguinte lista de expansão:

<details>
    <summary>Clique para expandir a lista de pacotes que não estão mais sendo produzidos</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft. AspNetCore. Authentication. Cookie &</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft. AspNetCore. Cookie Regras</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft. AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft. AspNetCore. Mvc.Razor</li>
        <li>Microsoft. AspNetCore. Mvc. Razor . ViewCompilation</li>
        <li>Microsoft. AspNetCore. Mvc. Razor Pages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft. AspNetCore.Razor</li>
        <li>Microsoft. AspNetCore. Razor . Appmodel</li>
        <li>Microsoft. AspNetCore. Razor . Desenvolver</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore. SignalR . Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Revisar alterações recentes

[Revisar alterações recentes](#break)

### <a name="framework-reference"></a>Referência de estrutura

Recursos de ASP.NET Core que estavam disponíveis por meio de um dos pacotes listados acima estão disponíveis como parte da `Microsoft.AspNetCore.App` estrutura compartilhada. A *estrutura compartilhada* é o conjunto de assemblies (arquivos *. dll* ) que estão instalados no computador e inclui um componente de tempo de execução e um pacote de direcionamento. Saiba mais em [A estrutura compartilhada](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Projetos direcionados ao `Microsoft.NET.Sdk.Web` SDK referenciam implicitamente a `Microsoft.AspNetCore.App` estrutura.

  Nenhuma referência adicional é necessária para esses projetos:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Os projetos direcionados `Microsoft.NET.Sdk` ou `Microsoft.NET.Sdk.Razor` SDK devem adicionar um explícito `FrameworkReference` a `Microsoft.AspNetCore.App` :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Compilações dependentes da estrutura usando o Docker

Compilações dependentes de estrutura de aplicativos de console que usam um pacote que depende da [estrutura compartilhada](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) ASP.NET Core pode fornecer o seguinte erro de tempo de execução:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` é a estrutura compartilhada que contém o tempo de execução de ASP.NET Core e só está presente na imagem [dotnet/núcleo/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker. O SDK 3,0 reduz o tamanho de compilações dependentes da estrutura usando ASP.NET Core não incluindo cópias duplicadas de bibliotecas que estão disponíveis na estrutura compartilhada. Essa é uma economia potencial de até 18 MB, mas requer que o tempo de execução do ASP.NET Core esteja presente/instalado para executar o aplicativo.

Para determinar se o aplicativo tem uma dependência (direta ou indireta) na estrutura compartilhada ASP.NET Core, examine a *runtimeconfig.jsno* arquivo gerado durante uma compilação/publicação do seu aplicativo. O arquivo JSON a seguir mostra uma dependência na estrutura compartilhada ASP.NET Core:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Se seu aplicativo estiver usando o Docker, use uma imagem base que inclua ASP.NET Core 3,0. Por exemplo, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Adicionar referências de pacote para assemblies removidos

ASP.NET Core 3,0 remove alguns assemblies que anteriormente faziam parte da `Microsoft.AspNetCore.App` referência do pacote. Para visualizar quais assemblies foram removidos, compare as duas pastas de estrutura compartilhadas. Por exemplo, uma comparação das versões 2.2.7 e 3.0.0:

![comparação de assemblies de estrutura compartilhada](22-to-30/_static/assembly-diff.png)

Para continuar usando os recursos fornecidos pelos assemblies removidos, faça referência às versões 3,0 dos pacotes correspondentes:

* Um aplicativo Web gerado por modelo com **contas de usuário individuais** requer a adição dos seguintes pacotes:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Para obter mais informações sobre como referenciar o pacote específico do provedor de banco de dados, consulte [provedores de banco de dados](/ef/core/providers/index).

* Identity IU

  O suporte à [ Identity interface do usuário](xref:security/authentication/identity) pode ser adicionado referenciando o [Microsoft. AspNetCore. Identity . Pacote da interface do usuário](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Serviços de SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Autenticação: o suporte para fluxos de autenticação de terceiros está disponível como pacotes NuGet:

  * OAuth do Facebook ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Autenticação de conta da Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Autenticação do OpenID Connect ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Token de portador OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Autenticação WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Suporte para formatação e negociação de conteúdo para `System.Net.HttpClient` : o pacote NuGet [Microsoft. AspNet. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) fornece uma extensibilidade útil para o `System.Net.HttpClient` com APIs como `ReadAsAsync` e `PostJsonAsync` .

* Razor compilação em tempo de execução: suporte para a compilação em tempo de execução de Razor exibições e páginas agora faz parte de [Microsoft. AspNetCore. Mvc. Razor . RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Suporte a MVC `Newtonsoft.Json` (JSON.net): o suporte para usar o MVC com o `Newtonsoft.Json` agora faz parte do [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="startup-changes"></a>Alterações de inicialização

A imagem a seguir mostra as linhas excluídas e alteradas em um Razor aplicativo Web ASP.NET Core páginas 2,2:

![as linhas excluídas e alteradas em um ASP.NET Core 2,2::: no-Loc (Razor)::: aplicativo Web](22-to-30/_static/startup2.2.png)

Na imagem anterior, o código excluído é mostrado em vermelho. O código excluído não mostra cookie o código de opções, que foi excluído antes de comparar os arquivos.

A imagem a seguir mostra as linhas adicionadas e alteradas em um Razor aplicativo Web ASP.NET Core páginas 3,0:

![as linhas adicionadas e alteradas em um ASP.NET Core 3,0::: no-Loc (Razor)::: aplicativo Web](22-to-30/_static/startup3.0.png)

Na imagem anterior, o código adicionado é mostrado em verde. Para obter informações sobre as seguintes alterações:

* `services.AddMvc` para `services.AddRazorPages` o, consulte [registro do serviço MVC](#mvc-service-registration) neste documento.
* `CompatibilityVersion`, consulte <xref:mvc/compatibility-version> .
* `IHostingEnvironment` para `IWebHostEnvironment` , consulte [este comunicado do GitHub](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization` foi adicionado aos modelos para mostrar que o middleware de autorização de ordem deve ser adicionado. Se o aplicativo não usar autorização, você poderá remover com segurança a chamada para `app.UseAuthorization` .
* `app.UseEndpoints`, consulte [ Razor páginas](#razor-pages) ou [migrar Startup.Configlhar](#migrate-startupconfigure) neste documento.

### <a name="analyzer-support"></a>Suporte do Analyzer

Projetos que têm `Microsoft.NET.Sdk.Web` como alvo implicitamente referenciam analisadores fornecidos anteriormente como parte do pacote [Microsoft. AspNetCore. Mvc. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . Nenhuma referência adicional é necessária para habilitá-las.

Se seu aplicativo usar [analisadores de API](xref:web-api/advanced/analyzers) fornecidos anteriormente usando o pacote [Microsoft. AspNetCore. Mvc. API. Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , edite o arquivo de projeto para fazer referência aos analisadores fornecidos como parte do SDK Web do .NET Core:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="no-locrazor-class-library"></a>Razor Biblioteca de classes

Razor Os projetos de biblioteca de classes que fornecem componentes de interface do usuário para o MVC devem definir a `AddRazorSupportForMvc` propriedade no arquivo de projeto:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Modelo de hospedagem em processo

Os projetos assumem como padrão o [modelo de hospedagem em processo](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) no ASP.NET Core 3,0 ou posterior. Opcionalmente, você pode remover a `<AspNetCoreHostingModel>` propriedade no arquivo de projeto se seu valor for `InProcess` .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuração

Migre a configuração do Kestrel para o [Construtor de hosts da Web](#hostb) fornecido pelo `ConfigureWebHostDefaults` (*Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Se o aplicativo criar o host manualmente com `HostBuilder` o, chame `UseKestrel` no construtor de hosts da Web em `ConfigureWebHostDefaults` :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Middleware de conexão substitui adaptadores de conexão

Os adaptadores `Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter` de conexão () foram removidos do Kestrel. Substitua adaptadores de conexão por middleware de conexão. O middleware de conexão é semelhante ao middleware HTTP no pipeline de ASP.NET Core, mas para conexões de nível inferior. Log de conexão e HTTPS:

* Foram movidos dos adaptadores de conexão para o middleware de conexão.
* Esses métodos de extensão funcionam como nas versões anteriores do ASP.NET Core. 

Para obter mais informações, consulte [o exemplo TlsFilterConnectionHandler na seção listenoptions. Protocols do artigo Kestrel](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Abstrações de transporte movidas e tornadas públicas

A camada de transporte Kestrel foi exposta como uma interface pública no `Connections.Abstractions` . Como parte dessas atualizações:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` e os tipos associados foram removidos.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> foi movido de <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> para as opções de transporte.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` foi removido de <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> .

Para obter mais informações, consulte os seguintes recursos do GitHub:

* [Abstrações de rede cliente/servidor (#10308 dotnet/AspNetCore)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementar nova abstração de ouvinte Fundação e plat novamente Kestrel na parte superior (dotNet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Cabeçalhos do trailer de solicitação do Kestrel

Para aplicativos destinados a versões anteriores do ASP.NET Core:

* Kestrel adiciona cabeçalhos de trailers em partes do HTTP/1.1 à coleção de cabeçalhos de solicitação.
* Os trailers ficam disponíveis depois que o corpo da solicitação é lido até o final.

Isso causa algumas preocupações sobre ambigüidade entre cabeçalhos e trailers, portanto, os trailers foram movidos para uma nova coleção ( `RequestTrailerExtensions` ) em 3,0.

Os trailers de solicitação HTTP/2 são:

* Não disponível no ASP.NET Core 2,2.
* Disponível em 3,0 como `RequestTrailerExtensions` .

Novos métodos de extensão de solicitação estão presentes para acessar esses trailers. Assim como ocorre com HTTP/1.1, os trailers ficam disponíveis depois que o corpo da solicitação é lido até o final.

Para a versão 3,0, os seguintes `RequestTrailerExtensions` métodos estão disponíveis:

* `GetDeclaredTrailers`: Obtém o cabeçalho da solicitação `Trailer` que lista os marcadores a serem esperados após o corpo.
* `SupportsTrailers`: Indica se a solicitação dá suporte ao recebimento de cabeçalhos de trailer.
* `CheckTrailersAvailable`: Verifica se a solicitação dá suporte a trailers e se está disponível para ser lida. Essa verificação não pressupõe que haja trailers para leitura. Pode não haver nenhum trailer para ler mesmo se `true` for retornado por esse método.
* `GetTrailer`: Obtém o cabeçalho à direita solicitado da resposta. Verifique `SupportsTrailers` antes de chamar `GetTrailer` , ou um <xref:System.NotSupportedException> pode ocorrer se a solicitação não oferecer suporte a cabeçalhos à direita.

Para obter mais informações, consulte [colocar os trailers de solicitação em uma coleção separada (dotNet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO desabilitado

`AllowSynchronousIO` Habilita ou desabilita APIs de e/s síncronas, como `HttpRequest.Body.Read` , `HttpResponse.Body.Write` e `Stream.Flush` . Essas APIs são uma fonte de privação de thread que leva a falhas de aplicativo. No 3,0, `AllowSynchronousIO` é desabilitado por padrão. Para obter mais informações, consulte [a seção e/s síncrona no artigo Kestrel](../fundamentals/servers/kestrel.md?view=aspnetcore-3.0#synchronous-io).

Se a e/s síncrona for necessária, ela poderá ser habilitada Configurando a `AllowSynchronousIO` opção no servidor que está sendo usado (ao chamar `ConfigureKestrel` , por exemplo, se estiver usando Kestrel). Observe que os servidores (Kestrel, HttpSa, TestServer, etc.) têm sua própria `AllowSynchronousIO` opção que não afetará outros servidores. A e/s síncrona pode ser habilitada para todos os servidores de acordo com a solicitação usando a `IHttpBodyControlFeature.AllowSynchronousIO` opção:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Se você tiver problemas com <xref:System.IO.TextWriter> implementações ou outros fluxos que chamam APIs síncronas em [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), chame a nova <xref:System.IO.Stream.DisposeAsync*> API em vez disso.

Para obter mais informações, consulte [[comunicado] AllowSynchronousIO desabilitado em todos os servidores (dotNet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="output-formatter-buffering"></a>Buffer de formatadores de saída

[Newtonsoft.Jsem](https://www.newtonsoft.com/json), <xref:System.Xml.Serialization.XmlSerializer> , e os <xref:System.Runtime.Serialization.DataContractSerializer> formatadores de saída baseados dão suporte apenas à serialização síncrona. Para permitir que esses formatadores funcionem com as restrições [AllowSynchronousIO](https://github.com/dotnet/aspnetcore/issues/7644) do servidor, o MVC armazena em buffer a saída desses formatadores antes de gravar no disco. Como resultado do armazenamento em buffer, o MVC incluirá o cabeçalho Content-Length ao responder usando esses formatadores.

<xref:System.Text.Json> dá suporte à serialização assíncrona e, consequentemente, o `System.Text.Json` formatador baseado não armazena em buffer. Considere usar este formatador para melhorar o desempenho.

Para desabilitar o armazenamento em buffer, os aplicativos podem ser configurados <xref:Microsoft.AspNetCore.Mvc.MvcOptions.SuppressOutputFormatterBuffering> em sua inicialização:

```csharp
services.AddControllers(options => options.SuppressOutputFormatterBuffering = true)
```

Observe que isso pode resultar no aplicativo lançar uma exceção de tempo de execução se `AllowSynchronousIO` também não estiver configurado.

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Assembly Microsoft. AspNetCore. Server. Kestrel. https removido

No ASP.NET Core 2,1, o conteúdo de *Microsoft.AspNetCore.Server.Kestrel.Https.dll* foi movido para *Microsoft.AspNetCore.Server.Kestrel.Core.dll*. Essa era uma atualização sem interrupção usando `TypeForwardedTo` atributos. Para 3,0, o assembly de *Microsoft.AspNetCore.Server.Kestrel.Https.dll* vazio e o pacote NuGet foram removidos.

Bibliotecas que fazem referência a [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) devem atualizar ASP.NET Core dependências para 2,1 ou posterior.

Os aplicativos e bibliotecas direcionados ASP.NET Core 2,1 ou posterior devem remover todas as referências diretas para o pacote [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Suporte do Newtonsoft.Json (Json.NET)

Como parte do trabalho para [melhorar a estrutura compartilhada ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/), [Newtonsoft.Jsno (JSON.net)](https://www.newtonsoft.com/json/help/html/Introduction.htm) foi removido da estrutura compartilhada ASP.NET Core.

O serializador JSON padrão para ASP.NET Core é agora <xref:System.Text.Json> , que é novo no .NET Core 3,0. Considere o uso `System.Text.Json` quando possível. Ele é de alto desempenho e não requer uma dependência de biblioteca adicional. No entanto, como `System.Text.Json` é novo, no momento, ele pode estar faltando recursos que seu aplicativo precisa. Para obter mais informações, consulte [como migrar do Newtonsoft.Jspara o System.Text.Jsem](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-no-locsignalr-project"></a>Usar Newtonsoft.Jsem um projeto do ASP.NET Core 3,0 SignalR

* Instale o [Microsoft. AspNetCore. SignalR . Pacote NuGet Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .

* No cliente, encadeamento uma `AddNewtonsoftJsonProtocol` chamada de método para a `HubConnectionBuilder` instância:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chathub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* No servidor, encadeamento uma `AddNewtonsoftJsonProtocol` chamada de método para a `AddSignalR` chamada de método em `Startup.ConfigureServices` :

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Usar Newtonsoft.Jsem um projeto MVC ASP.NET Core 3,0

* Instale o [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) pacote.

* Atualize `Startup.ConfigureServices` para chamar `AddNewtonsoftJson` .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` é compatível com os novos métodos de registro do serviço MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json` as configurações podem ser definidas na chamada para `AddNewtonsoftJson` :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Observação:** Se o `AddNewtonsoftJson` método não estiver disponível, verifique se você instalou o [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) pacote. Um erro comum é instalar o [Newtonsoft.Jsno](https://www.nuget.org/packages/Newtonsoft.Json/) pacote em vez do [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) pacote.

## <a name="mvc-service-registration"></a>Registro do serviço MVC

ASP.NET Core 3,0 adiciona novas opções para o registro de cenários MVC dentro do `Startup.ConfigureServices` .

Três novos métodos de extensão de nível superior relacionados aos cenários MVC no `IServiceCollection` estão disponíveis. Os modelos usam esses novos métodos em vez de `AddMvc` . No entanto, `AddMvc` continua se comportando como tem em versões anteriores.

O exemplo a seguir adiciona suporte para controladores e recursos relacionados à API, mas não a exibições ou páginas. O modelo de API usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

O exemplo a seguir adiciona suporte para controladores, recursos relacionados à API e exibições, mas não páginas. O modelo de aplicativo Web (MVC) usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

O exemplo a seguir adiciona suporte para Razor páginas e suporte mínimo a controlador. O modelo de aplicativo Web usa este código:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Os novos métodos também podem ser combinados. O exemplo a seguir é equivalente a chamar `AddMvc` no ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Código de inicialização de roteamento

Se um aplicativo chamar `UseMvc` ou `UseSignalR` , migre o aplicativo para o [Roteamento de ponto de extremidade](xref:fundamentals/routing) , se possível. Para melhorar a compatibilidade de roteamento de ponto de extremidade com versões anteriores do MVC, revertemos algumas das alterações na geração de URL introduzidas no ASP.NET Core 2,2. Se você enfrentou problemas ao usar o roteamento de ponto de extremidade em 2,2, espere melhorias no ASP.NET Core 3,0 com as seguintes exceções:

* Se o aplicativo implementar `IRouter` ou herdar de `Route` , use [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) como a substituição.
* Se o aplicativo acessar diretamente `RouteData.Routers` dentro do MVC para analisar URLs, você poderá substituir isso pelo uso de [LinkParser. ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Defina a rota com um nome de rota.
  * Use `LinkParser.ParsePathByEndpointName` e passe o nome da rota desejada.

O roteamento de ponto de extremidade dá suporte à mesma sintaxe de padrão de rota e aos recursos de criação de padrão de rota como `IRouter` . O roteamento de ponto de extremidade dá suporte `IRouteConstraint` . O roteamento de ponto de extremidade dá suporte `[Route]` `[HttpGet]` a, e aos outros atributos de roteamento do MVC.

Para a maioria dos aplicativos, o `Startup` requer apenas alterações.

### <a name="migrate-startupconfigure"></a>Migrar Startup.Configlhar

Conselhos gerais:

* Adicione `UseRouting`.
* Se o aplicativo chamar `UseStaticFiles` , coloque `UseStaticFiles` **antes** de `UseRouting` .
* Se o aplicativo usar recursos de autenticação/autorização, como `AuthorizePage` ou `[Authorize]` , coloque a chamada para `UseAuthentication` e `UseAuthorization` : **After**e `UseRouting` `UseCors` , mas antes de `UseEndpoints` :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Substituir `UseMvc` ou `UseSignalR` por `UseEndpoints` .
* Se o aplicativo usar cenários [CORS](xref:security/cors) , como `[EnableCors]` , coloque a chamada para antes de `UseCors` qualquer outro middleware que use CORS (por exemplo, Place `UseCors` antes `UseAuthentication` , `UseAuthorization` e `UseEndpoints` ).
* Substituir `IHostingEnvironment` por `IWebHostEnvironment` e adicionar uma `using` instrução para o <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> namespace.
* Substituir `IApplicationLifetime` por <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> namespace).
* Substituir `EnvironmentName` por <xref:Microsoft.Extensions.Hosting.Environments> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> namespace).

O código a seguir é um exemplo de `Startup.Configure` em um aplicativo típico ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Depois de atualizar o `Startup.Configure` código anterior:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Para a maioria dos aplicativos, chamadas para `UseAuthentication` , `UseAuthorization` e `UseCors` devem aparecer entre as chamadas para `UseRouting` e `UseEndpoints` para entrar em vigor.

### <a name="health-checks"></a>Verificações de Integridade

As verificações de integridade usam o roteamento de ponto de extremidade com o host genérico. No `Startup.Configure` , chame `MapHealthChecks` no construtor de ponto de extremidade com a URL do ponto de extremidade ou o caminho relativo:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Os pontos de extremidade de verificações de integridade podem:

* Especifique um ou mais hosts/portas permitidos.
* Exigir autorização.
* Exigir CORS.

Para obter mais informações, consulte <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Diretrizes de middleware de segurança

O suporte para autorização e CORS é unificado em relação à abordagem de [middleware](xref:fundamentals/middleware/index) . Isso permite o uso do mesmo middleware e funcionalidade entre esses cenários. Um middleware de autorização atualizado é fornecido nesta versão, e o middleware CORS é aprimorado para que ele possa entender os atributos usados pelos controladores MVC.

#### <a name="cors"></a>CORS

Anteriormente, o CORS poderia ser difícil de configurar. O middleware foi fornecido para uso em alguns casos de uso, mas os filtros MVC foram destinados para serem usados **sem** o middleware em outros casos de uso. Com o ASP.NET Core 3,0, recomendamos que todos os aplicativos que exigem CORS usem o middleware CORS em tandem com o roteamento de ponto de extremidade. `UseCors` pode ser fornecido com uma política padrão, e `[EnableCors]` `[DisableCors]` os atributos podem ser usados para substituir a política padrão quando necessário.

No exemplo a seguir:

* O CORS está habilitado para todos os pontos de extremidade com a `default` política nomeada.
* A `MyController` classe DESABILITA CORS com o `[DisableCors]` atributo.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorização

Em versões anteriores do ASP.NET Core, o suporte à autorização foi fornecido por meio do `[Authorize]` atributo. O middleware de autorização não estava disponível. No ASP.NET Core 3,0, o middleware de autorização é necessário. É recomendável colocar o middleware de autorização ASP.NET Core ( `UseAuthorization` ) imediatamente após `UseAuthentication` . O middleware de autorização também pode ser configurado com uma política padrão, que pode ser substituída.

No ASP.NET Core 3,0 ou posterior, `UseAuthorization` é chamado em `Startup.Configure` , e o seguinte `HomeController` requer um usuário conectado:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Ao usar o roteamento de ponto de extremidade, é recomendável configurar `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` e, em vez disso, depender do middleware de autorização.  Se o aplicativo usar um `AuthorizeFilter` como filtro global no MVC, é recomendável refatorar o código para fornecer uma política na chamada para `AddAuthorization` .

`DefaultPolicy`Inicialmente, o é configurado para exigir autenticação, portanto, nenhuma configuração adicional é necessária. No exemplo a seguir, os pontos de extremidade MVC são marcados como `RequireAuthorization` para que todas as solicitações devam ser autorizadas com base no `DefaultPolicy` . No entanto, o `HomeController` permite o acesso sem o usuário entrar no aplicativo devido a `[AllowAnonymous]` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorização para pontos de extremidade específicos

A autorização também pode ser configurada para classes específicas de pontos de extremidade. O código a seguir é um exemplo de conversão de um aplicativo MVC que configurou um global `AuthorizeFilter` para um aplicativo com uma política específica que requer autorização:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

As políticas também podem ser personalizadas. O `DefaultPolicy` está configurado para exigir autenticação:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Como alternativa, todos os pontos de extremidade podem ser configurados para exigir autorização sem `[Authorize]` ou `RequireAuthorization` Configurando um `FallbackPolicy` . O `FallbackPolicy` é diferente do `DefaultPolicy` . O `DefaultPolicy` é disparado pelo `[Authorize]` ou `RequireAuthorization` , enquanto o `FallbackPolicy` é disparado quando nenhuma outra política é definida. `FallbackPolicy` é inicialmente configurado para permitir solicitações sem autorização.

O exemplo a seguir é o mesmo que o `DefaultPolicy` exemplo anterior, mas usa o `FallbackPolicy` para sempre exigir autenticação em todos os pontos de extremidade, exceto quando `[AllowAnonymous]` é especificado:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

A autorização por middleware funciona sem a estrutura com qualquer conhecimento específico de autorização. Por exemplo, as [verificações de integridade](xref:host-and-deploy/health-checks) não têm conhecimento específico de autorização, mas as verificações de integridade podem ter uma política de autorização configurável aplicada pelo middleware.

Além disso, cada ponto de extremidade pode personalizar seus requisitos de autorização. No exemplo a seguir, `UseAuthorization` processa a autorização com o `DefaultPolicy` , mas o `/healthz` ponto de extremidade de verificação de integridade requer um `admin` usuário:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

A proteção é implementada para alguns cenários. O middleware de pontos de extremidade gera uma exceção se uma política de autorização ou CORS é ignorada devido ao middleware ausente. O suporte do Analyzer para fornecer comentários adicionais sobre a configuração incorreta está em andamento.

#### <a name="custom-authorization-handlers"></a>Manipuladores de autorização personalizados

Se o aplicativo usar [manipuladores de autorização](xref:security/authorization/policies#authorization-handlers)personalizados, o roteamento de ponto de extremidade passará um tipo de recurso diferente para manipuladores do que o MVC. Os manipuladores que esperam que o recurso de contexto do manipulador de autorização sejam do tipo <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (o tipo de recurso [fornecido pelos filtros MVC](xref:security/authorization/policies#access-mvc-request-context-in-handlers)) precisarão ser atualizados para manipular recursos do tipo <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (o tipo de recurso fornecido aos manipuladores de autorização por roteamento de ponto de extremidade).

O MVC ainda usa `AuthorizationFilterContext` recursos, portanto, se o aplicativo usar filtros de autorização do MVC junto com a autorização de roteamento de ponto de extremidade, poderá ser necessário lidar com os dois tipos de recursos.

### SignalR

O mapeamento de SignalR hubs agora ocorre dentro de `UseEndpoints` .

Mapeie cada Hub com `MapHub` . Como nas versões anteriores, cada Hub é explicitamente listado.

No exemplo a seguir, o suporte para o `ChatHub` SignalR Hub é adicionado:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Há uma nova opção para controlar os limites de tamanho de mensagens de clientes. Por exemplo, em `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

No ASP.NET Core 2,2, você pode definir `TransportMaxBufferSize` e que efetivamente controlaria o tamanho máximo da mensagem. No ASP.NET Core 3,0, essa opção agora controla apenas o tamanho máximo antes de a pressão de back.

### <a name="mvc-controllers"></a>Controladores MVC

O mapeamento de controladores agora ocorre dentro do `UseEndpoints` .

Adicione `MapControllers` se o aplicativo usar o roteamento de atributos. Como o roteamento inclui suporte para muitas estruturas no ASP.NET Core 3,0 ou posterior, adicionar controladores roteados por atributo é aceitar.

Substitua o seguinte:

* `MapRoute` com `MapControllerRoute`
* `MapAreaRoute` com `MapAreaControllerRoute`

Como o roteamento agora inclui suporte para mais do que apenas MVC, a terminologia foi alterada para tornar esses métodos claramente desconsiderando o que eles fazem. Rotas convencionais, como, `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` são aplicadas na ordem em que são adicionadas. Coloque rotas mais específicas (como rotas para uma área) primeiro.

No exemplo a seguir:

* `MapControllers` Adiciona suporte para controladores roteados por atributo.
* `MapAreaControllerRoute` Adiciona uma rota convencional para controladores em uma área.
* `MapControllerRoute` Adiciona uma rota convencional para controladores.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Remoção de sufixo assíncrono de nomes de ação do controlador

No ASP.NET Core 3,0, ASP.NET Core MVC remove o `Async` sufixo dos nomes de ação do controlador. O roteamento e a geração de link são afetados por esse novo padrão. Por exemplo:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Antes do ASP.NET Core 3,0:

* A ação anterior pode ser acessada na rota *Products/ListAsync* .
* Geração de link necessária ao especificar o `Async` sufixo. Por exemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

No ASP.NET Core 3,0:

* A ação anterior pode ser acessada na rota *produtos/lista* .
* A geração de link não requer a especificação do `Async` sufixo. Por exemplo:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Essa alteração não afeta os nomes especificados usando o [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) atributo. O comportamento padrão pode ser desabilitado com o seguinte código em `Startup.ConfigureServices` :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Alterações na geração de link

Conforme explicado na documentação sobre [diferenças de versões anteriores do roteamento](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), há algumas diferenças na geração de link (usando `Url.Link` e APIs semelhantes, por exemplo). Elas incluem:

* Por padrão, ao usar o roteamento de ponto de extremidade, a capitalização de parâmetros de rota em URIs gerados não é necessariamente preservada. Esse comportamento pode ser controlado com a `IOutboundParameterTransformer` interface.
* A geração de um URI para uma rota inválida (um controlador/uma ação ou uma página que não exista) produzirá uma cadeia de caracteres vazia em roteamento de ponto de extremidade em vez de produzir um URI inválido.
* Valores de ambiente (parâmetros de rota do contexto atual) não são usados automaticamente na geração de link com roteamento de ponto de extremidade. Anteriormente, ao gerar um link para outra ação (ou página), os valores de rota não especificados seriam inferidos dos valores de ambiente de rotas *atuais* . Ao usar o roteamento de ponto de extremidade, todos os parâmetros de rota devem ser especificados explicitamente durante a geração de link.

### <a name="no-locrazor-pages"></a>Razor Pages

As Razor páginas de mapeamento agora ocorrem dentro do `UseEndpoints` .

Adicione `MapRazorPages` se o aplicativo usar Razor páginas. Como o roteamento de ponto de extremidade inclui suporte para muitas estruturas, adicionar Razor páginas agora é aceitar.

No método a seguir `Startup.Configure` , o `MapRazorPages` adiciona suporte para Razor páginas:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Usar MVC sem roteamento de ponto de extremidade

Usar o MVC via `UseMvc` ou `UseMvcWithDefaultRoute` no ASP.NET Core 3,0 requer uma aceitação explícita dentro do `Startup.ConfigureServices` . Isso é necessário porque o MVC deve saber se ele pode contar com a autorização e middleware CORS durante a inicialização. É fornecido um analisador que avisa se o aplicativo tenta usar uma configuração sem suporte.

Se o aplicativo exigir suporte herdado `IRouter` , desabilite `EnableEndpointRouting` usando qualquer uma das seguintes abordagens no `Startup.ConfigureServices` :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Verificações de integridade

As verificações de integridade podem ser usadas como um *roteador-Ware* com roteamento de ponto de extremidade.

Adicione `MapHealthChecks` para usar verificações de integridade com roteamento de ponto de extremidade. O `MapHealthChecks` método aceita argumentos semelhantes a `UseHealthChecks` . A vantagem de usar o `MapHealthChecks` over `UseHealthChecks` é a capacidade de aplicar a autorização e ter um controle mais refinado sobre a política de correspondência.

No exemplo a seguir, `MapHealthChecks` é chamado para um ponto de extremidade de verificação de integridade em `/healthz` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder substitui WebHostBuilder

Os modelos ASP.NET Core 3,0 usam [host genérico](xref:fundamentals/host/generic-host). Versões anteriores usavam [host da Web](xref:fundamentals/host/web-host). O código a seguir mostra a classe gerada pelo modelo ASP.NET Core 3,0 `Program` :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

O código a seguir mostra a classe gerada pelo modelo ASP.NET Core 2,2 `Program` :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> permanece em 3,0 e é o tipo de `webBuilder` visto no exemplo de código anterior. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> será preterido em uma versão futura e substituído por `HostBuilder` .

A alteração mais significativa de `WebHostBuilder` para `HostBuilder` está na [injeção de dependência (di)](xref:fundamentals/dependency-injection). Ao usar `HostBuilder` o, você só pode injetar o seguinte `Startup` Construtor into:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

As `HostBuilder` restrições de di:

* Habilite o contêiner de DI para ser criado apenas uma vez.
* Evita os problemas de tempo de vida do objeto resultante, como a resolução de várias instâncias de singletons.

Para obter mais informações, consulte [evitando a injeção do serviço de inicialização no ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>Addautoria movida para um assembly diferente

O ASP.NET Core 2,2 e os `AddAuthorization` métodos inferiores no *Microsoft.AspNetCore.Authorization.dll*:

* Foram renomeados `AddAuthorizationCore` .
* Foram movidos para *Microsoft.AspNetCore.Authorization.Policy.dll*.

Aplicativos que estão usando *Microsoft.AspNetCore.Authorization.dll* e *Microsoft.AspNetCore.Authorization.Policy.dll* não são afetados.

Os aplicativos que não estão usando *Microsoft.AspNetCore.Authorization.Policy.dll* devem seguir um destes procedimentos:

* Adicione uma referência a *Microsoft.AspNetCore.Authorization.Policy.dll*. Essa abordagem funciona para a maioria dos aplicativos e é tudo o que é necessário.
* Alternar para usando `AddAuthorizationCore`

Para obter mais informações, consulte [ `AddAuthorization(o =>` sobrecargas de alterações na sobrecarga em um assembly diferente #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="no-locidentity-ui"></a>Identity IU

Identity Atualizações da interface do usuário para o ASP.NET Core 3,0:

* Adicione uma referência de pacote a [Microsoft. AspNetCore. Identity . Interface do usuário](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Os aplicativos que não usam Razor páginas devem chamar `MapRazorPages` . Consulte as [ Razor páginas](#razor-pages) deste documento.
* A inicialização 4 é a estrutura de interface do usuário padrão. Defina uma `IdentityUIFrameworkVersion` propriedade de projeto para alterar o padrão. Para obter mais informações, consulte [este comunicado do GitHub](https://github.com/aspnet/Announcements/issues/380).

## SignalR

O SignalR cliente JavaScript foi alterado de `@aspnet/signalr` para `@microsoft/signalr` . Para reagir a essa alteração, altere as referências em *package.jsem* arquivos, `require` instruções e instruções ECMAScript `import` .

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Jsem é o protocolo padrão

`System.Text.Json` Agora é o protocolo de Hub padrão usado pelo cliente e pelo servidor.

No `Startup.ConfigureServices` , chame `AddJsonProtocol` para definir opções de serializador.

**Servidor**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Cliente:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chathub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Alternar para o Newtonsoft.Jsem

Se você estiver usando os [recursos do Newtonsoft.Jsno que não têm suporte no System.Text.Jsno](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), você pode voltar para `Newtonsoft.Json` . Consulte [usar Newtonsoft.Jsem um SignalR projeto do ASP.NET Core 3,0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) anteriormente neste artigo.

## <a name="redis-distributed-caches"></a>Caches distribuídos do Redis

O pacote [Microsoft. Extensions. Caching. Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) não está disponível para os aplicativos ASP.NET Core 3,0 ou posteriores. Substitua a referência do pacote por [Microsoft. Extensions. Caching. StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Para obter mais informações, consulte <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Aceitar a compilação em tempo de execução

Antes do ASP.NET Core 3,0, a compilação do tempo de execução dos modos de exibição era um recurso implícito da estrutura. A compilação em tempo de execução complementa a compilação de exibições do tempo de compilação. Ele permite que a estrutura compile Razor exibições e páginas (arquivos *. cshtml* ) quando os arquivos são modificados, sem a necessidade de recriar o aplicativo inteiro. Esse recurso dá suporte ao cenário de fazer uma edição rápida no IDE e atualizar o navegador para exibir as alterações.

No ASP.NET Core 3,0, a compilação em tempo de execução é um cenário de aceitação. Compilação em tempo de compilação é o único mecanismo para a compilação de exibição que é habilitada por padrão. O tempo de execução depende do Visual Studio ou [dotnet-Watch](xref:tutorials/dotnet-watch) no Visual Studio Code para recompilar o projeto quando ele detecta alterações em arquivos *. cshtml* . No Visual Studio, as alterações em arquivos *. cs*, *. cshtml*ou *. Razor* no projeto que estão sendo executados (<kbd>Ctrl + F5</kbd>), mas não depuradas (<kbd>F5</kbd>), disparam a recompilação do projeto.

Para habilitar a compilação em tempo de execução em seu projeto ASP.NET Core 3,0:

1. Instale o [Microsoft. AspNetCore. Mvc. Razor . ](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) Pacote NuGet do RuntimeCompilation.
1. Atualização `Startup.ConfigureServices` para chamar `AddRazorRuntimeCompilation` :

    Para ASP.NET Core MVC, use o seguinte código:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Para ASP.NET Core Razor páginas, use o seguinte código:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
O exemplo em https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation mostra um exemplo de como habilitar a compilação de tempo de execução condicionalmente em ambientes de desenvolvimento.

Para obter mais informações sobre a Razor compilação de arquivos, consulte <xref:mvc/views/view-compilation> .

## <a name="migrate-libraries-via-multi-targeting"></a>Migrar bibliotecas por meio de vários destinos

As bibliotecas geralmente precisam dar suporte a várias versões do ASP.NET Core. A maioria das bibliotecas que foram compiladas em relação às versões anteriores do ASP.NET Core deve continuar trabalhando sem problemas. As seguintes condições exigem que o aplicativo seja compilado em Cruz:

* A biblioteca depende de um recurso que tem uma [alteração significativa](#breaking-api-changes)binária.
* A biblioteca deseja aproveitar os novos recursos do ASP.NET Core 3,0. 

Por exemplo:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Use `#ifdefs` para habilitar ASP.NET Core APIs específicas do 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Para obter mais informações sobre como usar ASP.NET Core APIs em uma biblioteca de classes, consulte <xref:fundamentals/target-aspnetcore> .

## <a name="miscellaneous-changes"></a>Alterações diversas

O sistema de validação no .NET Core 3,0 e posterior trata parâmetros não anuláveis ou propriedades associadas como se tivessem um `[Required]` atributo. Para obter mais informações, consulte o [atributo [Required]](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Publicar

Exclua as pastas *bin* e *obj* no diretório do projeto.

## <a name="testserver"></a>TestServer

Para aplicativos que usam <xref:Microsoft.AspNetCore.TestHost.TestServer> diretamente com o [host genérico](xref:fundamentals/host/web-host), crie o `TestServer` em um <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Interrompendo alterações de API

Revise as alterações significativas:

* [Lista completa de alterações significativas na versão ASP.NET Core 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Quebrando alterações de API em antifalsificação, CORS, diagnóstico, MVC e roteamento](https://github.com/aspnet/Announcements/issues/387). Essa lista inclui alterações significativas para as opções de compatibilidade.
* Para obter um resumo das alterações mais recentes de 2,2 a 3,0 no .NET Core, ASP.NET Core e Entity Framework Core, consulte [alterações significativas para a migração da versão 2,2 para a 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="endpoint-routing-with-catch-all-parameter"></a>Roteamento de ponto de extremidade com o parâmetro catch-all

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 no serviço Azure App

A distribuição do .NET Core para o serviço Azure App foi concluída. O .NET Core 3,0 está disponível em todos os data centers do serviço Azure App.