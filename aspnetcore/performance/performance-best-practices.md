---
title: ASP.NET principais práticas de desempenho
author: mjrousos
description: Dicas para aumentar o desempenho em aplicativos ASP.NET Core e evitar problemas comuns de desempenho.
monikerRange: '>= aspnetcore-2.1'
ms.author: riande
ms.date: 04/06/2020
no-loc:
- SignalR
uid: performance/performance-best-practices
ms.openlocfilehash: 068a35fbe410dad24030fe68c0dfd062b402212c
ms.sourcegitcommit: f0aeeab6ab6e09db713bb9b7862c45f4d447771b
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/08/2020
ms.locfileid: "80977178"
---
# <a name="aspnet-core-performance-best-practices"></a><span data-ttu-id="76d88-103">ASP.NET principais práticas de desempenho</span><span class="sxs-lookup"><span data-stu-id="76d88-103">ASP.NET Core Performance Best Practices</span></span>

<span data-ttu-id="76d88-104">Por [Mike Rousos](https://github.com/mjrousos)</span><span class="sxs-lookup"><span data-stu-id="76d88-104">By [Mike Rousos](https://github.com/mjrousos)</span></span>

<span data-ttu-id="76d88-105">Este artigo fornece diretrizes para práticas recomendadas de desempenho com ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="76d88-105">This article provides guidelines for performance best practices with ASP.NET Core.</span></span>

## <a name="cache-aggressively"></a><span data-ttu-id="76d88-106">Cache agressivamente</span><span class="sxs-lookup"><span data-stu-id="76d88-106">Cache aggressively</span></span>

<span data-ttu-id="76d88-107">O caching é discutido em várias partes deste documento.</span><span class="sxs-lookup"><span data-stu-id="76d88-107">Caching is discussed in several parts of this document.</span></span> <span data-ttu-id="76d88-108">Para obter mais informações, consulte <xref:performance/caching/response>.</span><span class="sxs-lookup"><span data-stu-id="76d88-108">For more information, see <xref:performance/caching/response>.</span></span>

## <a name="understand-hot-code-paths"></a><span data-ttu-id="76d88-109">Entenda os caminhos do código quente</span><span class="sxs-lookup"><span data-stu-id="76d88-109">Understand hot code paths</span></span>

<span data-ttu-id="76d88-110">Neste documento, um *caminho de código quente* é definido como um caminho de código que é frequentemente chamado e onde grande parte do tempo de execução ocorre.</span><span class="sxs-lookup"><span data-stu-id="76d88-110">In this document, a *hot code path* is defined as a code path that is frequently called and where much of the execution time occurs.</span></span> <span data-ttu-id="76d88-111">Caminhos de código quente normalmente limitam a escala e o desempenho do aplicativo e são discutidos em várias partes deste documento.</span><span class="sxs-lookup"><span data-stu-id="76d88-111">Hot code paths typically limit app scale-out and performance and are discussed in several parts of this document.</span></span>

## <a name="avoid-blocking-calls"></a><span data-ttu-id="76d88-112">Evite bloquear chamadas</span><span class="sxs-lookup"><span data-stu-id="76d88-112">Avoid blocking calls</span></span>

<span data-ttu-id="76d88-113">ASP.NET os aplicativos Core devem ser projetados para processar muitas solicitações simultaneamente.</span><span class="sxs-lookup"><span data-stu-id="76d88-113">ASP.NET Core apps should be designed to process many requests simultaneously.</span></span> <span data-ttu-id="76d88-114">As APIs assíncronas permitem que um pequeno pool de threads acuse milhares de solicitações simultâneas, não esperando o bloqueio de chamadas.</span><span class="sxs-lookup"><span data-stu-id="76d88-114">Asynchronous APIs allow a small pool of threads to handle thousands of concurrent requests by not waiting on blocking calls.</span></span> <span data-ttu-id="76d88-115">Em vez de esperar uma tarefa síncrona de longa duração para ser concluída, o segmento pode funcionar em outra solicitação.</span><span class="sxs-lookup"><span data-stu-id="76d88-115">Rather than waiting on a long-running synchronous task to complete, the thread can work on another request.</span></span>

<span data-ttu-id="76d88-116">Um problema de desempenho comum em ASP.NET aplicativos Core é bloquear chamadas que podem ser assíncronas.</span><span class="sxs-lookup"><span data-stu-id="76d88-116">A common performance problem in ASP.NET Core apps is blocking calls that could be asynchronous.</span></span> <span data-ttu-id="76d88-117">Muitas chamadas de bloqueio síncrono levam à [fome do Thread Pool](https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/) e aos tempos de resposta degradados.</span><span class="sxs-lookup"><span data-stu-id="76d88-117">Many synchronous blocking calls lead to [Thread Pool starvation](https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/) and degraded response times.</span></span>

<span data-ttu-id="76d88-118">**Não:**</span><span class="sxs-lookup"><span data-stu-id="76d88-118">**Do not**:</span></span>

* <span data-ttu-id="76d88-119">Bloqueie a execução assíncrona chamando [Task.Wait](/dotnet/api/system.threading.tasks.task.wait) ou [Task.Result](/dotnet/api/system.threading.tasks.task-1.result).</span><span class="sxs-lookup"><span data-stu-id="76d88-119">Block asynchronous execution by calling [Task.Wait](/dotnet/api/system.threading.tasks.task.wait) or [Task.Result](/dotnet/api/system.threading.tasks.task-1.result).</span></span>
* <span data-ttu-id="76d88-120">Adquira bloqueios em caminhos de código comuns.</span><span class="sxs-lookup"><span data-stu-id="76d88-120">Acquire locks in common code paths.</span></span> <span data-ttu-id="76d88-121">ASP.NET os aplicativos Core são mais performáticos quando projetados para executar código em paralelo.</span><span class="sxs-lookup"><span data-stu-id="76d88-121">ASP.NET Core apps are most performant when architected to run code in parallel.</span></span>
* <span data-ttu-id="76d88-122">Ligue para [Task.Run](/dotnet/api/system.threading.tasks.task.run) e aguarde imediatamente.</span><span class="sxs-lookup"><span data-stu-id="76d88-122">Call [Task.Run](/dotnet/api/system.threading.tasks.task.run) and immediately await it.</span></span> <span data-ttu-id="76d88-123">ASP.NET Core já executa o código do aplicativo em threads normais do Thread Pool, portanto, chamar Task.Run só resulta em agendamento extra desnecessário do Pool de Threads.</span><span class="sxs-lookup"><span data-stu-id="76d88-123">ASP.NET Core already runs app code on normal Thread Pool threads, so calling Task.Run only results in extra unnecessary Thread Pool scheduling.</span></span> <span data-ttu-id="76d88-124">Mesmo que o código programado bloqueie um segmento, o Task.Run não impede isso.</span><span class="sxs-lookup"><span data-stu-id="76d88-124">Even if the scheduled code would block a thread, Task.Run does not prevent that.</span></span>

<span data-ttu-id="76d88-125">**Faça:**</span><span class="sxs-lookup"><span data-stu-id="76d88-125">**Do**:</span></span>

* <span data-ttu-id="76d88-126">Faça [caminhos de código quente](#understand-hot-code-paths) assíncronos.</span><span class="sxs-lookup"><span data-stu-id="76d88-126">Make [hot code paths](#understand-hot-code-paths) asynchronous.</span></span>
* <span data-ttu-id="76d88-127">As APIs de acesso a dados, I/O e operações de longa duração são assíncronas se uma API assíncrona estiver disponível.</span><span class="sxs-lookup"><span data-stu-id="76d88-127">Call data access, I/O, and long-running operations APIs asynchronously if an asynchronous API is available.</span></span> <span data-ttu-id="76d88-128">**Não** use [Task.Run](/dotnet/api/system.threading.tasks.task.run) para fazer uma API síncrona sincronizada.</span><span class="sxs-lookup"><span data-stu-id="76d88-128">Do **not** use [Task.Run](/dotnet/api/system.threading.tasks.task.run) to make a synchronus API asynchronous.</span></span>
* <span data-ttu-id="76d88-129">Torne as ações do controlador/Razor Page assíncronas.</span><span class="sxs-lookup"><span data-stu-id="76d88-129">Make controller/Razor Page actions asynchronous.</span></span> <span data-ttu-id="76d88-130">Toda a pilha de chamadas é assíncrona para se beneficiar de padrões [assíncronos/aguardados.](/dotnet/csharp/programming-guide/concepts/async/)</span><span class="sxs-lookup"><span data-stu-id="76d88-130">The entire call stack is asynchronous in order to benefit from [async/await](/dotnet/csharp/programming-guide/concepts/async/) patterns.</span></span>

<span data-ttu-id="76d88-131">Um profiler, como [o PerfView,](https://github.com/Microsoft/perfview)pode ser usado para encontrar threads frequentemente adicionados ao [Pool de segmentos](/windows/desktop/procthread/thread-pools).</span><span class="sxs-lookup"><span data-stu-id="76d88-131">A profiler, such as [PerfView](https://github.com/Microsoft/perfview), can be used to find threads frequently added to the [Thread Pool](/windows/desktop/procthread/thread-pools).</span></span> <span data-ttu-id="76d88-132">O `Microsoft-Windows-DotNETRuntime/ThreadPoolWorkerThread/Start` evento indica um segmento adicionado ao pool de segmentos.</span><span class="sxs-lookup"><span data-stu-id="76d88-132">The `Microsoft-Windows-DotNETRuntime/ThreadPoolWorkerThread/Start` event indicates a thread added to the thread pool.</span></span> <!--  For more information, see [async guidance docs](TBD-Link_To_Davifowl_Doc)  -->

## <a name="minimize-large-object-allocations"></a><span data-ttu-id="76d88-133">Minimizar grandes alocações de objetos</span><span class="sxs-lookup"><span data-stu-id="76d88-133">Minimize large object allocations</span></span>

<span data-ttu-id="76d88-134">O [coletor de lixo .NET Core](/dotnet/standard/garbage-collection/) gerencia a alocação e a liberação de memória automaticamente em ASP.NET aplicativos Core.</span><span class="sxs-lookup"><span data-stu-id="76d88-134">The [.NET Core garbage collector](/dotnet/standard/garbage-collection/) manages allocation and release of memory automatically in ASP.NET Core apps.</span></span> <span data-ttu-id="76d88-135">A coleta automática de lixo geralmente significa que os desenvolvedores não precisam se preocupar sobre como ou quando a memória é liberada.</span><span class="sxs-lookup"><span data-stu-id="76d88-135">Automatic garbage collection generally means that developers don't need to worry about how or when memory is freed.</span></span> <span data-ttu-id="76d88-136">No entanto, limpar objetos não referenciados leva tempo da CPU, então os desenvolvedores devem minimizar a alocação de objetos em [caminhos de código quente](#understand-hot-code-paths).</span><span class="sxs-lookup"><span data-stu-id="76d88-136">However, cleaning up unreferenced objects takes CPU time, so developers should minimize allocating objects in [hot code paths](#understand-hot-code-paths).</span></span> <span data-ttu-id="76d88-137">A coleta de lixo é especialmente cara em objetos grandes (> 85 K bytes).</span><span class="sxs-lookup"><span data-stu-id="76d88-137">Garbage collection is especially expensive on large objects (> 85 K bytes).</span></span> <span data-ttu-id="76d88-138">Objetos grandes são armazenados no [grande monte de objetos](/dotnet/standard/garbage-collection/large-object-heap) e requerem uma coleta completa (geração 2) de lixo para limpar.</span><span class="sxs-lookup"><span data-stu-id="76d88-138">Large objects are stored on the [large object heap](/dotnet/standard/garbage-collection/large-object-heap) and require a full (generation 2) garbage collection to clean up.</span></span> <span data-ttu-id="76d88-139">Ao contrário das coleções de geração 0 e geração 1, uma coleção de geração 2 requer uma suspensão temporária da execução do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="76d88-139">Unlike generation 0 and generation 1 collections, a generation 2 collection requires a temporary suspension of app execution.</span></span> <span data-ttu-id="76d88-140">A alocação freqüente e a desalocação de objetos grandes podem causar desempenho inconsistente.</span><span class="sxs-lookup"><span data-stu-id="76d88-140">Frequent allocation and de-allocation of large objects can cause inconsistent performance.</span></span>

<span data-ttu-id="76d88-141">Recomendações:</span><span class="sxs-lookup"><span data-stu-id="76d88-141">Recommendations:</span></span>

* <span data-ttu-id="76d88-142">**Considere** o cache de objetos grandes que são usados com freqüência.</span><span class="sxs-lookup"><span data-stu-id="76d88-142">**Do** consider caching large objects that are frequently used.</span></span> <span data-ttu-id="76d88-143">O cache de objetos grandes evita alocações caras.</span><span class="sxs-lookup"><span data-stu-id="76d88-143">Caching large objects prevents expensive allocations.</span></span>
* <span data-ttu-id="76d88-144">**Faça** buffers de pool usando um [arrayPool\<T>](/dotnet/api/system.buffers.arraypool-1) para armazenar grandes arrays.</span><span class="sxs-lookup"><span data-stu-id="76d88-144">**Do** pool buffers by using an [ArrayPool\<T>](/dotnet/api/system.buffers.arraypool-1) to store large arrays.</span></span>
* <span data-ttu-id="76d88-145">**Não** aloque muitos objetos grandes de curta duração em [caminhos de código quente.](#understand-hot-code-paths)</span><span class="sxs-lookup"><span data-stu-id="76d88-145">**Do not** allocate many, short-lived large objects on [hot code paths](#understand-hot-code-paths).</span></span>

<span data-ttu-id="76d88-146">Problemas de memória, como o anterior, podem ser diagnosticados revisando estatísticas de coleta de lixo (GC) no [PerfView](https://github.com/Microsoft/perfview) e examinando:</span><span class="sxs-lookup"><span data-stu-id="76d88-146">Memory issues, such as the preceding, can be diagnosed by reviewing garbage collection (GC) stats in [PerfView](https://github.com/Microsoft/perfview) and examining:</span></span>

* <span data-ttu-id="76d88-147">Tempo de pausa da coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="76d88-147">Garbage collection pause time.</span></span>
* <span data-ttu-id="76d88-148">Qual a porcentagem do tempo do processador gasto na coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="76d88-148">What percentage of the processor time is spent in garbage collection.</span></span>
* <span data-ttu-id="76d88-149">Quantas coletas de lixo são geração 0, 1 e 2.</span><span class="sxs-lookup"><span data-stu-id="76d88-149">How many garbage collections are generation 0, 1, and 2.</span></span>

<span data-ttu-id="76d88-150">Para obter mais informações, consulte [Coleta e Desempenho do Lixo](/dotnet/standard/garbage-collection/performance).</span><span class="sxs-lookup"><span data-stu-id="76d88-150">For more information, see [Garbage Collection and Performance](/dotnet/standard/garbage-collection/performance).</span></span>

## <a name="optimize-data-access-and-io"></a><span data-ttu-id="76d88-151">Otimizar o acesso a dados e I/O</span><span class="sxs-lookup"><span data-stu-id="76d88-151">Optimize data access and I/O</span></span>

<span data-ttu-id="76d88-152">Interações com um armazenamento de dados e outros serviços remotos são muitas vezes as partes mais lentas de um aplicativo ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="76d88-152">Interactions with a data store and other remote services are often the slowest parts of an ASP.NET Core app.</span></span> <span data-ttu-id="76d88-153">Ler e escrever dados de forma eficiente é fundamental para um bom desempenho.</span><span class="sxs-lookup"><span data-stu-id="76d88-153">Reading and writing data efficiently is critical for good performance.</span></span>

<span data-ttu-id="76d88-154">Recomendações:</span><span class="sxs-lookup"><span data-stu-id="76d88-154">Recommendations:</span></span>

* <span data-ttu-id="76d88-155">**Chame** todas as APIs de acesso de dados de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="76d88-155">**Do** call all data access APIs asynchronously.</span></span>
* <span data-ttu-id="76d88-156">**Não** recupere mais dados do que o necessário.</span><span class="sxs-lookup"><span data-stu-id="76d88-156">**Do not** retrieve more data than is necessary.</span></span> <span data-ttu-id="76d88-157">Escreva consultas para retornar apenas os dados necessários para a solicitação HTTP atual.</span><span class="sxs-lookup"><span data-stu-id="76d88-157">Write queries to return just the data that's necessary for the current HTTP request.</span></span>
* <span data-ttu-id="76d88-158">**Considere** o cache de dados acessados com freqüência recuperados de um banco de dados ou serviço remoto se dados ligeiramente desatualizados forem aceitáveis.</span><span class="sxs-lookup"><span data-stu-id="76d88-158">**Do** consider caching frequently accessed data retrieved from a database or remote service if slightly out-of-date data is acceptable.</span></span> <span data-ttu-id="76d88-159">Dependendo do cenário, use um [MemoryCache](xref:performance/caching/memory) ou um [DistributedCache](xref:performance/caching/distributed).</span><span class="sxs-lookup"><span data-stu-id="76d88-159">Depending on the scenario, use a [MemoryCache](xref:performance/caching/memory) or a [DistributedCache](xref:performance/caching/distributed).</span></span> <span data-ttu-id="76d88-160">Para obter mais informações, consulte <xref:performance/caching/response>.</span><span class="sxs-lookup"><span data-stu-id="76d88-160">For more information, see <xref:performance/caching/response>.</span></span>
* <span data-ttu-id="76d88-161">**Minimize** as viagens de ida e volta da rede.</span><span class="sxs-lookup"><span data-stu-id="76d88-161">**Do** minimize network round trips.</span></span> <span data-ttu-id="76d88-162">O objetivo é recuperar os dados necessários em uma única chamada, em vez de várias chamadas.</span><span class="sxs-lookup"><span data-stu-id="76d88-162">The goal is to retrieve the required data in a single call rather than several calls.</span></span>
* <span data-ttu-id="76d88-163">**Use** [consultas sem rastreamento](/ef/core/querying/tracking#no-tracking-queries) no Entity Framework Core ao acessar dados para fins somente leitura.</span><span class="sxs-lookup"><span data-stu-id="76d88-163">**Do** use [no-tracking queries](/ef/core/querying/tracking#no-tracking-queries) in Entity Framework Core when accessing data for read-only purposes.</span></span> <span data-ttu-id="76d88-164">O EF Core pode retornar os resultados de consultas sem rastreamento de forma mais eficiente.</span><span class="sxs-lookup"><span data-stu-id="76d88-164">EF Core can return the results of no-tracking queries more efficiently.</span></span>
* <span data-ttu-id="76d88-165">**Filtrar** e agregar consultas LINQ (com `.Where`, `.Select`ou `.Sum` instruções, por exemplo) para que a filtragem seja realizada pelo banco de dados.</span><span class="sxs-lookup"><span data-stu-id="76d88-165">**Do** filter and aggregate LINQ queries (with `.Where`, `.Select`, or `.Sum` statements, for example) so that the filtering is performed by the database.</span></span>
* <span data-ttu-id="76d88-166">**Considere** que o EF Core resolve alguns operadores de consulta no cliente, o que pode levar a uma execução de consulta ineficiente.</span><span class="sxs-lookup"><span data-stu-id="76d88-166">**Do** consider that EF Core resolves some query operators on the client, which may lead to inefficient query execution.</span></span> <span data-ttu-id="76d88-167">Para obter mais informações, consulte [problemas de desempenho da avaliação do cliente](/ef/core/querying/client-eval#client-evaluation-performance-issues).</span><span class="sxs-lookup"><span data-stu-id="76d88-167">For more information, see [Client evaluation performance issues](/ef/core/querying/client-eval#client-evaluation-performance-issues).</span></span>
* <span data-ttu-id="76d88-168">**Não use** consultas de projeção em coleções, o que pode resultar na execução de consultas SQL "N + 1".</span><span class="sxs-lookup"><span data-stu-id="76d88-168">**Do not** use projection queries on collections, which can result in executing "N + 1" SQL queries.</span></span> <span data-ttu-id="76d88-169">Para obter mais informações, consulte [Otimização de subconsultas correlacionadas](/ef/core/what-is-new/ef-core-2.1#optimization-of-correlated-subqueries).</span><span class="sxs-lookup"><span data-stu-id="76d88-169">For more information, see [Optimization of correlated subqueries](/ef/core/what-is-new/ef-core-2.1#optimization-of-correlated-subqueries).</span></span>

<span data-ttu-id="76d88-170">Consulte [o EF High Performance](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries) para abordagens que podem melhorar o desempenho em aplicativos de alta escala:</span><span class="sxs-lookup"><span data-stu-id="76d88-170">See [EF High Performance](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries) for approaches that may improve performance in high-scale apps:</span></span>

* [<span data-ttu-id="76d88-171">Pool de DbContext</span><span class="sxs-lookup"><span data-stu-id="76d88-171">DbContext pooling</span></span>](/ef/core/what-is-new/ef-core-2.0#dbcontext-pooling)
* [<span data-ttu-id="76d88-172">Consultas explicitamente compiladas</span><span class="sxs-lookup"><span data-stu-id="76d88-172">Explicitly compiled queries</span></span>](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries)

<span data-ttu-id="76d88-173">Recomendamos medir o impacto das abordagens de alto desempenho anteriores antes de comprometer a base de código.</span><span class="sxs-lookup"><span data-stu-id="76d88-173">We recommend measuring the impact of the preceding high-performance approaches before committing the code base.</span></span> <span data-ttu-id="76d88-174">A complexidade adicional das consultas compiladas pode não justificar a melhoria do desempenho.</span><span class="sxs-lookup"><span data-stu-id="76d88-174">The additional complexity of compiled queries may not justify the performance improvement.</span></span>

<span data-ttu-id="76d88-175">Os problemas de consulta podem ser detectados revisando o tempo gasto acessando dados com [o Application Insights](/azure/application-insights/app-insights-overview) ou com ferramentas de criação de perfil.</span><span class="sxs-lookup"><span data-stu-id="76d88-175">Query issues can be detected by reviewing the time spent accessing data with [Application Insights](/azure/application-insights/app-insights-overview) or with profiling tools.</span></span> <span data-ttu-id="76d88-176">A maioria dos bancos de dados também disponibiliza estatísticas sobre consultas frequentemente executadas.</span><span class="sxs-lookup"><span data-stu-id="76d88-176">Most databases also make statistics available concerning frequently executed queries.</span></span>

## <a name="pool-http-connections-with-httpclientfactory"></a><span data-ttu-id="76d88-177">Pool conexões HTTP com httpClientFactory</span><span class="sxs-lookup"><span data-stu-id="76d88-177">Pool HTTP connections with HttpClientFactory</span></span>

<span data-ttu-id="76d88-178">Embora [o HttpClient](/dotnet/api/system.net.http.httpclient) implemente a `IDisposable` interface, ela foi projetada para reutilização.</span><span class="sxs-lookup"><span data-stu-id="76d88-178">Although [HttpClient](/dotnet/api/system.net.http.httpclient) implements the `IDisposable` interface, it's designed for reuse.</span></span> <span data-ttu-id="76d88-179">As `HttpClient` instâncias fechadas `TIME_WAIT` deixam os soquetes abertos no estado por um curto período de tempo.</span><span class="sxs-lookup"><span data-stu-id="76d88-179">Closed `HttpClient` instances leave sockets open in the `TIME_WAIT` state for a short period of time.</span></span> <span data-ttu-id="76d88-180">Se um caminho de `HttpClient` código que cria e elimina objetos é usado com freqüência, o aplicativo pode esgotar os soquetes disponíveis.</span><span class="sxs-lookup"><span data-stu-id="76d88-180">If a code path that creates and disposes of `HttpClient` objects is frequently used, the app may exhaust available sockets.</span></span> <span data-ttu-id="76d88-181">[HttpClientFactory](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) foi introduzido no ASP.NET Core 2.1 como uma solução para este problema.</span><span class="sxs-lookup"><span data-stu-id="76d88-181">[HttpClientFactory](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) was introduced in ASP.NET Core 2.1 as a solution to this problem.</span></span> <span data-ttu-id="76d88-182">Ele lida com o pool de conexões HTTP para otimizar o desempenho e a confiabilidade.</span><span class="sxs-lookup"><span data-stu-id="76d88-182">It handles pooling HTTP connections to optimize performance and reliability.</span></span>

<span data-ttu-id="76d88-183">Recomendações:</span><span class="sxs-lookup"><span data-stu-id="76d88-183">Recommendations:</span></span>

* <span data-ttu-id="76d88-184">**Não** crie e `HttpClient` elimine diretamente as instâncias.</span><span class="sxs-lookup"><span data-stu-id="76d88-184">**Do not** create and dispose of `HttpClient` instances directly.</span></span>
* <span data-ttu-id="76d88-185">**Use** [HttpClientFactory](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) para `HttpClient` recuperar instâncias.</span><span class="sxs-lookup"><span data-stu-id="76d88-185">**Do** use [HttpClientFactory](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) to retrieve `HttpClient` instances.</span></span> <span data-ttu-id="76d88-186">Para obter mais informações, consulte [Use HttpClientFactory para implementar solicitações HTTP resilientes](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests).</span><span class="sxs-lookup"><span data-stu-id="76d88-186">For more information, see [Use HttpClientFactory to implement resilient HTTP requests](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests).</span></span>

## <a name="keep-common-code-paths-fast"></a><span data-ttu-id="76d88-187">Mantenha os caminhos de código comuns rapidamente</span><span class="sxs-lookup"><span data-stu-id="76d88-187">Keep common code paths fast</span></span>

<span data-ttu-id="76d88-188">Você quer que todos os seus códigos sejam rápidos.</span><span class="sxs-lookup"><span data-stu-id="76d88-188">You want all of your code to be fast.</span></span> <span data-ttu-id="76d88-189">Os caminhos de código frequentemente chamados são os mais críticos para otimizar.</span><span class="sxs-lookup"><span data-stu-id="76d88-189">Frequently-called code paths are the most critical to optimize.</span></span> <span data-ttu-id="76d88-190">Eles incluem:</span><span class="sxs-lookup"><span data-stu-id="76d88-190">These include:</span></span>

* <span data-ttu-id="76d88-191">Os componentes de middleware no pipeline de processamento de solicitação do aplicativo, especialmente middleware, são executados no início do pipeline.</span><span class="sxs-lookup"><span data-stu-id="76d88-191">Middleware components in the app's request processing pipeline, especially middleware run early in the pipeline.</span></span> <span data-ttu-id="76d88-192">Esses componentes têm um grande impacto no desempenho.</span><span class="sxs-lookup"><span data-stu-id="76d88-192">These components have a large impact on performance.</span></span>
* <span data-ttu-id="76d88-193">Código que é executado para cada solicitação ou várias vezes por solicitação.</span><span class="sxs-lookup"><span data-stu-id="76d88-193">Code that's executed for every request or multiple times per request.</span></span> <span data-ttu-id="76d88-194">Por exemplo, registro personalizado, manipuladores de autorização ou inicialização de serviços transitórios.</span><span class="sxs-lookup"><span data-stu-id="76d88-194">For example, custom logging, authorization handlers, or initialization of transient services.</span></span>

<span data-ttu-id="76d88-195">Recomendações:</span><span class="sxs-lookup"><span data-stu-id="76d88-195">Recommendations:</span></span>

* <span data-ttu-id="76d88-196">**Não** use componentes de middleware personalizados com tarefas de longa duração.</span><span class="sxs-lookup"><span data-stu-id="76d88-196">**Do not** use custom middleware components with long-running tasks.</span></span>
* <span data-ttu-id="76d88-197">**Use** ferramentas de criação de perfil de desempenho, como [Visual Studio Diagnostic Tools](/visualstudio/profiling/profiling-feature-tour) ou [PerfView),](https://github.com/Microsoft/perfview)para identificar [caminhos de código quente](#understand-hot-code-paths).</span><span class="sxs-lookup"><span data-stu-id="76d88-197">**Do** use performance profiling tools, such as [Visual Studio Diagnostic Tools](/visualstudio/profiling/profiling-feature-tour) or [PerfView](https://github.com/Microsoft/perfview)), to identify [hot code paths](#understand-hot-code-paths).</span></span>

## <a name="complete-long-running-tasks-outside-of-http-requests"></a><span data-ttu-id="76d88-198">Concluir tarefas de longa duração fora das solicitações HTTP</span><span class="sxs-lookup"><span data-stu-id="76d88-198">Complete long-running Tasks outside of HTTP requests</span></span>

<span data-ttu-id="76d88-199">A maioria das solicitações para um aplicativo ASP.NET Core pode ser tratada por um controlador ou modelo de página chamando os serviços necessários e retornando uma resposta HTTP.</span><span class="sxs-lookup"><span data-stu-id="76d88-199">Most requests to an ASP.NET Core app can be handled by a controller or page model calling necessary services and returning an HTTP response.</span></span> <span data-ttu-id="76d88-200">Para algumas solicitações que envolvem tarefas de longa duração, é melhor tornar todo o processo de solicitação-resposta assíncrono.</span><span class="sxs-lookup"><span data-stu-id="76d88-200">For some requests that involve long-running tasks, it's better to make the entire request-response process asynchronous.</span></span>

<span data-ttu-id="76d88-201">Recomendações:</span><span class="sxs-lookup"><span data-stu-id="76d88-201">Recommendations:</span></span>

* <span data-ttu-id="76d88-202">**Não** espere que tarefas de longa duração sejam concluídas como parte do processamento de solicitação HTTP comum.</span><span class="sxs-lookup"><span data-stu-id="76d88-202">**Do not** wait for long-running tasks to complete as part of ordinary HTTP request processing.</span></span>
* <span data-ttu-id="76d88-203">**Considere** lidar com solicitações de longa duração com [serviços](xref:fundamentals/host/hosted-services) de fundo ou fora de processo com uma [função Azure](/azure/azure-functions/).</span><span class="sxs-lookup"><span data-stu-id="76d88-203">**Do** consider handling long-running requests with [background services](xref:fundamentals/host/hosted-services) or out of process with an [Azure Function](/azure/azure-functions/).</span></span> <span data-ttu-id="76d88-204">Completar o trabalho fora do processo é especialmente benéfico para tarefas intensivas em CPU.</span><span class="sxs-lookup"><span data-stu-id="76d88-204">Completing work out-of-process is especially beneficial for CPU-intensive tasks.</span></span>
* <span data-ttu-id="76d88-205">**Use** opções de comunicação em [SignalR](xref:signalr/introduction)tempo real, como, para se comunicar com os clientes de forma assíncrona.</span><span class="sxs-lookup"><span data-stu-id="76d88-205">**Do** use real-time communication options, such as [SignalR](xref:signalr/introduction), to communicate with clients asynchronously.</span></span>

## <a name="minify-client-assets"></a><span data-ttu-id="76d88-206">Minimizar ativos do cliente</span><span class="sxs-lookup"><span data-stu-id="76d88-206">Minify client assets</span></span>

<span data-ttu-id="76d88-207">ASP.NET aplicativos Core com front-ends complexos frequentemente servem muitos arquivos JavaScript, CSS ou imagem.</span><span class="sxs-lookup"><span data-stu-id="76d88-207">ASP.NET Core apps with complex front-ends frequently serve many JavaScript, CSS, or image files.</span></span> <span data-ttu-id="76d88-208">O desempenho das solicitações iniciais de carga pode ser melhorado por:</span><span class="sxs-lookup"><span data-stu-id="76d88-208">Performance of initial load requests can be improved by:</span></span>

* <span data-ttu-id="76d88-209">Agrupamento, que combina vários arquivos em um.</span><span class="sxs-lookup"><span data-stu-id="76d88-209">Bundling, which combines multiple files into one.</span></span>
* <span data-ttu-id="76d88-210">Minifying, que reduz o tamanho dos arquivos removendo espaço em branco e comentários.</span><span class="sxs-lookup"><span data-stu-id="76d88-210">Minifying, which reduces the size of files by removing whitespace and comments.</span></span>

<span data-ttu-id="76d88-211">Recomendações:</span><span class="sxs-lookup"><span data-stu-id="76d88-211">Recommendations:</span></span>

* <span data-ttu-id="76d88-212">**Use** o suporte [incorporado](xref:client-side/bundling-and-minification) do ASP.NET Core para agrupar e minificar ativos do cliente.</span><span class="sxs-lookup"><span data-stu-id="76d88-212">**Do** use ASP.NET Core's [built-in support](xref:client-side/bundling-and-minification) for bundling and minifying client assets.</span></span>
* <span data-ttu-id="76d88-213">**Considere** outras ferramentas de terceiros, como [o Webpack,](https://webpack.js.org/)para gerenciamento complexo de ativos de clientes.</span><span class="sxs-lookup"><span data-stu-id="76d88-213">**Do** consider other third-party tools, such as [Webpack](https://webpack.js.org/), for complex client asset management.</span></span>

## <a name="compress-responses"></a><span data-ttu-id="76d88-214">Compactar respostas</span><span class="sxs-lookup"><span data-stu-id="76d88-214">Compress responses</span></span>

 <span data-ttu-id="76d88-215">Reduzir o tamanho da resposta geralmente aumenta a capacidade de resposta de um aplicativo, muitas vezes de forma dramática.</span><span class="sxs-lookup"><span data-stu-id="76d88-215">Reducing the size of the response usually increases the responsiveness of an app, often dramatically.</span></span> <span data-ttu-id="76d88-216">Uma maneira de reduzir o tamanho da carga é comprimir as respostas de um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="76d88-216">One way to reduce payload sizes is to compress an app's responses.</span></span> <span data-ttu-id="76d88-217">Para obter mais informações, consulte [compressão de resposta](xref:performance/response-compression).</span><span class="sxs-lookup"><span data-stu-id="76d88-217">For more information, see [Response compression](xref:performance/response-compression).</span></span>

## <a name="use-the-latest-aspnet-core-release"></a><span data-ttu-id="76d88-218">Use a versão mais recente do ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="76d88-218">Use the latest ASP.NET Core release</span></span>

<span data-ttu-id="76d88-219">Cada nova versão do ASP.NET Core inclui melhorias de desempenho.</span><span class="sxs-lookup"><span data-stu-id="76d88-219">Each new release of ASP.NET Core includes performance improvements.</span></span> <span data-ttu-id="76d88-220">Otimizações no .NET Core e ASP.NET Core significam que as versões mais recentes geralmente superam as versões mais antigas.</span><span class="sxs-lookup"><span data-stu-id="76d88-220">Optimizations in .NET Core and ASP.NET Core mean that newer versions generally outperform older versions.</span></span> <span data-ttu-id="76d88-221">Por exemplo, o .NET Core 2.1 adicionou suporte para expressões regulares compiladas e se beneficiou do [Span\<T>](https://msdn.microsoft.com/magazine/mt814808.aspx).</span><span class="sxs-lookup"><span data-stu-id="76d88-221">For example, .NET Core 2.1 added support for compiled regular expressions and benefitted from [Span\<T>](https://msdn.microsoft.com/magazine/mt814808.aspx).</span></span> <span data-ttu-id="76d88-222">ASP.NET Core 2.2 adicionou suporte para HTTP/2.</span><span class="sxs-lookup"><span data-stu-id="76d88-222">ASP.NET Core 2.2 added support for HTTP/2.</span></span> <span data-ttu-id="76d88-223">[ASP.NET Core 3.0 adiciona muitas melhorias](xref:aspnetcore-3.0) que reduzem o uso da memória e melhoram o throughput.</span><span class="sxs-lookup"><span data-stu-id="76d88-223">[ASP.NET Core 3.0 adds many improvements](xref:aspnetcore-3.0) that reduce memory usage and improve throughput.</span></span> <span data-ttu-id="76d88-224">Se o desempenho for uma prioridade, considere atualizar para a versão atual do ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="76d88-224">If performance is a priority, consider upgrading to the current version of ASP.NET Core.</span></span>

## <a name="minimize-exceptions"></a><span data-ttu-id="76d88-225">Minimizar exceções</span><span class="sxs-lookup"><span data-stu-id="76d88-225">Minimize exceptions</span></span>

<span data-ttu-id="76d88-226">Exceções devem ser raras.</span><span class="sxs-lookup"><span data-stu-id="76d88-226">Exceptions should be rare.</span></span> <span data-ttu-id="76d88-227">Lançar e capturar exceções é lento em relação a outros padrões de fluxo de código.</span><span class="sxs-lookup"><span data-stu-id="76d88-227">Throwing and catching exceptions is slow relative to other code flow patterns.</span></span> <span data-ttu-id="76d88-228">Por causa disso, exceções não devem ser usadas para controlar o fluxo normal do programa.</span><span class="sxs-lookup"><span data-stu-id="76d88-228">Because of this, exceptions shouldn't be used to control normal program flow.</span></span>

<span data-ttu-id="76d88-229">Recomendações:</span><span class="sxs-lookup"><span data-stu-id="76d88-229">Recommendations:</span></span>

* <span data-ttu-id="76d88-230">**Não** use o arremesso ou a captura de exceções como um meio de fluxo normal do programa, especialmente em [caminhos de código quente](#understand-hot-code-paths).</span><span class="sxs-lookup"><span data-stu-id="76d88-230">**Do not** use throwing or catching exceptions as a means of normal program flow, especially in [hot code paths](#understand-hot-code-paths).</span></span>
* <span data-ttu-id="76d88-231">**Inclua** a lógica no aplicativo para detectar e lidar com condições que causariam uma exceção.</span><span class="sxs-lookup"><span data-stu-id="76d88-231">**Do** include logic in the app to detect and handle conditions that would cause an exception.</span></span>
* <span data-ttu-id="76d88-232">**Faça** exceções de arremesso ou captura para condições incomuns ou inesperadas.</span><span class="sxs-lookup"><span data-stu-id="76d88-232">**Do** throw or catch exceptions for unusual or unexpected conditions.</span></span>

<span data-ttu-id="76d88-233">Ferramentas de diagnóstico de aplicativos, como o Application Insights, podem ajudar a identificar exceções comuns em um aplicativo que podem afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="76d88-233">App diagnostic tools, such as Application Insights, can help to identify common exceptions in an app that may affect performance.</span></span>

## <a name="performance-and-reliability"></a><span data-ttu-id="76d88-234">Desempenho e confiabilidade</span><span class="sxs-lookup"><span data-stu-id="76d88-234">Performance and reliability</span></span>

<span data-ttu-id="76d88-235">As seções a seguir fornecem dicas de desempenho e problemas e soluções de confiabilidade conhecidos.</span><span class="sxs-lookup"><span data-stu-id="76d88-235">The following sections provide performance tips and known reliability problems and solutions.</span></span>

## <a name="avoid-synchronous-read-or-write-on-httprequesthttpresponse-body"></a><span data-ttu-id="76d88-236">Evite leitura síncrona ou gravação no corpo HttpRequest/HttpResponse</span><span class="sxs-lookup"><span data-stu-id="76d88-236">Avoid synchronous read or write on HttpRequest/HttpResponse body</span></span>

<span data-ttu-id="76d88-237">Tudo o que há de I/O no ASP.NET Core é assíncrono.</span><span class="sxs-lookup"><span data-stu-id="76d88-237">All I/O in ASP.NET Core is asynchronous.</span></span> <span data-ttu-id="76d88-238">Os servidores `Stream` implementam a interface, que tem sobrecargas síncronas e assíncronas.</span><span class="sxs-lookup"><span data-stu-id="76d88-238">Servers implement the `Stream` interface, which has both synchronous and asynchronous overloads.</span></span> <span data-ttu-id="76d88-239">Os assíncronos devem ser preferidos para evitar o bloqueio de roscas de rosca.</span><span class="sxs-lookup"><span data-stu-id="76d88-239">The asynchronous ones should be preferred to avoid blocking thread pool threads.</span></span> <span data-ttu-id="76d88-240">O bloqueio de roscas pode levar à fome da piscina de fios.</span><span class="sxs-lookup"><span data-stu-id="76d88-240">Blocking threads can lead to thread pool starvation.</span></span>

<span data-ttu-id="76d88-241">**Não faça isso:** O exemplo a <xref:System.IO.StreamReader.ReadToEnd*>seguir usa o .</span><span class="sxs-lookup"><span data-stu-id="76d88-241">**Do not do this:** The following example uses the <xref:System.IO.StreamReader.ReadToEnd*>.</span></span> <span data-ttu-id="76d88-242">Bloqueia o fio atual para esperar pelo resultado.</span><span class="sxs-lookup"><span data-stu-id="76d88-242">It blocks the current thread to wait for the result.</span></span> <span data-ttu-id="76d88-243">Este é um exemplo de [sincronização sobre assincronização](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
).</span><span class="sxs-lookup"><span data-stu-id="76d88-243">This is an example of [sync over async](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
).</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet1)]

<span data-ttu-id="76d88-244">No código anterior, `Get` lê sincronizadamente todo o corpo de solicitação HTTP na memória.</span><span class="sxs-lookup"><span data-stu-id="76d88-244">In the preceding code, `Get` synchronously reads the entire HTTP request body into memory.</span></span> <span data-ttu-id="76d88-245">Se o cliente estiver fazendo upload lento, o aplicativo está fazendo sincronização sobre a sincronia.</span><span class="sxs-lookup"><span data-stu-id="76d88-245">If the client is slowly uploading, the app is doing sync over async.</span></span> <span data-ttu-id="76d88-246">O aplicativo faz sincronia sobre assincronização porque kestrel **NÃO** suporta leituras síncronas.</span><span class="sxs-lookup"><span data-stu-id="76d88-246">The app does sync over async because Kestrel does **NOT** support synchronous reads.</span></span>

<span data-ttu-id="76d88-247">**Faça isso:** O exemplo <xref:System.IO.StreamReader.ReadToEndAsync*> a seguir usa e não bloqueia o fio durante a leitura.</span><span class="sxs-lookup"><span data-stu-id="76d88-247">**Do this:** The following example uses <xref:System.IO.StreamReader.ReadToEndAsync*> and does not block the thread while reading.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet2)]

<span data-ttu-id="76d88-248">O código anterior lê assíncronamente todo o corpo de solicitação HTTP na memória.</span><span class="sxs-lookup"><span data-stu-id="76d88-248">The preceding code asynchronously reads the entire HTTP request body into memory.</span></span>

> [!WARNING]
> <span data-ttu-id="76d88-249">Se a solicitação for grande, ler todo o corpo de solicitação HTTP na memória pode levar a uma condição fora da memória (OOM).</span><span class="sxs-lookup"><span data-stu-id="76d88-249">If the request is large, reading the entire HTTP request body into memory could lead to an out of memory (OOM) condition.</span></span> <span data-ttu-id="76d88-250">OOM pode resultar em uma negação de serviço.</span><span class="sxs-lookup"><span data-stu-id="76d88-250">OOM can result in a Denial Of Service.</span></span>  <span data-ttu-id="76d88-251">Para obter mais informações, consulte [Evite ler grandes corpos de solicitação ou corpos de resposta](#arlb) na memória neste documento.</span><span class="sxs-lookup"><span data-stu-id="76d88-251">For more information, see [Avoid reading large request bodies or response bodies into memory](#arlb) in this document.</span></span>

<span data-ttu-id="76d88-252">**Faça isso:** O exemplo a seguir é totalmente assíncrono usando um órgão de solicitação não tamponado:</span><span class="sxs-lookup"><span data-stu-id="76d88-252">**Do this:** The following example is fully asynchronous using a non buffered request body:</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MyFirstController.cs?name=snippet3)]

<span data-ttu-id="76d88-253">O código anterior desserializa assíncronamente o corpo de solicitação em um objeto C#.</span><span class="sxs-lookup"><span data-stu-id="76d88-253">The preceding code asynchronously de-serializes the request body into a C# object.</span></span>

## <a name="prefer-readformasync-over-requestform"></a><span data-ttu-id="76d88-254">Prefira ReadFormAsync ao solicitar.formulário</span><span class="sxs-lookup"><span data-stu-id="76d88-254">Prefer ReadFormAsync over Request.Form</span></span>

<span data-ttu-id="76d88-255">Use `HttpContext.Request.ReadFormAsync` em vez de `HttpContext.Request.Form`.</span><span class="sxs-lookup"><span data-stu-id="76d88-255">Use `HttpContext.Request.ReadFormAsync` instead of `HttpContext.Request.Form`.</span></span>
<span data-ttu-id="76d88-256">`HttpContext.Request.Form`pode ser lido com segurança apenas com as seguintes condições:</span><span class="sxs-lookup"><span data-stu-id="76d88-256">`HttpContext.Request.Form` can be safely read only with the following conditions:</span></span>

* <span data-ttu-id="76d88-257">O formulário foi lido por `ReadFormAsync`uma chamada para , e</span><span class="sxs-lookup"><span data-stu-id="76d88-257">The form has been read by a call to `ReadFormAsync`, and</span></span>
* <span data-ttu-id="76d88-258">O valor do formulário armazenado em cache está sendo lido usando`HttpContext.Request.Form`</span><span class="sxs-lookup"><span data-stu-id="76d88-258">The cached form value is being read using `HttpContext.Request.Form`</span></span>

<span data-ttu-id="76d88-259">**Não faça isso:** O exemplo `HttpContext.Request.Form`a seguir usa .</span><span class="sxs-lookup"><span data-stu-id="76d88-259">**Do not do this:** The following example uses `HttpContext.Request.Form`.</span></span>  <span data-ttu-id="76d88-260">`HttpContext.Request.Form`usa [sincronização sobre assincronização](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
) e pode levar à fome de pool de segmentos.</span><span class="sxs-lookup"><span data-stu-id="76d88-260">`HttpContext.Request.Form` uses [sync over async](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#warning-sync-over-async
) and can lead to thread pool starvation.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MySecondController.cs?name=snippet1)]

<span data-ttu-id="76d88-261">**Faça isso:** O exemplo `HttpContext.Request.ReadFormAsync` a seguir é usa para ler o corpo do formulário assíncronamente.</span><span class="sxs-lookup"><span data-stu-id="76d88-261">**Do this:** The following example uses `HttpContext.Request.ReadFormAsync` to read the form body asynchronously.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/MySecondController.cs?name=snippet2)]

<a name="arlb"></a>

## <a name="avoid-reading-large-request-bodies-or-response-bodies-into-memory"></a><span data-ttu-id="76d88-262">Evite ler grandes corpos de solicitação ou corpos de resposta na memória</span><span class="sxs-lookup"><span data-stu-id="76d88-262">Avoid reading large request bodies or response bodies into memory</span></span>

<span data-ttu-id="76d88-263">Em .NET, cada alocação de objeto superior a 85 KB acaba no heap de objeto grande[(LOH).](https://blogs.msdn.microsoft.com/maoni/2006/04/19/large-object-heap/)</span><span class="sxs-lookup"><span data-stu-id="76d88-263">In .NET, every object allocation greater than 85 KB ends up in the large object heap ([LOH](https://blogs.msdn.microsoft.com/maoni/2006/04/19/large-object-heap/)).</span></span> <span data-ttu-id="76d88-264">Objetos grandes são caros de duas maneiras:</span><span class="sxs-lookup"><span data-stu-id="76d88-264">Large objects are expensive in two ways:</span></span>

* <span data-ttu-id="76d88-265">O custo de alocação é alto porque a memória de um objeto grande recém-alocado tem que ser limpa.</span><span class="sxs-lookup"><span data-stu-id="76d88-265">The allocation cost is high because the memory for a newly allocated large object has to be cleared.</span></span> <span data-ttu-id="76d88-266">O CLR garante que a memória para todos os objetos recém-alocados seja limpa.</span><span class="sxs-lookup"><span data-stu-id="76d88-266">The CLR guarantees that memory for all newly allocated objects is cleared.</span></span>
* <span data-ttu-id="76d88-267">LOH é coletado com o resto do monte.</span><span class="sxs-lookup"><span data-stu-id="76d88-267">LOH is collected with the rest of the heap.</span></span> <span data-ttu-id="76d88-268">Loh requer uma coleta completa [de lixo](/dotnet/standard/garbage-collection/fundamentals) ou [coleta Gen2](/dotnet/standard/garbage-collection/fundamentals#generations).</span><span class="sxs-lookup"><span data-stu-id="76d88-268">LOH requires a full [garbage collection](/dotnet/standard/garbage-collection/fundamentals) or [Gen2 collection](/dotnet/standard/garbage-collection/fundamentals#generations).</span></span>

<span data-ttu-id="76d88-269">Este [post descreve](https://adamsitnik.com/Array-Pool/#the-problem) o problema de forma sucinta:</span><span class="sxs-lookup"><span data-stu-id="76d88-269">This [blog post](https://adamsitnik.com/Array-Pool/#the-problem) describes the problem succinctly:</span></span>

> <span data-ttu-id="76d88-270">Quando um objeto grande é alocado, ele é marcado como objeto Gen 2.</span><span class="sxs-lookup"><span data-stu-id="76d88-270">When a large object is allocated, it's marked as Gen 2 object.</span></span> <span data-ttu-id="76d88-271">Não gen 0 como para objetos pequenos.</span><span class="sxs-lookup"><span data-stu-id="76d88-271">Not Gen 0 as for small objects.</span></span> <span data-ttu-id="76d88-272">As conseqüências são que se você ficar sem memória em LOH, GC limpa todo o monte gerenciado, não apenas LOH.</span><span class="sxs-lookup"><span data-stu-id="76d88-272">The consequences are that if you run out of memory in LOH, GC cleans up the whole managed heap, not only LOH.</span></span> <span data-ttu-id="76d88-273">Então limpa gen 0, Gen 1 e Gen 2, incluindo LOH.</span><span class="sxs-lookup"><span data-stu-id="76d88-273">So it cleans up Gen 0, Gen 1 and Gen 2 including LOH.</span></span> <span data-ttu-id="76d88-274">Isso é chamado de coleta completa de lixo e é a coleta de lixo mais demorada.</span><span class="sxs-lookup"><span data-stu-id="76d88-274">This is called full garbage collection and is the most time-consuming garbage collection.</span></span> <span data-ttu-id="76d88-275">Para muitas aplicações, pode ser aceitável.</span><span class="sxs-lookup"><span data-stu-id="76d88-275">For many applications, it can be acceptable.</span></span> <span data-ttu-id="76d88-276">Mas definitivamente não para servidores web de alto desempenho, onde poucos buffers de memória grandes são necessários para lidar com uma solicitação média da Web (leia de um soquete, descompactação, decodificar json & mais).</span><span class="sxs-lookup"><span data-stu-id="76d88-276">But definitely not for high-performance web servers, where few big memory buffers are needed to handle an average web request (read from a socket, decompress, decode JSON & more).</span></span>

<span data-ttu-id="76d88-277">Ingenuamente armazenando um grande pedido `byte[]` ou `string`corpo de resposta em um único ou:</span><span class="sxs-lookup"><span data-stu-id="76d88-277">Naively storing a large request or response body into a single `byte[]` or `string`:</span></span>

* <span data-ttu-id="76d88-278">Pode resultar em ficar sem espaço rapidamente no LOH.</span><span class="sxs-lookup"><span data-stu-id="76d88-278">May result in quickly running out of space in the LOH.</span></span>
* <span data-ttu-id="76d88-279">Pode causar problemas de desempenho para o aplicativo por causa da execução de GCs completos.</span><span class="sxs-lookup"><span data-stu-id="76d88-279">May cause performance issues for the app because of full GCs running.</span></span>

## <a name="working-with-a-synchronous-data-processing-api"></a><span data-ttu-id="76d88-280">Trabalhando com uma API de processamento de dados síncrono</span><span class="sxs-lookup"><span data-stu-id="76d88-280">Working with a synchronous data processing API</span></span>

<span data-ttu-id="76d88-281">Ao usar um serializador/desserializador que só suporta leituras e gravações síncronas (por exemplo, [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm)):</span><span class="sxs-lookup"><span data-stu-id="76d88-281">When using a serializer/de-serializer that only supports synchronous reads and writes (for example,  [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm)):</span></span>

* <span data-ttu-id="76d88-282">Tampone os dados na memória de forma assíncrona antes de passá-los para o serializador/desserializador.</span><span class="sxs-lookup"><span data-stu-id="76d88-282">Buffer the data into memory asynchronously before passing it into the serializer/de-serializer.</span></span>

> [!WARNING]
> <span data-ttu-id="76d88-283">Se a solicitação for grande, pode levar a uma condição fora da memória (OOM).</span><span class="sxs-lookup"><span data-stu-id="76d88-283">If the request is large, it could lead to an out of memory (OOM) condition.</span></span> <span data-ttu-id="76d88-284">OOM pode resultar em uma negação de serviço.</span><span class="sxs-lookup"><span data-stu-id="76d88-284">OOM can result in a Denial Of Service.</span></span>  <span data-ttu-id="76d88-285">Para obter mais informações, consulte [Evite ler grandes corpos de solicitação ou corpos de resposta](#arlb) na memória neste documento.</span><span class="sxs-lookup"><span data-stu-id="76d88-285">For more information, see [Avoid reading large request bodies or response bodies into memory](#arlb) in this document.</span></span>

<span data-ttu-id="76d88-286">ASP.NET Core 3.0 usa <xref:System.Text.Json> por padrão para serialização JSON.</span><span class="sxs-lookup"><span data-stu-id="76d88-286">ASP.NET Core 3.0 uses <xref:System.Text.Json> by default for JSON serialization.</span></span> <span data-ttu-id="76d88-287"><xref:System.Text.Json>:</span><span class="sxs-lookup"><span data-stu-id="76d88-287"><xref:System.Text.Json>:</span></span>

* <span data-ttu-id="76d88-288">Lê e escreve JSON assíncronamente.</span><span class="sxs-lookup"><span data-stu-id="76d88-288">Reads and writes JSON asynchronously.</span></span>
* <span data-ttu-id="76d88-289">É otimizado para texto UTF-8.</span><span class="sxs-lookup"><span data-stu-id="76d88-289">Is optimized for UTF-8 text.</span></span>
* <span data-ttu-id="76d88-290">Tipicamente desempenho `Newtonsoft.Json`superior a .</span><span class="sxs-lookup"><span data-stu-id="76d88-290">Typically higher performance than `Newtonsoft.Json`.</span></span>

## <a name="do-not-store-ihttpcontextaccessorhttpcontext-in-a-field"></a><span data-ttu-id="76d88-291">Não armazene IHttpContext.HttpContext em um campo</span><span class="sxs-lookup"><span data-stu-id="76d88-291">Do not store IHttpContextAccessor.HttpContext in a field</span></span>

<span data-ttu-id="76d88-292">O [IHttpContextAccessor.HttpContext](xref:Microsoft.AspNetCore.Http.IHttpContextAccessor.HttpContext) `HttpContext` retorna a solicitação ativa quando acessada a partir do segmento de solicitação.</span><span class="sxs-lookup"><span data-stu-id="76d88-292">The [IHttpContextAccessor.HttpContext](xref:Microsoft.AspNetCore.Http.IHttpContextAccessor.HttpContext) returns the `HttpContext` of the active request when accessed from the request thread.</span></span> <span data-ttu-id="76d88-293">O `IHttpContextAccessor.HttpContext` **não** deve ser armazenado em um campo ou variável.</span><span class="sxs-lookup"><span data-stu-id="76d88-293">The `IHttpContextAccessor.HttpContext` should **not** be stored in a field or variable.</span></span>

<span data-ttu-id="76d88-294">**Não faça isso:** O exemplo a `HttpContext` seguir armazena o em um campo e, em seguida, tenta usá-lo mais tarde.</span><span class="sxs-lookup"><span data-stu-id="76d88-294">**Do not do this:** The following example stores the `HttpContext` in a field and then attempts to use it later.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/MyType.cs?name=snippet1)]

<span data-ttu-id="76d88-295">O código anterior captura frequentemente um `HttpContext` nulo ou incorreto no construtor.</span><span class="sxs-lookup"><span data-stu-id="76d88-295">The preceding code frequently captures a null or incorrect `HttpContext` in the constructor.</span></span>

<span data-ttu-id="76d88-296">**Faça isso:** O seguinte exemplo:</span><span class="sxs-lookup"><span data-stu-id="76d88-296">**Do this:** The following example:</span></span>

* <span data-ttu-id="76d88-297">Armazena <xref:Microsoft.AspNetCore.Http.IHttpContextAccessor> o em um campo.</span><span class="sxs-lookup"><span data-stu-id="76d88-297">Stores the <xref:Microsoft.AspNetCore.Http.IHttpContextAccessor> in a field.</span></span>
* <span data-ttu-id="76d88-298">Usa `HttpContext` o campo na hora `null`correta e verifica se .</span><span class="sxs-lookup"><span data-stu-id="76d88-298">Uses the `HttpContext` field at the correct time and checks for `null`.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/MyType.cs?name=snippet2)]

## <a name="do-not-access-httpcontext-from-multiple-threads"></a><span data-ttu-id="76d88-299">Não acesse httpcontext a partir de vários threads</span><span class="sxs-lookup"><span data-stu-id="76d88-299">Do not access HttpContext from multiple threads</span></span>

<span data-ttu-id="76d88-300">`HttpContext`*NÃO* é seguro para rosca.</span><span class="sxs-lookup"><span data-stu-id="76d88-300">`HttpContext` is *NOT* thread-safe.</span></span> <span data-ttu-id="76d88-301">O `HttpContext` acesso a partir de vários threads em paralelo pode resultar em comportamentos indefinidos, como travamentos, travas e corrupção de dados.</span><span class="sxs-lookup"><span data-stu-id="76d88-301">Accessing `HttpContext` from multiple threads in parallel can result in undefined behavior such as hangs, crashes, and data corruption.</span></span>

<span data-ttu-id="76d88-302">**Não faça isso:** O exemplo a seguir faz três solicitações paralelas e registra o caminho de solicitação de entrada antes e depois da solicitação HTTP de saída.</span><span class="sxs-lookup"><span data-stu-id="76d88-302">**Do not do this:** The following example makes three parallel requests and logs the incoming request path before and after the outgoing HTTP request.</span></span> <span data-ttu-id="76d88-303">O caminho de solicitação é acessado a partir de vários segmentos, potencialmente em paralelo.</span><span class="sxs-lookup"><span data-stu-id="76d88-303">The request path is accessed from multiple threads, potentially in parallel.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncFirstController.cs?name=snippet1&highlight=25,28)]

<span data-ttu-id="76d88-304">**Faça isso:** O exemplo a seguir copia todos os dados da solicitação recebida antes de fazer as três solicitações paralelas.</span><span class="sxs-lookup"><span data-stu-id="76d88-304">**Do this:** The following example copies all data from the incoming request before making the three parallel requests.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncFirstController.cs?name=snippet2&highlight=6,8,22,28)]

## <a name="do-not-use-the-httpcontext-after-the-request-is-complete"></a><span data-ttu-id="76d88-305">Não use o HttpContext após a solicitação ser concluída</span><span class="sxs-lookup"><span data-stu-id="76d88-305">Do not use the HttpContext after the request is complete</span></span>

<span data-ttu-id="76d88-306">`HttpContext`só é válido enquanto houver uma solicitação HTTP ativa no pipeline ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="76d88-306">`HttpContext` is only valid as long as there is an active HTTP request in the ASP.NET Core pipeline.</span></span> <span data-ttu-id="76d88-307">Todo o ASP.NET Core pipeline é uma cadeia assíncrona de delegados que executa cada solicitação.</span><span class="sxs-lookup"><span data-stu-id="76d88-307">The entire ASP.NET Core pipeline is an asynchronous chain of delegates that executes every request.</span></span> <span data-ttu-id="76d88-308">Quando `Task` o retorno desta cadeia é `HttpContext` concluído, o é reciclado.</span><span class="sxs-lookup"><span data-stu-id="76d88-308">When the `Task` returned from this chain completes, the `HttpContext` is recycled.</span></span>

<span data-ttu-id="76d88-309">**Não faça isso:** O exemplo `async void` a seguir usa que faz `await` com que a solicitação HTTP seja concluída quando a primeira é atingida:</span><span class="sxs-lookup"><span data-stu-id="76d88-309">**Do not do this:** The following example uses `async void` which makes the HTTP request complete when the first `await` is reached:</span></span>

* <span data-ttu-id="76d88-310">O que **é sempre** uma má prática em ASP.NET aplicativos Core.</span><span class="sxs-lookup"><span data-stu-id="76d88-310">Which is **ALWAYS** a bad practice in ASP.NET Core apps.</span></span>
* <span data-ttu-id="76d88-311">Acessa `HttpResponse` o após a solicitação HTTP ser concluída.</span><span class="sxs-lookup"><span data-stu-id="76d88-311">Accesses the `HttpResponse` after the HTTP request is complete.</span></span>
* <span data-ttu-id="76d88-312">Trava o processo.</span><span class="sxs-lookup"><span data-stu-id="76d88-312">Crashes the process.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncBadVoidController.cs?name=snippet1)]

<span data-ttu-id="76d88-313">**Faça isso:** O exemplo a `Task` seguir retorna a para a estrutura, de modo que a solicitação HTTP não é concluída até que a ação seja concluída.</span><span class="sxs-lookup"><span data-stu-id="76d88-313">**Do this:** The following example returns a `Task` to the framework, so the HTTP request doesn't complete until the action completes.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/AsyncSecondController.cs?name=snippet1)]

## <a name="do-not-capture-the-httpcontext-in-background-threads"></a><span data-ttu-id="76d88-314">Não capture o HttpContext em segmentos de fundo</span><span class="sxs-lookup"><span data-stu-id="76d88-314">Do not capture the HttpContext in background threads</span></span>

<span data-ttu-id="76d88-315">**Não faça isso:** O exemplo a seguir mostra `HttpContext` que `Controller` um fechamento é capturar a propriedade.</span><span class="sxs-lookup"><span data-stu-id="76d88-315">**Do not do this:** The following example shows a closure is capturing the `HttpContext` from the `Controller` property.</span></span> <span data-ttu-id="76d88-316">Esta é uma má prática porque o item de trabalho poderia:</span><span class="sxs-lookup"><span data-stu-id="76d88-316">This is a bad practice because the work item could:</span></span>

* <span data-ttu-id="76d88-317">Corra para fora do escopo de solicitação.</span><span class="sxs-lookup"><span data-stu-id="76d88-317">Run outside of the request scope.</span></span>
* <span data-ttu-id="76d88-318">Tente ler `HttpContext`errado.</span><span class="sxs-lookup"><span data-stu-id="76d88-318">Attempt to read the wrong `HttpContext`.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetFirstController.cs?name=snippet1)]

<span data-ttu-id="76d88-319">**Faça isso:** O seguinte exemplo:</span><span class="sxs-lookup"><span data-stu-id="76d88-319">**Do this:** The following example:</span></span>

* <span data-ttu-id="76d88-320">Copia os dados necessários na tarefa de fundo durante a solicitação.</span><span class="sxs-lookup"><span data-stu-id="76d88-320">Copies the data required in the background task during the request.</span></span>
* <span data-ttu-id="76d88-321">Não faz referência a nada do controlador.</span><span class="sxs-lookup"><span data-stu-id="76d88-321">Doesn't reference anything from the controller.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetFirstController.cs?name=snippet2)]

<span data-ttu-id="76d88-322">As tarefas de fundo devem ser implementadas como serviços hospedados.</span><span class="sxs-lookup"><span data-stu-id="76d88-322">Background tasks should be implemented as hosted services.</span></span> <span data-ttu-id="76d88-323">Saiba mais em [Tarefas em segundo plano com serviços hospedados](xref:fundamentals/host/hosted-services).</span><span class="sxs-lookup"><span data-stu-id="76d88-323">For more information, see [Background tasks with hosted services](xref:fundamentals/host/hosted-services).</span></span>

## <a name="do-not-capture-services-injected-into-the-controllers-on-background-threads"></a><span data-ttu-id="76d88-324">Não capture serviços injetados nos controladores em segmentos de fundo</span><span class="sxs-lookup"><span data-stu-id="76d88-324">Do not capture services injected into the controllers on background threads</span></span>

<span data-ttu-id="76d88-325">**Não faça isso:** O exemplo a seguir mostra `DbContext` que `Controller` um encerramento é capturar o parâmetro de ação.</span><span class="sxs-lookup"><span data-stu-id="76d88-325">**Do not do this:** The following example shows a closure is capturing the `DbContext` from the `Controller` action parameter.</span></span> <span data-ttu-id="76d88-326">Isso é uma má prática.</span><span class="sxs-lookup"><span data-stu-id="76d88-326">This is a bad practice.</span></span>  <span data-ttu-id="76d88-327">O item de trabalho pode ser executado fora do escopo de solicitação.</span><span class="sxs-lookup"><span data-stu-id="76d88-327">The work item could run outside of the request scope.</span></span> <span data-ttu-id="76d88-328">O `ContosoDbContext` é escopo para a solicitação, `ObjectDisposedException`resultando em um .</span><span class="sxs-lookup"><span data-stu-id="76d88-328">The `ContosoDbContext` is scoped to the request, resulting in an `ObjectDisposedException`.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet1)]

<span data-ttu-id="76d88-329">**Faça isso:** O seguinte exemplo:</span><span class="sxs-lookup"><span data-stu-id="76d88-329">**Do this:** The following example:</span></span>

* <span data-ttu-id="76d88-330">Injeta um <xref:Microsoft.Extensions.DependencyInjection.IServiceScopeFactory> para criar um escopo no item de trabalho de fundo.</span><span class="sxs-lookup"><span data-stu-id="76d88-330">Injects an <xref:Microsoft.Extensions.DependencyInjection.IServiceScopeFactory> in order to create a scope in the background work item.</span></span> <span data-ttu-id="76d88-331">`IServiceScopeFactory`é um singleton.</span><span class="sxs-lookup"><span data-stu-id="76d88-331">`IServiceScopeFactory` is a singleton.</span></span>
* <span data-ttu-id="76d88-332">Cria um novo escopo de injeção de dependência no segmento de fundo.</span><span class="sxs-lookup"><span data-stu-id="76d88-332">Creates a new dependency injection scope in the background thread.</span></span>
* <span data-ttu-id="76d88-333">Não faz referência a nada do controlador.</span><span class="sxs-lookup"><span data-stu-id="76d88-333">Doesn't reference anything from the controller.</span></span>
* <span data-ttu-id="76d88-334">Não captura o `ContosoDbContext` pedido de entrada.</span><span class="sxs-lookup"><span data-stu-id="76d88-334">Doesn't capture the `ContosoDbContext` from the incoming request.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet2)]

<span data-ttu-id="76d88-335">O seguinte código destacado:</span><span class="sxs-lookup"><span data-stu-id="76d88-335">The following highlighted code:</span></span>

* <span data-ttu-id="76d88-336">Cria um escopo para a vida útil da operação de fundo e resolve os serviços a partir dela.</span><span class="sxs-lookup"><span data-stu-id="76d88-336">Creates a scope for the lifetime of the background operation and resolves services from it.</span></span>
* <span data-ttu-id="76d88-337">Usa `ContosoDbContext` do escopo correto.</span><span class="sxs-lookup"><span data-stu-id="76d88-337">Uses `ContosoDbContext` from the correct scope.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Controllers/FireAndForgetSecondController.cs?name=snippet2&highlight=9-16)]

## <a name="do-not-modify-the-status-code-or-headers-after-the-response-body-has-started"></a><span data-ttu-id="76d88-338">Não modifique o código de status ou os cabeçalhos depois que o corpo de resposta tiver iniciado</span><span class="sxs-lookup"><span data-stu-id="76d88-338">Do not modify the status code or headers after the response body has started</span></span>

<span data-ttu-id="76d88-339">ASP.NET Core não tampona o corpo de resposta HTTP.</span><span class="sxs-lookup"><span data-stu-id="76d88-339">ASP.NET Core does not buffer the HTTP response body.</span></span> <span data-ttu-id="76d88-340">A primeira vez que a resposta é escrita:</span><span class="sxs-lookup"><span data-stu-id="76d88-340">The first time the response is written:</span></span>

* <span data-ttu-id="76d88-341">Os cabeçalhos são enviados junto com esse pedaço do corpo para o cliente.</span><span class="sxs-lookup"><span data-stu-id="76d88-341">The headers are sent along with that chunk of the body to the client.</span></span>
* <span data-ttu-id="76d88-342">Não é mais possível mudar os cabeçalhos de resposta.</span><span class="sxs-lookup"><span data-stu-id="76d88-342">It's no longer possible to change response headers.</span></span>

<span data-ttu-id="76d88-343">**Não faça isso:** O código a seguir tenta adicionar cabeçalhos de resposta depois que a resposta já foi iniciada:</span><span class="sxs-lookup"><span data-stu-id="76d88-343">**Do not do this:** The following code tries to add response headers after the response has already started:</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet1)]

<span data-ttu-id="76d88-344">No código anterior, `context.Response.Headers["test"] = "test value";` lançará `next()` uma exceção se tiver escrito para a resposta.</span><span class="sxs-lookup"><span data-stu-id="76d88-344">In the preceding code, `context.Response.Headers["test"] = "test value";` will throw an exception if `next()` has written to the response.</span></span>

<span data-ttu-id="76d88-345">**Faça isso:** O exemplo a seguir verifica se a resposta HTTP foi iniciada antes de modificar os cabeçalhos.</span><span class="sxs-lookup"><span data-stu-id="76d88-345">**Do this:** The following example checks if the HTTP response has started before modifying the headers.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet2)]

<span data-ttu-id="76d88-346">**Faça isso:** O exemplo `HttpResponse.OnStarting` a seguir é usa para definir os cabeçalhos antes que os cabeçalhos de resposta sejam liberados para o cliente.</span><span class="sxs-lookup"><span data-stu-id="76d88-346">**Do this:** The following example uses `HttpResponse.OnStarting` to set the headers before the response headers are flushed to the client.</span></span>

<span data-ttu-id="76d88-347">Verificar se a resposta não foi iniciada permite registrar um retorno de chamada que será invocado pouco antes dos cabeçalhos de resposta serem escritos.</span><span class="sxs-lookup"><span data-stu-id="76d88-347">Checking if the response has not started allows registering a callback that will be invoked just before response headers are written.</span></span> <span data-ttu-id="76d88-348">Verificando se a resposta não foi iniciada:</span><span class="sxs-lookup"><span data-stu-id="76d88-348">Checking if the response has not started:</span></span>

* <span data-ttu-id="76d88-349">Fornece a capacidade de anexar ou substituir cabeçalhos bem a tempo.</span><span class="sxs-lookup"><span data-stu-id="76d88-349">Provides the ability to append or override headers just in time.</span></span>
* <span data-ttu-id="76d88-350">Não requer conhecimento do próximo middleware no oleoduto.</span><span class="sxs-lookup"><span data-stu-id="76d88-350">Doesn't require knowledge of the next middleware in the pipeline.</span></span>

[!code-csharp[](performance-best-practices/samples/3.0/Startup22.cs?name=snippet3)]

## <a name="do-not-call-next-if-you-have-already-started-writing-to-the-response-body"></a><span data-ttu-id="76d88-351">Não ligue para o próximo() se você já começou a escrever para o corpo de resposta</span><span class="sxs-lookup"><span data-stu-id="76d88-351">Do not call next() if you have already started writing to the response body</span></span>

<span data-ttu-id="76d88-352">Os componentes só esperam ser chamados se for possível manuseá-los e manipular a resposta.</span><span class="sxs-lookup"><span data-stu-id="76d88-352">Components only expect to be called if it's possible for them to handle and manipulate the response.</span></span>
