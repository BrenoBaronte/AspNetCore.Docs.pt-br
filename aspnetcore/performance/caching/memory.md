---
title: Cache na memória no ASP.NET Core
author: rick-anderson
description: Saiba como armazenar dados em cache na memória no ASP.NET Core.
ms.author: riande
ms.custom: mvc
ms.date: 02/02/2020
no-loc:
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: performance/caching/memory
ms.openlocfilehash: 8eec361efbc3c7dca6c0bef65b6f6b40b3b46798
ms.sourcegitcommit: d65a027e78bf0b83727f975235a18863e685d902
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 06/26/2020
ms.locfileid: "85404607"
---
# <a name="cache-in-memory-in-aspnet-core"></a><span data-ttu-id="aee2e-103">Cache na memória no ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="aee2e-103">Cache in-memory in ASP.NET Core</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="aee2e-104">Por [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo)e [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="aee2e-104">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="aee2e-105">[Exibir ou baixar código de exemplo](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([como baixar](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="aee2e-105">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="aee2e-106">Noções básicas de cache</span><span class="sxs-lookup"><span data-stu-id="aee2e-106">Caching basics</span></span>

<span data-ttu-id="aee2e-107">O Caching pode melhorar significativamente o desempenho e a escalabilidade de um aplicativo, reduzindo o trabalho necessário para gerar conteúdo.</span><span class="sxs-lookup"><span data-stu-id="aee2e-107">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="aee2e-108">O Caching funciona melhor com dados que são alterados com pouca frequência **e** é caro de gerar.</span><span class="sxs-lookup"><span data-stu-id="aee2e-108">Caching works best with data that changes infrequently **and** is expensive to generate.</span></span> <span data-ttu-id="aee2e-109">O Caching faz uma cópia dos dados que podem ser retornados muito mais rápido do que a partir da origem.</span><span class="sxs-lookup"><span data-stu-id="aee2e-109">Caching makes a copy of data that can be returned much faster than from the source.</span></span> <span data-ttu-id="aee2e-110">Os aplicativos devem ser escritos e testados para **nunca** depender de dados armazenados em cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-110">Apps should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="aee2e-111">O ASP.NET Core dá suporte a vários caches diferentes.</span><span class="sxs-lookup"><span data-stu-id="aee2e-111">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="aee2e-112">O cache mais simples é baseado no [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span><span class="sxs-lookup"><span data-stu-id="aee2e-112">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span></span> <span data-ttu-id="aee2e-113">`IMemoryCache`representa um cache armazenado na memória do servidor Web.</span><span class="sxs-lookup"><span data-stu-id="aee2e-113">`IMemoryCache` represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="aee2e-114">Os aplicativos em execução em um farm de servidores (vários servidores) devem garantir que as sessões sejam adesivas ao usar o cache na memória.</span><span class="sxs-lookup"><span data-stu-id="aee2e-114">Apps running on a server farm (multiple servers) should ensure sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="aee2e-115">As sessões adesivas garantem que todas as solicitações subsequentes de um cliente vão para o mesmo servidor.</span><span class="sxs-lookup"><span data-stu-id="aee2e-115">Sticky sessions ensure that subsequent requests from a client all go to the same server.</span></span> <span data-ttu-id="aee2e-116">Por exemplo, os aplicativos Web do Azure usam [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) para rotear todas as solicitações subsequentes para o mesmo servidor.</span><span class="sxs-lookup"><span data-stu-id="aee2e-116">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all subsequent requests to the same server.</span></span>

<span data-ttu-id="aee2e-117">As sessões não adesivas em um web farm exigem um [cache distribuído](distributed.md) para evitar problemas de consistência do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-117">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="aee2e-118">Para alguns aplicativos, um cache distribuído pode dar suporte a escalabilidade horizontal maior que um cache na memória.</span><span class="sxs-lookup"><span data-stu-id="aee2e-118">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="aee2e-119">O uso de um cache distribuído descarrega a memória de cache para um processo externo.</span><span class="sxs-lookup"><span data-stu-id="aee2e-119">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="aee2e-120">O cache na memória pode armazenar qualquer objeto.</span><span class="sxs-lookup"><span data-stu-id="aee2e-120">The in-memory cache can store any object.</span></span> <span data-ttu-id="aee2e-121">A interface de cache distribuído é limitada ao `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="aee2e-121">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="aee2e-122">O armazenamento em cache na memória e distribuído armazena itens de cache como pares de chave-valor.</span><span class="sxs-lookup"><span data-stu-id="aee2e-122">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="aee2e-123">System. Runtime. Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="aee2e-123">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="aee2e-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([Pacote NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) pode ser usado com:</span><span class="sxs-lookup"><span data-stu-id="aee2e-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="aee2e-125">.NET Standard 2,0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="aee2e-125">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="aee2e-126">Qualquer [implementação .net](/dotnet/standard/net-standard#net-implementation-support) que tenha como destino .net Standard 2,0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="aee2e-126">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="aee2e-127">Por exemplo, ASP.NET Core 2,0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="aee2e-127">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="aee2e-128">.NET Framework 4.5 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="aee2e-128">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="aee2e-129">[Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (descrito neste artigo) é recomendado `System.Runtime.Caching` / `MemoryCache` , pois está mais bem integrado ao ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="aee2e-129">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="aee2e-130">Por exemplo, o `IMemoryCache` funciona nativamente com ASP.NET Core [injeção de dependência](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="aee2e-130">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="aee2e-131">Use `System.Runtime.Caching` / `MemoryCache` como uma ponte de compatibilidade ao portar o código do ASP.NET 4. x para ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="aee2e-131">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="aee2e-132">Diretrizes de cache</span><span class="sxs-lookup"><span data-stu-id="aee2e-132">Cache guidelines</span></span>

* <span data-ttu-id="aee2e-133">O código deve sempre ter uma opção de fallback para buscar dados e **não** depende de um valor em cache estar disponível.</span><span class="sxs-lookup"><span data-stu-id="aee2e-133">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="aee2e-134">O cache usa um recurso escasso, memória.</span><span class="sxs-lookup"><span data-stu-id="aee2e-134">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="aee2e-135">Limitar o crescimento do cache:</span><span class="sxs-lookup"><span data-stu-id="aee2e-135">Limit cache growth:</span></span>
  * <span data-ttu-id="aee2e-136">Não **use a** entrada externa como chaves de cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-136">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="aee2e-137">Use expirações para limitar o crescimento do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-137">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="aee2e-138">[Use SetSize, size e SizeLimit para limitar o tamanho do cache](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="aee2e-138">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="aee2e-139">O tempo de execução de ASP.NET Core **não limita o** tamanho do cache com base na pressão de memória.</span><span class="sxs-lookup"><span data-stu-id="aee2e-139">The ASP.NET Core runtime does **not** limit cache size based on memory pressure.</span></span> <span data-ttu-id="aee2e-140">Cabe ao desenvolvedor limitar o tamanho do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-140">It's up to the developer to limit cache size.</span></span>

## <a name="use-imemorycache"></a><span data-ttu-id="aee2e-141">Usar IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="aee2e-141">Use IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="aee2e-142">Usar um cache de memória *compartilhada* de [injeção de dependência](xref:fundamentals/dependency-injection) e chamada `SetSize` , `Size` ou `SizeLimit` para limitar o tamanho do cache pode causar falha no aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aee2e-142">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="aee2e-143">Quando um limite de tamanho é definido em um cache, todas as entradas devem especificar um tamanho ao serem adicionadas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-143">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="aee2e-144">Isso pode levar a problemas, já que os desenvolvedores podem não ter controle total sobre o que usa o cache compartilhado.</span><span class="sxs-lookup"><span data-stu-id="aee2e-144">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="aee2e-145">Por exemplo, Entity Framework Core usa o cache compartilhado e não especifica um tamanho.</span><span class="sxs-lookup"><span data-stu-id="aee2e-145">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="aee2e-146">Se um aplicativo definir um limite de tamanho de cache e usar EF Core, o aplicativo lançará um `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="aee2e-146">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="aee2e-147">Ao usar `SetSize` , `Size` ou `SizeLimit` para limitar o cache, crie um singleton de cache para cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-147">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="aee2e-148">Para obter mais informações e um exemplo, consulte [usar SetSize, tamanho e SizeLimit para limitar o tamanho do cache](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="aee2e-148">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>
> <span data-ttu-id="aee2e-149">Um cache compartilhado é um compartilhado por outras estruturas ou bibliotecas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-149">A shared cache is one shared by other frameworks or libraries.</span></span> <span data-ttu-id="aee2e-150">Por exemplo, EF Core usa o cache compartilhado e não especifica um tamanho.</span><span class="sxs-lookup"><span data-stu-id="aee2e-150">For example, EF Core uses the shared cache and does not specify a size.</span></span> 

<span data-ttu-id="aee2e-151">O cache na memória é um *serviço* que é referenciado de um aplicativo usando [injeção de dependência](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="aee2e-151">In-memory caching is a *service* that's referenced from an app using [Dependency Injection](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="aee2e-152">Solicite a `IMemoryCache` instância no construtor:</span><span class="sxs-lookup"><span data-stu-id="aee2e-152">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="aee2e-153">O código a seguir usa [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) para verificar se há uma hora no cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-153">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="aee2e-154">Se uma hora não for armazenada em cache, uma nova entrada será criada e adicionada ao cache com o [conjunto](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="aee2e-154">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span> <span data-ttu-id="aee2e-155">A `CacheKeys` classe faz parte do exemplo de download.</span><span class="sxs-lookup"><span data-stu-id="aee2e-155">The `CacheKeys` class is part of the download sample.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/CacheKeys.cs)]

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="aee2e-156">A hora atual e a hora em cache são exibidas:</span><span class="sxs-lookup"><span data-stu-id="aee2e-156">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/3.0sample/WebCacheSample/Views/Home/Cache.cshtml)]

<span data-ttu-id="aee2e-157">O valor armazenado em cache `DateTime` permanece no cache enquanto houver solicitações dentro do período de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="aee2e-157">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span>

<span data-ttu-id="aee2e-158">O código a seguir usa [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) e [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) para armazenar dados em cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-158">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="aee2e-159">O código a seguir chama [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) para buscar o tempo em cache:</span><span class="sxs-lookup"><span data-stu-id="aee2e-159">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="aee2e-160">O código a seguir obtém ou cria um item armazenado em cache com expiração absoluta:</span><span class="sxs-lookup"><span data-stu-id="aee2e-160">The following code gets or creates a cached item with absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet99)]

<span data-ttu-id="aee2e-161">Um conjunto de itens em cache com uma expiração deslizante só corre o risco de se tornar obsoleto.</span><span class="sxs-lookup"><span data-stu-id="aee2e-161">A cached item set with a sliding expiration only is at risk of becoming stale.</span></span> <span data-ttu-id="aee2e-162">Se ele for acessado com mais frequência do que o intervalo de expiração deslizante, o item nunca expirará.</span><span class="sxs-lookup"><span data-stu-id="aee2e-162">If it's accessed more frequently than the sliding expiration interval, the item will never expire.</span></span> <span data-ttu-id="aee2e-163">Combine uma expiração deslizante com uma expiração absoluta para garantir que o item expire quando seu tempo de expiração absoluto passar.</span><span class="sxs-lookup"><span data-stu-id="aee2e-163">Combine a sliding expiration with an absolute expiration to guarantee that the item expires once its absolute expiration time passes.</span></span> <span data-ttu-id="aee2e-164">A expiração absoluta define um limite superior para o tempo em que o item pode ser armazenado em cache enquanto ainda permite que o item expire antes, se ele não for solicitado dentro do intervalo de expiração deslizante.</span><span class="sxs-lookup"><span data-stu-id="aee2e-164">The absolute expiration sets an upper bound to how long the item can be cached while still allowing the item to expire earlier if it isn't requested within the sliding expiration interval.</span></span> <span data-ttu-id="aee2e-165">Quando a expiração absoluta e deslizante são especificadas, as expirações são logicamente de or.</span><span class="sxs-lookup"><span data-stu-id="aee2e-165">When both absolute and sliding expiration are specified, the expirations are logically ORed.</span></span> <span data-ttu-id="aee2e-166">Se o intervalo de expiração deslizante *ou* o tempo de expiração absoluto forem aprovados, o item será removido do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-166">If either the sliding expiration interval *or* the absolute expiration time pass, the item is evicted from the cache.</span></span>

<span data-ttu-id="aee2e-167">O código a seguir obtém ou cria um item armazenado em cache com a expiração deslizante *e* absoluta:</span><span class="sxs-lookup"><span data-stu-id="aee2e-167">The following code gets or creates a cached item with both sliding *and* absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet9)]

<span data-ttu-id="aee2e-168">O código anterior garante que os dados não serão armazenados em cache mais do que o tempo absoluto.</span><span class="sxs-lookup"><span data-stu-id="aee2e-168">The preceding code guarantees the data will not be cached longer than the absolute time.</span></span>

<span data-ttu-id="aee2e-169"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> e <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> são métodos de extensão na <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> classe.</span><span class="sxs-lookup"><span data-stu-id="aee2e-169"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> are extension methods in the <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> class.</span></span> <span data-ttu-id="aee2e-170">Esses métodos ampliam a capacidade do <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="aee2e-170">These methods extend the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="aee2e-171">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="aee2e-171">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="aee2e-172">O exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="aee2e-172">The following sample:</span></span>

* <span data-ttu-id="aee2e-173">Define um tempo de expiração deslizante.</span><span class="sxs-lookup"><span data-stu-id="aee2e-173">Sets a sliding expiration time.</span></span> <span data-ttu-id="aee2e-174">As solicitações que acessam este item armazenado em cache redefinirão o relógio de expiração deslizante.</span><span class="sxs-lookup"><span data-stu-id="aee2e-174">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="aee2e-175">Define a prioridade do cache como [CacheItemPriority. NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span><span class="sxs-lookup"><span data-stu-id="aee2e-175">Sets the cache priority to [CacheItemPriority.NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span></span>
* <span data-ttu-id="aee2e-176">Define um [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) que será chamado depois que a entrada for removida do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-176">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="aee2e-177">O retorno de chamada é executado em um thread diferente do código que remove o item do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-177">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="aee2e-178">Use SetSize, size e SizeLimit para limitar o tamanho do cache</span><span class="sxs-lookup"><span data-stu-id="aee2e-178">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="aee2e-179">Uma `MemoryCache` instância pode, opcionalmente, especificar e impor um limite de tamanho.</span><span class="sxs-lookup"><span data-stu-id="aee2e-179">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="aee2e-180">O limite de tamanho do cache não tem uma unidade de medida definida porque o cache não tem nenhum mecanismo para medir o tamanho das entradas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-180">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="aee2e-181">Se o limite de tamanho do cache for definido, todas as entradas deverão especificar tamanho.</span><span class="sxs-lookup"><span data-stu-id="aee2e-181">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="aee2e-182">O tempo de execução de ASP.NET Core não limita o tamanho do cache com base na pressão de memória.</span><span class="sxs-lookup"><span data-stu-id="aee2e-182">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="aee2e-183">Cabe ao desenvolvedor limitar o tamanho do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-183">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="aee2e-184">O tamanho especificado é em unidades que o desenvolvedor escolhe.</span><span class="sxs-lookup"><span data-stu-id="aee2e-184">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="aee2e-185">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="aee2e-185">For example:</span></span>

* <span data-ttu-id="aee2e-186">Se o aplicativo Web estava armazenando cadeia de caracteres em cache principalmente, cada tamanho de entrada de cache poderia ser o comprimento da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="aee2e-186">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="aee2e-187">O aplicativo pode especificar o tamanho de todas as entradas como 1 e o limite de tamanho é a contagem de entradas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-187">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="aee2e-188">Se <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> não estiver definido, o cache aumentará sem limite.</span><span class="sxs-lookup"><span data-stu-id="aee2e-188">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> isn't set, the cache grows without bound.</span></span> <span data-ttu-id="aee2e-189">O tempo de execução de ASP.NET Core não corta o cache quando a memória do sistema está baixa.</span><span class="sxs-lookup"><span data-stu-id="aee2e-189">The ASP.NET Core runtime doesn't trim the cache when system memory is low.</span></span> <span data-ttu-id="aee2e-190">Os aplicativos devem ser arquitetados para:</span><span class="sxs-lookup"><span data-stu-id="aee2e-190">Apps must be architected to:</span></span>

* <span data-ttu-id="aee2e-191">Limitar o crescimento do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-191">Limit cache growth.</span></span>
* <span data-ttu-id="aee2e-192">A chamada <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> ou <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> quando a memória disponível é limitada:</span><span class="sxs-lookup"><span data-stu-id="aee2e-192">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="aee2e-193">O código a seguir cria um tamanho fixo não unitário <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> acessível por [injeção de dependência](xref:fundamentals/dependency-injection):</span><span class="sxs-lookup"><span data-stu-id="aee2e-193">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="aee2e-194">`SizeLimit`Não tem unidades.</span><span class="sxs-lookup"><span data-stu-id="aee2e-194">`SizeLimit` does not have units.</span></span> <span data-ttu-id="aee2e-195">As entradas armazenadas em cache devem especificar o tamanho em qualquer unidade que julgar mais apropriada se o limite de tamanho do cache tiver sido definido.</span><span class="sxs-lookup"><span data-stu-id="aee2e-195">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="aee2e-196">Todos os usuários de uma instância de cache devem usar o mesmo sistema de unidade.</span><span class="sxs-lookup"><span data-stu-id="aee2e-196">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="aee2e-197">Uma entrada não será armazenada em cache se a soma dos tamanhos de entrada armazenados em cache exceder o valor especificado por `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="aee2e-197">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="aee2e-198">Se nenhum limite de tamanho de cache for definido, o tamanho do cache definido na entrada será ignorado.</span><span class="sxs-lookup"><span data-stu-id="aee2e-198">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="aee2e-199">O código a seguir é registrado `MyMemoryCache` com o contêiner de [injeção de dependência](xref:fundamentals/dependency-injection) .</span><span class="sxs-lookup"><span data-stu-id="aee2e-199">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Startup.cs?name=snippet)]

<span data-ttu-id="aee2e-200">`MyMemoryCache`é criado como um cache de memória independente para componentes que reconhecem esse cache de tamanho limitado e sabem como definir adequadamente o tamanho de entrada de cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-200">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="aee2e-201">O código a seguir usa `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="aee2e-201">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet)]

<span data-ttu-id="aee2e-202">O tamanho da entrada de cache pode ser definido por <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> ou pelos <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> métodos de extensão:</span><span class="sxs-lookup"><span data-stu-id="aee2e-202">The size of the cache entry can be set by <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> or the <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> extension methods:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="aee2e-203">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="aee2e-203">MemoryCache.Compact</span></span>

<span data-ttu-id="aee2e-204">`MemoryCache.Compact`tenta remover o percentual especificado do cache na seguinte ordem:</span><span class="sxs-lookup"><span data-stu-id="aee2e-204">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="aee2e-205">Todos os itens expirados.</span><span class="sxs-lookup"><span data-stu-id="aee2e-205">All expired items.</span></span>
* <span data-ttu-id="aee2e-206">Itens por prioridade.</span><span class="sxs-lookup"><span data-stu-id="aee2e-206">Items by priority.</span></span> <span data-ttu-id="aee2e-207">Os itens de prioridade mais baixa são removidos primeiro.</span><span class="sxs-lookup"><span data-stu-id="aee2e-207">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="aee2e-208">Objetos usados menos recentemente.</span><span class="sxs-lookup"><span data-stu-id="aee2e-208">Least recently used objects.</span></span>
* <span data-ttu-id="aee2e-209">Itens com a expiração absoluta mais antiga.</span><span class="sxs-lookup"><span data-stu-id="aee2e-209">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="aee2e-210">Itens com a expiração deslizante mais antiga.</span><span class="sxs-lookup"><span data-stu-id="aee2e-210">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="aee2e-211">Itens fixados com prioridade <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> nunca são removidos.</span><span class="sxs-lookup"><span data-stu-id="aee2e-211">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span> <span data-ttu-id="aee2e-212">O código a seguir remove um item de cache e chama `Compact` :</span><span class="sxs-lookup"><span data-stu-id="aee2e-212">The following code removes a cache item and calls `Compact`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="aee2e-213">Consulte [Compact Source no GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="aee2e-213">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="aee2e-214">Dependências de cache</span><span class="sxs-lookup"><span data-stu-id="aee2e-214">Cache dependencies</span></span>

<span data-ttu-id="aee2e-215">O exemplo a seguir mostra como expirar uma entrada de cache se uma entrada dependente expirar.</span><span class="sxs-lookup"><span data-stu-id="aee2e-215">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="aee2e-216">Um <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> é adicionado ao item armazenado em cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-216">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="aee2e-217">Quando `Cancel` é chamado no `CancellationTokenSource` , ambas as entradas de cache são removidas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-217">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="aee2e-218">O uso de um <xref:System.Threading.CancellationTokenSource> permite que várias entradas de cache sejam removidas como um grupo.</span><span class="sxs-lookup"><span data-stu-id="aee2e-218">Using a <xref:System.Threading.CancellationTokenSource> allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="aee2e-219">Com o `using` padrão no código acima, as entradas de cache criadas dentro do `using` bloco herdarão os gatilhos e as configurações de expiração.</span><span class="sxs-lookup"><span data-stu-id="aee2e-219">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="aee2e-220">Observações adicionais</span><span class="sxs-lookup"><span data-stu-id="aee2e-220">Additional notes</span></span>

* <span data-ttu-id="aee2e-221">A expiração não ocorre em segundo plano.</span><span class="sxs-lookup"><span data-stu-id="aee2e-221">Expiration doesn't happen in the background.</span></span> <span data-ttu-id="aee2e-222">Não há nenhum temporizador que examina ativamente o cache em busca de itens expirados.</span><span class="sxs-lookup"><span data-stu-id="aee2e-222">There is no timer that actively scans the cache for expired items.</span></span> <span data-ttu-id="aee2e-223">Qualquer atividade no cache ( `Get` , `Set` , `Remove` ) pode disparar uma verificação em segundo plano para itens expirados.</span><span class="sxs-lookup"><span data-stu-id="aee2e-223">Any activity on the cache (`Get`, `Set`, `Remove`) can trigger a background scan for expired items.</span></span> <span data-ttu-id="aee2e-224">Um temporizador no `CancellationTokenSource` ( <xref:System.Threading.CancellationTokenSource.CancelAfter*> ) também remove a entrada e dispara uma verificação de itens expirados.</span><span class="sxs-lookup"><span data-stu-id="aee2e-224">A timer on the `CancellationTokenSource` (<xref:System.Threading.CancellationTokenSource.CancelAfter*>) also removes the entry and trigger a scan for expired items.</span></span> <span data-ttu-id="aee2e-225">O exemplo a seguir usa [CancellationTokenSource (TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) para o token registrado.</span><span class="sxs-lookup"><span data-stu-id="aee2e-225">The following example uses [CancellationTokenSource(TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) for the registered token.</span></span> <span data-ttu-id="aee2e-226">Quando esse token é disparado, ele remove a entrada imediatamente e dispara os retornos de chamada de remoção:</span><span class="sxs-lookup"><span data-stu-id="aee2e-226">When this token fires it removes the entry immediately and fires the eviction callbacks:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ae)]

* <span data-ttu-id="aee2e-227">Ao usar um retorno de chamada para popular novamente um item de cache:</span><span class="sxs-lookup"><span data-stu-id="aee2e-227">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="aee2e-228">Várias solicitações podem encontrar o valor de chave em cache vazio porque o retorno de chamada não foi concluído.</span><span class="sxs-lookup"><span data-stu-id="aee2e-228">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="aee2e-229">Isso pode resultar em vários threads repopulando o item armazenado em cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-229">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="aee2e-230">Quando uma entrada de cache é usada para criar outra, o filho copia os tokens de expiração da entrada pai e as configurações de expiração com base no tempo.</span><span class="sxs-lookup"><span data-stu-id="aee2e-230">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="aee2e-231">O filho não expirou pela remoção manual ou pela atualização da entrada pai.</span><span class="sxs-lookup"><span data-stu-id="aee2e-231">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="aee2e-232">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> para definir os retornos de chamada que serão acionados depois que a entrada de cache for removida do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-232">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>
* <span data-ttu-id="aee2e-233">Para a maioria dos aplicativos, o `IMemoryCache` está habilitado.</span><span class="sxs-lookup"><span data-stu-id="aee2e-233">For most apps, `IMemoryCache` is enabled.</span></span> <span data-ttu-id="aee2e-234">Por exemplo, a chamada `AddMvc` ,, `AddControllersWithViews` `AddRazorPages` , `AddMvcCore().AddRazorViewEngine` e muitos outros `Add{Service}` métodos no `ConfigureServices` , habilita `IMemoryCache` .</span><span class="sxs-lookup"><span data-stu-id="aee2e-234">For example, calling `AddMvc`, `AddControllersWithViews`, `AddRazorPages`, `AddMvcCore().AddRazorViewEngine`, and many other `Add{Service}` methods in `ConfigureServices`, enables `IMemoryCache`.</span></span> <span data-ttu-id="aee2e-235">Para aplicativos que não chamam um dos `Add{Service}` métodos anteriores, pode ser necessário chamar <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> in `ConfigureServices` .</span><span class="sxs-lookup"><span data-stu-id="aee2e-235">For apps that are not calling one of the preceding `Add{Service}` methods, it may be necessary to call <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> in `ConfigureServices`.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="aee2e-236">Atualização do cache em segundo plano</span><span class="sxs-lookup"><span data-stu-id="aee2e-236">Background cache update</span></span>

<span data-ttu-id="aee2e-237">Use um [serviço em segundo plano](xref:fundamentals/host/hosted-services) , como <xref:Microsoft.Extensions.Hosting.IHostedService> para atualizar o cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-237">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="aee2e-238">O serviço de segundo plano pode recalcular as entradas e, em seguida, atribuí-las ao cache somente quando elas estiverem prontas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-238">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="aee2e-239">Recursos adicionais</span><span class="sxs-lookup"><span data-stu-id="aee2e-239">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end

::: moniker range="< aspnetcore-3.0"

<!-- This is the 2.1 version -->
<span data-ttu-id="aee2e-240">Por [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo)e [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="aee2e-240">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="aee2e-241">[Exibir ou baixar código de exemplo](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([como baixar](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="aee2e-241">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="aee2e-242">Noções básicas de cache</span><span class="sxs-lookup"><span data-stu-id="aee2e-242">Caching basics</span></span>

<span data-ttu-id="aee2e-243">O Caching pode melhorar significativamente o desempenho e a escalabilidade de um aplicativo, reduzindo o trabalho necessário para gerar conteúdo.</span><span class="sxs-lookup"><span data-stu-id="aee2e-243">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="aee2e-244">O Caching funciona melhor com dados que são alterados com pouca frequência.</span><span class="sxs-lookup"><span data-stu-id="aee2e-244">Caching works best with data that changes infrequently.</span></span> <span data-ttu-id="aee2e-245">O Caching faz uma cópia dos dados que podem ser retornados muito mais rápido do que a partir da fonte original.</span><span class="sxs-lookup"><span data-stu-id="aee2e-245">Caching makes a copy of data that can be returned much faster than from the original source.</span></span> <span data-ttu-id="aee2e-246">O código deve ser escrito e testado para **nunca** depender de dados armazenados em cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-246">Code should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="aee2e-247">O ASP.NET Core dá suporte a vários caches diferentes.</span><span class="sxs-lookup"><span data-stu-id="aee2e-247">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="aee2e-248">O cache mais simples é baseado no [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), que representa um cache armazenado na memória do servidor Web.</span><span class="sxs-lookup"><span data-stu-id="aee2e-248">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), which represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="aee2e-249">Os aplicativos que são executados em um farm de servidores (vários servidores) devem garantir que as sessões sejam adesivas ao usar o cache na memória.</span><span class="sxs-lookup"><span data-stu-id="aee2e-249">Apps that run on a server farm (multiple servers) should ensure that sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="aee2e-250">As sessões adesivas garantem que todas as solicitações posteriores de um cliente passem para o mesmo servidor.</span><span class="sxs-lookup"><span data-stu-id="aee2e-250">Sticky sessions ensure that later requests from a client all go to the same server.</span></span> <span data-ttu-id="aee2e-251">Por exemplo, os aplicativos Web do Azure usam [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) para rotear todas as solicitações de um agente do usuário para o mesmo servidor.</span><span class="sxs-lookup"><span data-stu-id="aee2e-251">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all requests from a user agent to the same server.</span></span>

<span data-ttu-id="aee2e-252">As sessões não adesivas em um web farm exigem um [cache distribuído](distributed.md) para evitar problemas de consistência do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-252">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="aee2e-253">Para alguns aplicativos, um cache distribuído pode dar suporte a escalabilidade horizontal maior que um cache na memória.</span><span class="sxs-lookup"><span data-stu-id="aee2e-253">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="aee2e-254">O uso de um cache distribuído descarrega a memória de cache para um processo externo.</span><span class="sxs-lookup"><span data-stu-id="aee2e-254">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="aee2e-255">O cache na memória pode armazenar qualquer objeto.</span><span class="sxs-lookup"><span data-stu-id="aee2e-255">The in-memory cache can store any object.</span></span> <span data-ttu-id="aee2e-256">A interface de cache distribuído é limitada ao `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="aee2e-256">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="aee2e-257">O armazenamento em cache na memória e distribuído armazena itens de cache como pares de chave-valor.</span><span class="sxs-lookup"><span data-stu-id="aee2e-257">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="aee2e-258">System. Runtime. Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="aee2e-258">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="aee2e-259"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([Pacote NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) pode ser usado com:</span><span class="sxs-lookup"><span data-stu-id="aee2e-259"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="aee2e-260">.NET Standard 2,0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="aee2e-260">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="aee2e-261">Qualquer [implementação .net](/dotnet/standard/net-standard#net-implementation-support) que tenha como destino .net Standard 2,0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="aee2e-261">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="aee2e-262">Por exemplo, ASP.NET Core 2,0 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="aee2e-262">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="aee2e-263">.NET Framework 4.5 ou posterior.</span><span class="sxs-lookup"><span data-stu-id="aee2e-263">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="aee2e-264">[Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (descrito neste artigo) é recomendado `System.Runtime.Caching` / `MemoryCache` , pois está mais bem integrado ao ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="aee2e-264">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="aee2e-265">Por exemplo, o `IMemoryCache` funciona nativamente com ASP.NET Core [injeção de dependência](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="aee2e-265">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="aee2e-266">Use `System.Runtime.Caching` / `MemoryCache` como uma ponte de compatibilidade ao portar o código do ASP.NET 4. x para ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="aee2e-266">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="aee2e-267">Diretrizes de cache</span><span class="sxs-lookup"><span data-stu-id="aee2e-267">Cache guidelines</span></span>

* <span data-ttu-id="aee2e-268">O código deve sempre ter uma opção de fallback para buscar dados e **não** depende de um valor em cache estar disponível.</span><span class="sxs-lookup"><span data-stu-id="aee2e-268">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="aee2e-269">O cache usa um recurso escasso, memória.</span><span class="sxs-lookup"><span data-stu-id="aee2e-269">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="aee2e-270">Limitar o crescimento do cache:</span><span class="sxs-lookup"><span data-stu-id="aee2e-270">Limit cache growth:</span></span>
  * <span data-ttu-id="aee2e-271">Não **use a** entrada externa como chaves de cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-271">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="aee2e-272">Use expirações para limitar o crescimento do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-272">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="aee2e-273">[Use SetSize, size e SizeLimit para limitar o tamanho do cache](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="aee2e-273">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="aee2e-274">O tempo de execução de ASP.NET Core não limita o tamanho do cache com base na pressão de memória.</span><span class="sxs-lookup"><span data-stu-id="aee2e-274">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="aee2e-275">Cabe ao desenvolvedor limitar o tamanho do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-275">It's up to the developer to limit cache size.</span></span>

## <a name="using-imemorycache"></a><span data-ttu-id="aee2e-276">Usando IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="aee2e-276">Using IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="aee2e-277">Usar um cache de memória *compartilhada* de [injeção de dependência](xref:fundamentals/dependency-injection) e chamada `SetSize` , `Size` ou `SizeLimit` para limitar o tamanho do cache pode causar falha no aplicativo.</span><span class="sxs-lookup"><span data-stu-id="aee2e-277">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="aee2e-278">Quando um limite de tamanho é definido em um cache, todas as entradas devem especificar um tamanho ao serem adicionadas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-278">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="aee2e-279">Isso pode levar a problemas, já que os desenvolvedores podem não ter controle total sobre o que usa o cache compartilhado.</span><span class="sxs-lookup"><span data-stu-id="aee2e-279">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="aee2e-280">Por exemplo, Entity Framework Core usa o cache compartilhado e não especifica um tamanho.</span><span class="sxs-lookup"><span data-stu-id="aee2e-280">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="aee2e-281">Se um aplicativo definir um limite de tamanho de cache e usar EF Core, o aplicativo lançará um `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="aee2e-281">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="aee2e-282">Ao usar `SetSize` , `Size` ou `SizeLimit` para limitar o cache, crie um singleton de cache para cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-282">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="aee2e-283">Para obter mais informações e um exemplo, consulte [usar SetSize, tamanho e SizeLimit para limitar o tamanho do cache](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="aee2e-283">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>

<span data-ttu-id="aee2e-284">O cache na memória é um *serviço* que é referenciado de seu aplicativo usando [injeção de dependência](../../fundamentals/dependency-injection.md).</span><span class="sxs-lookup"><span data-stu-id="aee2e-284">In-memory caching is a *service* that's referenced from your app using [Dependency Injection](../../fundamentals/dependency-injection.md).</span></span> <span data-ttu-id="aee2e-285">Chamada `AddMemoryCache` em `ConfigureServices` :</span><span class="sxs-lookup"><span data-stu-id="aee2e-285">Call `AddMemoryCache` in `ConfigureServices`:</span></span>

[!code-csharp[](memory/sample/WebCache/Startup.cs?highlight=9)]

<span data-ttu-id="aee2e-286">Solicite a `IMemoryCache` instância no construtor:</span><span class="sxs-lookup"><span data-stu-id="aee2e-286">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="aee2e-287">`IMemoryCache`requer o pacote NuGet [Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), que está disponível no [metapacote Microsoft. AspNetCore. app](xref:fundamentals/metapackage-app).</span><span class="sxs-lookup"><span data-stu-id="aee2e-287">`IMemoryCache` requires NuGet package [Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), which is available in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app).</span></span>

<span data-ttu-id="aee2e-288">O código a seguir usa [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) para verificar se há uma hora no cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-288">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="aee2e-289">Se uma hora não for armazenada em cache, uma nova entrada será criada e adicionada ao cache com o [conjunto](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="aee2e-289">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span>

[!code-csharp[](memory/sample/WebCache/CacheKeys.cs)]

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="aee2e-290">A hora atual e a hora em cache são exibidas:</span><span class="sxs-lookup"><span data-stu-id="aee2e-290">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/sample/WebCache/Views/Home/Cache.cshtml)]

<span data-ttu-id="aee2e-291">O valor armazenado em cache `DateTime` permanece no cache enquanto houver solicitações dentro do período de tempo limite.</span><span class="sxs-lookup"><span data-stu-id="aee2e-291">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span> <span data-ttu-id="aee2e-292">A imagem a seguir mostra a hora atual e uma hora mais antiga recuperada do cache:</span><span class="sxs-lookup"><span data-stu-id="aee2e-292">The following image shows the current time and an older time retrieved from the cache:</span></span>

![Exibição de índice com duas horas diferentes exibidas](memory/_static/time.png)

<span data-ttu-id="aee2e-294">O código a seguir usa [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) e [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) para armazenar dados em cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-294">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="aee2e-295">O código a seguir chama [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) para buscar o tempo em cache:</span><span class="sxs-lookup"><span data-stu-id="aee2e-295">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="aee2e-296"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> e [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) são os métodos de extensão que fazem parte da classe [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) que estende a capacidade de <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="aee2e-296"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) are extension methods part of the [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) class that extends the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span> <span data-ttu-id="aee2e-297">Consulte [métodos IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) e [métodos CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) para obter uma descrição de outros métodos de cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-297">See [IMemoryCache methods](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) and [CacheExtensions methods](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) for a description of other cache methods.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="aee2e-298">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="aee2e-298">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="aee2e-299">O exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="aee2e-299">The following sample:</span></span>

* <span data-ttu-id="aee2e-300">Define um tempo de expiração deslizante.</span><span class="sxs-lookup"><span data-stu-id="aee2e-300">Sets a sliding expiration time.</span></span> <span data-ttu-id="aee2e-301">As solicitações que acessam este item armazenado em cache redefinirão o relógio de expiração deslizante.</span><span class="sxs-lookup"><span data-stu-id="aee2e-301">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="aee2e-302">Define a prioridade do cache como `CacheItemPriority.NeverRemove` .</span><span class="sxs-lookup"><span data-stu-id="aee2e-302">Sets the cache priority to `CacheItemPriority.NeverRemove`.</span></span>
* <span data-ttu-id="aee2e-303">Define um [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) que será chamado depois que a entrada for removida do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-303">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="aee2e-304">O retorno de chamada é executado em um thread diferente do código que remove o item do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-304">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="aee2e-305">Use SetSize, size e SizeLimit para limitar o tamanho do cache</span><span class="sxs-lookup"><span data-stu-id="aee2e-305">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="aee2e-306">Uma `MemoryCache` instância pode, opcionalmente, especificar e impor um limite de tamanho.</span><span class="sxs-lookup"><span data-stu-id="aee2e-306">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="aee2e-307">O limite de tamanho do cache não tem uma unidade de medida definida porque o cache não tem nenhum mecanismo para medir o tamanho das entradas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-307">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="aee2e-308">Se o limite de tamanho do cache for definido, todas as entradas deverão especificar tamanho.</span><span class="sxs-lookup"><span data-stu-id="aee2e-308">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="aee2e-309">O tempo de execução de ASP.NET Core não limita o tamanho do cache com base na pressão de memória.</span><span class="sxs-lookup"><span data-stu-id="aee2e-309">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="aee2e-310">Cabe ao desenvolvedor limitar o tamanho do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-310">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="aee2e-311">O tamanho especificado é em unidades que o desenvolvedor escolhe.</span><span class="sxs-lookup"><span data-stu-id="aee2e-311">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="aee2e-312">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="aee2e-312">For example:</span></span>

* <span data-ttu-id="aee2e-313">Se o aplicativo Web estava armazenando cadeia de caracteres em cache principalmente, cada tamanho de entrada de cache poderia ser o comprimento da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="aee2e-313">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="aee2e-314">O aplicativo pode especificar o tamanho de todas as entradas como 1 e o limite de tamanho é a contagem de entradas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-314">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="aee2e-315">Se <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> não estiver definido, o cache aumentará sem limite.</span><span class="sxs-lookup"><span data-stu-id="aee2e-315">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> is not set, the cache grows without bound.</span></span> <span data-ttu-id="aee2e-316">O tempo de execução de ASP.NET Core não corta o cache quando a memória do sistema está baixa.</span><span class="sxs-lookup"><span data-stu-id="aee2e-316">The ASP.NET Core runtime does not trim the cache when system memory is low.</span></span> <span data-ttu-id="aee2e-317">Muitos aplicativos foram arquitetados para:</span><span class="sxs-lookup"><span data-stu-id="aee2e-317">Apps much be architected to:</span></span>

* <span data-ttu-id="aee2e-318">Limitar o crescimento do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-318">Limit cache growth.</span></span>
* <span data-ttu-id="aee2e-319">A chamada <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> ou <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> quando a memória disponível é limitada:</span><span class="sxs-lookup"><span data-stu-id="aee2e-319">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="aee2e-320">O código a seguir cria um tamanho fixo não unitário <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> acessível por [injeção de dependência](xref:fundamentals/dependency-injection):</span><span class="sxs-lookup"><span data-stu-id="aee2e-320">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="aee2e-321">`SizeLimit`Não tem unidades.</span><span class="sxs-lookup"><span data-stu-id="aee2e-321">`SizeLimit` does not have units.</span></span> <span data-ttu-id="aee2e-322">As entradas armazenadas em cache devem especificar o tamanho em qualquer unidade que julgar mais apropriada se o limite de tamanho do cache tiver sido definido.</span><span class="sxs-lookup"><span data-stu-id="aee2e-322">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="aee2e-323">Todos os usuários de uma instância de cache devem usar o mesmo sistema de unidade.</span><span class="sxs-lookup"><span data-stu-id="aee2e-323">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="aee2e-324">Uma entrada não será armazenada em cache se a soma dos tamanhos de entrada armazenados em cache exceder o valor especificado por `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="aee2e-324">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="aee2e-325">Se nenhum limite de tamanho de cache for definido, o tamanho do cache definido na entrada será ignorado.</span><span class="sxs-lookup"><span data-stu-id="aee2e-325">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="aee2e-326">O código a seguir é registrado `MyMemoryCache` com o contêiner de [injeção de dependência](xref:fundamentals/dependency-injection) .</span><span class="sxs-lookup"><span data-stu-id="aee2e-326">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/sample/RPcache/Startup.cs?name=snippet&highlight=5)]

<span data-ttu-id="aee2e-327">`MyMemoryCache`é criado como um cache de memória independente para componentes que reconhecem esse cache de tamanho limitado e sabem como definir adequadamente o tamanho de entrada de cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-327">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="aee2e-328">O código a seguir usa `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="aee2e-328">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet)]

<span data-ttu-id="aee2e-329">O tamanho da entrada de cache pode ser definido por [tamanho](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) ou pelo método de extensão [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) :</span><span class="sxs-lookup"><span data-stu-id="aee2e-329">The size of the cache entry can be set by [Size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) or the [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) extension method:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="aee2e-330">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="aee2e-330">MemoryCache.Compact</span></span>

<span data-ttu-id="aee2e-331">`MemoryCache.Compact`tenta remover o percentual especificado do cache na seguinte ordem:</span><span class="sxs-lookup"><span data-stu-id="aee2e-331">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="aee2e-332">Todos os itens expirados.</span><span class="sxs-lookup"><span data-stu-id="aee2e-332">All expired items.</span></span>
* <span data-ttu-id="aee2e-333">Itens por prioridade.</span><span class="sxs-lookup"><span data-stu-id="aee2e-333">Items by priority.</span></span> <span data-ttu-id="aee2e-334">Os itens de prioridade mais baixa são removidos primeiro.</span><span class="sxs-lookup"><span data-stu-id="aee2e-334">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="aee2e-335">Objetos usados menos recentemente.</span><span class="sxs-lookup"><span data-stu-id="aee2e-335">Least recently used objects.</span></span>
* <span data-ttu-id="aee2e-336">Itens com a expiração absoluta mais antiga.</span><span class="sxs-lookup"><span data-stu-id="aee2e-336">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="aee2e-337">Itens com a expiração deslizante mais antiga.</span><span class="sxs-lookup"><span data-stu-id="aee2e-337">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="aee2e-338">Itens fixados com prioridade <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> nunca são removidos.</span><span class="sxs-lookup"><span data-stu-id="aee2e-338">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="aee2e-339">Consulte [Compact Source no GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="aee2e-339">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="aee2e-340">Dependências de cache</span><span class="sxs-lookup"><span data-stu-id="aee2e-340">Cache dependencies</span></span>

<span data-ttu-id="aee2e-341">O exemplo a seguir mostra como expirar uma entrada de cache se uma entrada dependente expirar.</span><span class="sxs-lookup"><span data-stu-id="aee2e-341">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="aee2e-342">Um <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> é adicionado ao item armazenado em cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-342">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="aee2e-343">Quando `Cancel` é chamado no `CancellationTokenSource` , ambas as entradas de cache são removidas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-343">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="aee2e-344">O uso de um `CancellationTokenSource` permite que várias entradas de cache sejam removidas como um grupo.</span><span class="sxs-lookup"><span data-stu-id="aee2e-344">Using a `CancellationTokenSource` allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="aee2e-345">Com o `using` padrão no código acima, as entradas de cache criadas dentro do `using` bloco herdarão os gatilhos e as configurações de expiração.</span><span class="sxs-lookup"><span data-stu-id="aee2e-345">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="aee2e-346">Observações adicionais</span><span class="sxs-lookup"><span data-stu-id="aee2e-346">Additional notes</span></span>

* <span data-ttu-id="aee2e-347">Ao usar um retorno de chamada para popular novamente um item de cache:</span><span class="sxs-lookup"><span data-stu-id="aee2e-347">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="aee2e-348">Várias solicitações podem encontrar o valor de chave em cache vazio porque o retorno de chamada não foi concluído.</span><span class="sxs-lookup"><span data-stu-id="aee2e-348">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="aee2e-349">Isso pode resultar em vários threads repopulando o item armazenado em cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-349">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="aee2e-350">Quando uma entrada de cache é usada para criar outra, o filho copia os tokens de expiração da entrada pai e as configurações de expiração com base no tempo.</span><span class="sxs-lookup"><span data-stu-id="aee2e-350">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="aee2e-351">O filho não expirou pela remoção manual ou pela atualização da entrada pai.</span><span class="sxs-lookup"><span data-stu-id="aee2e-351">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="aee2e-352">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) para definir os retornos de chamada que serão acionados depois que a entrada de cache for removida do cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-352">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="aee2e-353">Atualização do cache em segundo plano</span><span class="sxs-lookup"><span data-stu-id="aee2e-353">Background cache update</span></span>

<span data-ttu-id="aee2e-354">Use um [serviço em segundo plano](xref:fundamentals/host/hosted-services) , como <xref:Microsoft.Extensions.Hosting.IHostedService> para atualizar o cache.</span><span class="sxs-lookup"><span data-stu-id="aee2e-354">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="aee2e-355">O serviço de segundo plano pode recalcular as entradas e, em seguida, atribuí-las ao cache somente quando elas estiverem prontas.</span><span class="sxs-lookup"><span data-stu-id="aee2e-355">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="aee2e-356">Recursos adicionais</span><span class="sxs-lookup"><span data-stu-id="aee2e-356">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end
